(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (Buffer){
'use strict';


var path = _dereq_('path');
var pump = _dereq_('pump');
var LocalMessageDuplexStream = _dereq_('post-message-stream');
var PongStream = _dereq_('ping-pong-stream/pong');
var ObjectMultiplex = _dereq_('obj-multiplex');
var extension = _dereq_('extensionizer');
var PortStream = _dereq_('./lib/port-stream.js');

var inpageContent = Buffer("KGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT0iZnVuY3Rpb24iJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKCJDYW5ub3QgZmluZCBtb2R1bGUgJyIrbysiJyIpO3Rocm93IGYuY29kZT0iTU9EVUxFX05PVF9GT1VORCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT0iZnVuY3Rpb24iJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAoZ2xvYmFsKXsKJ3VzZSBzdHJpY3QnOwoKLypnbG9iYWwgV2ViMyovCmNsZWFuQ29udGV4dEZvckltcG9ydHMoKTsKX2RlcmVxXygnd2ViMy9kaXN0L3dlYjMubWluLmpzJyk7CnZhciBsb2cgPSBfZGVyZXFfKCdsb2dsZXZlbCcpOwp2YXIgTG9jYWxNZXNzYWdlRHVwbGV4U3RyZWFtID0gX2RlcmVxXygncG9zdC1tZXNzYWdlLXN0cmVhbScpOwovLyBjb25zdCBQaW5nU3RyZWFtID0gcmVxdWlyZSgncGluZy1wb25nLXN0cmVhbS9waW5nJykKLy8gY29uc3QgZW5kT2ZTdHJlYW0gPSByZXF1aXJlKCdlbmQtb2Ytc3RyZWFtJykKdmFyIHNldHVwRGFwcEF1dG9SZWxvYWQgPSBfZGVyZXFfKCcuL2xpYi9hdXRvLXJlbG9hZC5qcycpOwp2YXIgTWV0YW1hc2tJbnBhZ2VQcm92aWRlciA9IF9kZXJlcV8oJy4vbGliL2lucGFnZS1wcm92aWRlci5qcycpOwpyZXN0b3JlQ29udGV4dEFmdGVySW1wb3J0cygpOwoKdmFyIE1FVEFNQVNLX0RFQlVHID0gdW5kZWZpbmVkOwp3aW5kb3cubG9nID0gbG9nOwpsb2cuc2V0RGVmYXVsdExldmVsKE1FVEFNQVNLX0RFQlVHID8gJ2RlYnVnJyA6ICd3YXJuJyk7CgovLwovLyBzZXR1cCBwbHVnaW4gY29tbXVuaWNhdGlvbgovLwoKLy8gc2V0dXAgYmFja2dyb3VuZCBjb25uZWN0aW9uCnZhciBtZXRhbWFza1N0cmVhbSA9IG5ldyBMb2NhbE1lc3NhZ2VEdXBsZXhTdHJlYW0oewogIG5hbWU6ICdpbnBhZ2UnLAogIHRhcmdldDogJ2NvbnRlbnRzY3JpcHQnCn0pOwoKLy8gY29tcG9zZSB0aGUgaW5wYWdlIHByb3ZpZGVyCnZhciBpbnBhZ2VQcm92aWRlciA9IG5ldyBNZXRhbWFza0lucGFnZVByb3ZpZGVyKG1ldGFtYXNrU3RyZWFtKTsKCi8vCi8vIHNldHVwIHdlYjMKLy8KCmlmICh0eXBlb2Ygd2luZG93LndlYjMgIT09ICd1bmRlZmluZWQnKSB7CiAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayBkZXRlY3RlZCBhbm90aGVyIHdlYjMuXG4gICAgIE1ldGFNYXNrIHdpbGwgbm90IHdvcmsgcmVsaWFibHkgd2l0aCBhbm90aGVyIHdlYjMgZXh0ZW5zaW9uLlxuICAgICBUaGlzIHVzdWFsbHkgaGFwcGVucyBpZiB5b3UgaGF2ZSB0d28gTWV0YU1hc2tzIGluc3RhbGxlZCxcbiAgICAgb3IgTWV0YU1hc2sgYW5kIGFub3RoZXIgd2ViMyBleHRlbnNpb24uIFBsZWFzZSByZW1vdmUgb25lXG4gICAgIGFuZCB0cnkgYWdhaW4uJyk7Cn0KdmFyIHdlYjMgPSBuZXcgV2ViMyhpbnBhZ2VQcm92aWRlcik7CndlYjMuc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7CiAgbG9nLmRlYnVnKCdNZXRhTWFzayAtIG92ZXJyb2RlIHdlYjMuc2V0UHJvdmlkZXInKTsKfTsKbG9nLmRlYnVnKCdNZXRhTWFzayAtIGluamVjdGVkIHdlYjMnKTsKLy8gZXhwb3J0IGdsb2JhbCB3ZWIzLCB3aXRoIHVzYWdlLWRldGVjdGlvbgpzZXR1cERhcHBBdXRvUmVsb2FkKHdlYjMsIGlucGFnZVByb3ZpZGVyLnB1YmxpY0NvbmZpZ1N0b3JlKTsKCi8vIHNldCB3ZWIzIGRlZmF1bHRBY2NvdW50CgppbnBhZ2VQcm92aWRlci5wdWJsaWNDb25maWdTdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHN0YXRlKSB7CiAgd2ViMy5ldGguZGVmYXVsdEFjY291bnQgPSBzdGF0ZS5zZWxlY3RlZEFkZHJlc3M7Cn0pOwoKLy8KLy8gdXRpbAovLwoKLy8gbmVlZCB0byBtYWtlIHN1cmUgd2UgYXJlbid0IGFmZmVjdGVkIGJ5IG92ZXJsYXBwaW5nIG5hbWVzcGFjZXMKLy8gYW5kIHRoYXQgd2UgZG9udCBhZmZlY3QgdGhlIGFwcCB3aXRoIG91ciBuYW1lc3BhY2UKLy8gbW9zdGx5IGEgZml4IGZvciB3ZWIzJ3MgQmlnTnVtYmVyIGlmIEFNRCdzICJkZWZpbmUiIGlzIGRlZmluZWQuLi4KdmFyIF9fZGVmaW5lOwoKZnVuY3Rpb24gY2xlYW5Db250ZXh0Rm9ySW1wb3J0cygpIHsKICBfX2RlZmluZSA9IGdsb2JhbC5kZWZpbmU7CiAgdHJ5IHsKICAgIGdsb2JhbC5kZWZpbmUgPSB1bmRlZmluZWQ7CiAgfSBjYXRjaCAoXykgewogICAgY29uc29sZS53YXJuKCdNZXRhTWFzayAtIGdsb2JhbC5kZWZpbmUgY291bGQgbm90IGJlIGRlbGV0ZWQuJyk7CiAgfQp9CgpmdW5jdGlvbiByZXN0b3JlQ29udGV4dEFmdGVySW1wb3J0cygpIHsKICB0cnkgewogICAgZ2xvYmFsLmRlZmluZSA9IF9fZGVmaW5lOwogIH0gY2F0Y2ggKF8pIHsKICAgIGNvbnNvbGUud2FybignTWV0YU1hc2sgLSBnbG9iYWwuZGVmaW5lIGNvdWxkIG5vdCBiZSBvdmVyd3JpdHRlbi4nKTsKICB9Cn0KCn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHt9KQp9LHsiLi9saWIvYXV0by1yZWxvYWQuanMiOjIsIi4vbGliL2lucGFnZS1wcm92aWRlci5qcyI6MywibG9nbGV2ZWwiOjExMSwicG9zdC1tZXNzYWdlLXN0cmVhbSI6MTE3LCJ3ZWIzL2Rpc3Qvd2ViMy5taW4uanMiOjE0MH1dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKGdsb2JhbCl7Cid1c2Ugc3RyaWN0JzsKCm1vZHVsZS5leHBvcnRzID0gc2V0dXBEYXBwQXV0b1JlbG9hZDsKCmZ1bmN0aW9uIHNldHVwRGFwcEF1dG9SZWxvYWQod2ViMywgb2JzZXJ2YWJsZSkgewogIC8vIGV4cG9ydCB3ZWIzIGFzIGEgZ2xvYmFsLCBjaGVja2luZyBmb3IgdXNhZ2UKICB2YXIgaGFzQmVlbldhcm5lZCA9IGZhbHNlOwogIHZhciByZWxvYWRJblByb2dyZXNzID0gZmFsc2U7CiAgdmFyIGxhc3RUaW1lVXNlZCA9IHZvaWQgMDsKICB2YXIgbGFzdFNlZW5OZXR3b3JrID0gdm9pZCAwOwoKICBnbG9iYWwud2ViMyA9IG5ldyBQcm94eSh3ZWIzLCB7CiAgICBnZXQ6IGZ1bmN0aW9uIGdldChfd2ViMywga2V5KSB7CiAgICAgIC8vIHNob3cgd2FybmluZyBvbmNlIG9uIHdlYjMgYWNjZXNzCiAgICAgIGlmICghaGFzQmVlbldhcm5lZCAmJiBrZXkgIT09ICdjdXJyZW50UHJvdmlkZXInKSB7CiAgICAgICAgY29uc29sZS53YXJuKCdNZXRhTWFzazogd2ViMyB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIG5lYXIgZnV0dXJlIGluIGZhdm9yIG9mIHRoZSBldGhlcmV1bVByb3ZpZGVyIFxuaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL2ZhcS9ibG9iL21hc3Rlci9kZXRlY3RpbmdfbWV0YW1hc2subWQjd2ViMy1kZXByZWNhdGlvbicpOwogICAgICAgIGhhc0JlZW5XYXJuZWQgPSB0cnVlOwogICAgICB9CiAgICAgIC8vIGdldCB0aGUgdGltZSBvZiB1c2UKICAgICAgbGFzdFRpbWVVc2VkID0gRGF0ZS5ub3coKTsKICAgICAgLy8gcmV0dXJuIHZhbHVlIG5vcm1hbGx5CiAgICAgIHJldHVybiBfd2ViM1trZXldOwogICAgfSwKICAgIHNldDogZnVuY3Rpb24gc2V0KF93ZWIzLCBrZXksIHZhbHVlKSB7CiAgICAgIC8vIHNldCB2YWx1ZSBub3JtYWxseQogICAgICBfd2ViM1trZXldID0gdmFsdWU7CiAgICB9CiAgfSk7CgogIG9ic2VydmFibGUuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdGF0ZSkgewogICAgLy8gaWYgcmVsb2FkIGluIHByb2dyZXNzLCBubyBuZWVkIHRvIGNoZWNrIHJlbG9hZCBsb2dpYwogICAgaWYgKHJlbG9hZEluUHJvZ3Jlc3MpIHJldHVybjsKCiAgICB2YXIgY3VycmVudE5ldHdvcmsgPSBzdGF0ZS5uZXR3b3JrVmVyc2lvbjsKCiAgICAvLyBzZXQgdGhlIGluaXRpYWwgbmV0d29yawogICAgaWYgKCFsYXN0U2Vlbk5ldHdvcmspIHsKICAgICAgbGFzdFNlZW5OZXR3b3JrID0gY3VycmVudE5ldHdvcms7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICAvLyBza2lwIHJlbG9hZCBsb2dpYyBpZiB3ZWIzIG5vdCB1c2VkCiAgICBpZiAoIWxhc3RUaW1lVXNlZCkgcmV0dXJuOwoKICAgIC8vIGlmIG5ldHdvcmsgZGlkIG5vdCBjaGFuZ2UsIGV4aXQKICAgIGlmIChjdXJyZW50TmV0d29yayA9PT0gbGFzdFNlZW5OZXR3b3JrKSByZXR1cm47CgogICAgLy8gaW5pdGlhdGUgcGFnZSByZWxvYWQKICAgIHJlbG9hZEluUHJvZ3Jlc3MgPSB0cnVlOwogICAgdmFyIHRpbWVTaW5jZVVzZSA9IERhdGUubm93KCkgLSBsYXN0VGltZVVzZWQ7CiAgICAvLyBpZiB3ZWIzIHdhcyByZWNlbnRseSB1c2VkIHRoZW4gZGVsYXkgdGhlIHJlbG9hZGluZyBvZiB0aGUgcGFnZQogICAgaWYgKHRpbWVTaW5jZVVzZSA+IDUwMCkgewogICAgICB0cmlnZ2VyUmVzZXQoKTsKICAgIH0gZWxzZSB7CiAgICAgIHNldFRpbWVvdXQodHJpZ2dlclJlc2V0LCA1MDApOwogICAgfQogIH0pOwp9CgovLyByZWxvYWQgdGhlIHBhZ2UKZnVuY3Rpb24gdHJpZ2dlclJlc2V0KCkgewogIGdsb2JhbC5sb2NhdGlvbi5yZWxvYWQoKTsKfQoKfSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiID8gd2luZG93IDoge30pCn0se31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7Cgp2YXIgcHVtcCA9IF9kZXJlcV8oJ3B1bXAnKTsKdmFyIFJwY0VuZ2luZSA9IF9kZXJlcV8oJ2pzb24tcnBjLWVuZ2luZScpOwp2YXIgY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUgPSBfZGVyZXFfKCdqc29uLXJwYy1lbmdpbmUvc3JjL2lkUmVtYXBNaWRkbGV3YXJlJyk7CnZhciBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlID0gX2RlcmVxXygnanNvbi1ycGMtbWlkZGxld2FyZS1zdHJlYW0nKTsKdmFyIExvY2FsU3RvcmFnZVN0b3JlID0gX2RlcmVxXygnb2JzLXN0b3JlJyk7CnZhciBhc1N0cmVhbSA9IF9kZXJlcV8oJ29icy1zdG9yZS9saWIvYXNTdHJlYW0nKTsKdmFyIE9iamVjdE11bHRpcGxleCA9IF9kZXJlcV8oJ29iai1tdWx0aXBsZXgnKTsKCm1vZHVsZS5leHBvcnRzID0gTWV0YW1hc2tJbnBhZ2VQcm92aWRlcjsKCmZ1bmN0aW9uIE1ldGFtYXNrSW5wYWdlUHJvdmlkZXIoY29ubmVjdGlvblN0cmVhbSkgewogIHZhciBzZWxmID0gdGhpczsKCiAgLy8gc2V0dXAgY29ubmVjdGlvblN0cmVhbSBtdWx0aXBsZXhpbmcKICB2YXIgbXV4ID0gc2VsZi5tdXggPSBuZXcgT2JqZWN0TXVsdGlwbGV4KCk7CiAgcHVtcChjb25uZWN0aW9uU3RyZWFtLCBtdXgsIGNvbm5lY3Rpb25TdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHsKICAgIHJldHVybiBsb2dTdHJlYW1EaXNjb25uZWN0V2FybmluZygnTWV0YU1hc2snLCBlcnIpOwogIH0pOwoKICAvLyBzdWJzY3JpYmUgdG8gbWV0YW1hc2sgcHVibGljIGNvbmZpZyAob25lLXdheSkKICBzZWxmLnB1YmxpY0NvbmZpZ1N0b3JlID0gbmV3IExvY2FsU3RvcmFnZVN0b3JlKHsgc3RvcmFnZUtleTogJ01ldGFNYXNrLUNvbmZpZycgfSk7CgogIHB1bXAobXV4LmNyZWF0ZVN0cmVhbSgncHVibGljQ29uZmlnJyksIGFzU3RyZWFtKHNlbGYucHVibGljQ29uZmlnU3RvcmUpLCBmdW5jdGlvbiAoZXJyKSB7CiAgICByZXR1cm4gbG9nU3RyZWFtRGlzY29ubmVjdFdhcm5pbmcoJ01ldGFNYXNrIFB1YmxpY0NvbmZpZ1N0b3JlJywgZXJyKTsKICB9KTsKCiAgLy8gaWdub3JlIHBoaXNoaW5nIHdhcm5pbmcgbWVzc2FnZSAoaGFuZGxlZCBlbHNld2hlcmUpCiAgbXV4Lmlnbm9yZVN0cmVhbSgncGhpc2hpbmcnKTsKCiAgLy8gY29ubmVjdCB0byBhc3luYyBwcm92aWRlcgogIHZhciBzdHJlYW1NaWRkbGV3YXJlID0gY3JlYXRlU3RyZWFtTWlkZGxld2FyZSgpOwogIHB1bXAoc3RyZWFtTWlkZGxld2FyZS5zdHJlYW0sIG11eC5jcmVhdGVTdHJlYW0oJ3Byb3ZpZGVyJyksIHN0cmVhbU1pZGRsZXdhcmUuc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7CiAgICByZXR1cm4gbG9nU3RyZWFtRGlzY29ubmVjdFdhcm5pbmcoJ01ldGFNYXNrIFJwY1Byb3ZpZGVyJywgZXJyKTsKICB9KTsKCiAgLy8gaGFuZGxlIHNlbmRBc3luYyByZXF1ZXN0cyB2aWEgZGFwcC1zaWRlIHJwYyBlbmdpbmUKICB2YXIgcnBjRW5naW5lID0gbmV3IFJwY0VuZ2luZSgpOwogIHJwY0VuZ2luZS5wdXNoKGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlKCkpOwogIHJwY0VuZ2luZS5wdXNoKHN0cmVhbU1pZGRsZXdhcmUpOwogIHNlbGYucnBjRW5naW5lID0gcnBjRW5naW5lOwp9CgovLyBoYW5kbGUgc2VuZEFzeW5jIHJlcXVlc3RzIHZpYSBhc3luY1Byb3ZpZGVyCi8vIGFsc28gcmVtYXAgaWRzIGluYm91bmQgYW5kIG91dGJvdW5kCk1ldGFtYXNrSW5wYWdlUHJvdmlkZXIucHJvdG90eXBlLnNlbmRBc3luYyA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYikgewogIHZhciBzZWxmID0gdGhpczsKICBzZWxmLnJwY0VuZ2luZS5oYW5kbGUocGF5bG9hZCwgY2IpOwp9OwoKTWV0YW1hc2tJbnBhZ2VQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7CiAgdmFyIHNlbGYgPSB0aGlzOwoKICB2YXIgc2VsZWN0ZWRBZGRyZXNzID0gdm9pZCAwOwogIHZhciByZXN1bHQgPSBudWxsOwogIHN3aXRjaCAocGF5bG9hZC5tZXRob2QpIHsKCiAgICBjYXNlICdldGhfYWNjb3VudHMnOgogICAgICAvLyByZWFkIGZyb20gbG9jYWxTdG9yYWdlCiAgICAgIHNlbGVjdGVkQWRkcmVzcyA9IHNlbGYucHVibGljQ29uZmlnU3RvcmUuZ2V0U3RhdGUoKS5zZWxlY3RlZEFkZHJlc3M7CiAgICAgIHJlc3VsdCA9IHNlbGVjdGVkQWRkcmVzcyA/IFtzZWxlY3RlZEFkZHJlc3NdIDogW107CiAgICAgIGJyZWFrOwoKICAgIGNhc2UgJ2V0aF9jb2luYmFzZSc6CiAgICAgIC8vIHJlYWQgZnJvbSBsb2NhbFN0b3JhZ2UKICAgICAgc2VsZWN0ZWRBZGRyZXNzID0gc2VsZi5wdWJsaWNDb25maWdTdG9yZS5nZXRTdGF0ZSgpLnNlbGVjdGVkQWRkcmVzczsKICAgICAgcmVzdWx0ID0gc2VsZWN0ZWRBZGRyZXNzIHx8IG51bGw7CiAgICAgIGJyZWFrOwoKICAgIGNhc2UgJ2V0aF91bmluc3RhbGxGaWx0ZXInOgogICAgICBzZWxmLnNlbmRBc3luYyhwYXlsb2FkLCBub29wKTsKICAgICAgcmVzdWx0ID0gdHJ1ZTsKICAgICAgYnJlYWs7CgogICAgY2FzZSAnbmV0X3ZlcnNpb24nOgogICAgICB2YXIgbmV0d29ya1ZlcnNpb24gPSBzZWxmLnB1YmxpY0NvbmZpZ1N0b3JlLmdldFN0YXRlKCkubmV0d29ya1ZlcnNpb247CiAgICAgIHJlc3VsdCA9IG5ldHdvcmtWZXJzaW9uIHx8IG51bGw7CiAgICAgIGJyZWFrOwoKICAgIC8vIHRocm93IG5vdC1zdXBwb3J0ZWQgRXJyb3IKICAgIGRlZmF1bHQ6CiAgICAgIHZhciBsaW5rID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9mYXEvYmxvYi9tYXN0ZXIvREVWRUxPUEVSUy5tZCNkaXp6eS1hbGwtYXN5bmMtLS10aGluay1vZi1tZXRhbWFzay1hcy1hLWxpZ2h0LWNsaWVudCc7CiAgICAgIHZhciBtZXNzYWdlID0gJ1RoZSBNZXRhTWFzayBXZWIzIG9iamVjdCBkb2VzIG5vdCBzdXBwb3J0IHN5bmNocm9ub3VzIG1ldGhvZHMgbGlrZSAnICsgcGF5bG9hZC5tZXRob2QgKyAnIHdpdGhvdXQgYSBjYWxsYmFjayBwYXJhbWV0ZXIuIFNlZSAnICsgbGluayArICcgZm9yIGRldGFpbHMuJzsKICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpOwoKICB9CgogIC8vIHJldHVybiB0aGUgcmVzdWx0CiAgcmV0dXJuIHsKICAgIGlkOiBwYXlsb2FkLmlkLAogICAganNvbnJwYzogcGF5bG9hZC5qc29ucnBjLAogICAgcmVzdWx0OiByZXN1bHQKICB9Owp9OwoKTWV0YW1hc2tJbnBhZ2VQcm92aWRlci5wcm90b3R5cGUuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7CiAgcmV0dXJuIHRydWU7Cn07CgpNZXRhbWFza0lucGFnZVByb3ZpZGVyLnByb3RvdHlwZS5pc0VpbmNNZXRhTWFzayA9IHRydWU7CgovLyB1dGlsCgpmdW5jdGlvbiBsb2dTdHJlYW1EaXNjb25uZWN0V2FybmluZyhyZW1vdGVMYWJlbCwgZXJyKSB7CiAgdmFyIHdhcm5pbmdNc2cgPSAnTWV0YW1hc2tJbnBhZ2VQcm92aWRlciAtIGxvc3QgY29ubmVjdGlvbiB0byAnICsgcmVtb3RlTGFiZWw7CiAgaWYgKGVycikgd2FybmluZ01zZyArPSAnXG4nICsgZXJyLnN0YWNrOwogIGNvbnNvbGUud2Fybih3YXJuaW5nTXNnKTsKfQoKZnVuY3Rpb24gbm9vcCgpIHt9Cgp9LHsianNvbi1ycGMtZW5naW5lIjoxMDksImpzb24tcnBjLWVuZ2luZS9zcmMvaWRSZW1hcE1pZGRsZXdhcmUiOjEwOCwianNvbi1ycGMtbWlkZGxld2FyZS1zdHJlYW0iOjExMCwib2JqLW11bHRpcGxleCI6MTEyLCJvYnMtc3RvcmUiOjExMywib2JzLXN0b3JlL2xpYi9hc1N0cmVhbSI6MTE0LCJwdW1wIjoxMTl9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7CihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7CiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6CiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6CiAgKGZhY3RvcnkoKGdsb2JhbC5hc3luYyA9IGdsb2JhbC5hc3luYyB8fCB7fSkpKTsKfSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnOwoKZnVuY3Rpb24gc2xpY2UoYXJyYXlMaWtlLCBzdGFydCkgewogICAgc3RhcnQgPSBzdGFydHwwOwogICAgdmFyIG5ld0xlbiA9IE1hdGgubWF4KGFycmF5TGlrZS5sZW5ndGggLSBzdGFydCwgMCk7CiAgICB2YXIgbmV3QXJyID0gQXJyYXkobmV3TGVuKTsKICAgIGZvcih2YXIgaWR4ID0gMDsgaWR4IDwgbmV3TGVuOyBpZHgrKykgIHsKICAgICAgICBuZXdBcnJbaWR4XSA9IGFycmF5TGlrZVtzdGFydCArIGlkeF07CiAgICB9CiAgICByZXR1cm4gbmV3QXJyOwp9CgovKioKICogQ3JlYXRlcyBhIGNvbnRpbnVhdGlvbiBmdW5jdGlvbiB3aXRoIHNvbWUgYXJndW1lbnRzIGFscmVhZHkgYXBwbGllZC4KICoKICogVXNlZnVsIGFzIGEgc2hvcnRoYW5kIHdoZW4gY29tYmluZWQgd2l0aCBvdGhlciBjb250cm9sIGZsb3cgZnVuY3Rpb25zLiBBbnkKICogYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gYXJlIGFkZGVkIHRvIHRoZSBhcmd1bWVudHMKICogb3JpZ2luYWxseSBwYXNzZWQgdG8gYXBwbHkuCiAqCiAqIEBuYW1lIGFwcGx5CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGV2ZW50dWFsbHkgYXBwbHkgYWxsCiAqIGFyZ3VtZW50cyB0by4gSW52b2tlcyB3aXRoIChhcmd1bWVudHMuLi4pLgogKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgYXBwbHkKICogd2hlbiB0aGUgY29udGludWF0aW9uIGlzIGNhbGxlZC4KICogQHJldHVybnMge0Z1bmN0aW9ufSB0aGUgcGFydGlhbGx5LWFwcGxpZWQgZnVuY3Rpb24KICogQGV4YW1wbGUKICoKICogLy8gdXNpbmcgYXBwbHkKICogYXN5bmMucGFyYWxsZWwoWwogKiAgICAgYXN5bmMuYXBwbHkoZnMud3JpdGVGaWxlLCAndGVzdGZpbGUxJywgJ3Rlc3QxJyksCiAqICAgICBhc3luYy5hcHBseShmcy53cml0ZUZpbGUsICd0ZXN0ZmlsZTInLCAndGVzdDInKQogKiBdKTsKICoKICoKICogLy8gdGhlIHNhbWUgcHJvY2VzcyB3aXRob3V0IHVzaW5nIGFwcGx5CiAqIGFzeW5jLnBhcmFsbGVsKFsKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgZnMud3JpdGVGaWxlKCd0ZXN0ZmlsZTEnLCAndGVzdDEnLCBjYWxsYmFjayk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBmcy53cml0ZUZpbGUoJ3Rlc3RmaWxlMicsICd0ZXN0MicsIGNhbGxiYWNrKTsKICogICAgIH0KICogXSk7CiAqCiAqIC8vIEl0J3MgcG9zc2libGUgdG8gcGFzcyBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHdoZW4gY2FsbGluZyB0aGUKICogLy8gY29udGludWF0aW9uOgogKgogKiBub2RlPiB2YXIgZm4gPSBhc3luYy5hcHBseShzeXMucHV0cywgJ29uZScpOwogKiBub2RlPiBmbigndHdvJywgJ3RocmVlJyk7CiAqIG9uZQogKiB0d28KICogdGhyZWUKICovCnZhciBhcHBseSA9IGZ1bmN0aW9uKGZuLyosIC4uLmFyZ3MqLykgewogICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgcmV0dXJuIGZ1bmN0aW9uKC8qY2FsbEFyZ3MqLykgewogICAgICAgIHZhciBjYWxsQXJncyA9IHNsaWNlKGFyZ3VtZW50cyk7CiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGNhbGxBcmdzKSk7CiAgICB9Owp9OwoKdmFyIGluaXRpYWxQYXJhbXMgPSBmdW5jdGlvbiAoZm4pIHsKICAgIHJldHVybiBmdW5jdGlvbiAoLyouLi5hcmdzLCBjYWxsYmFjayovKSB7CiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMpOwogICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7CiAgICAgICAgZm4uY2FsbCh0aGlzLCBhcmdzLCBjYWxsYmFjayk7CiAgICB9Owp9OwoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZQogKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpCiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYCkKICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgMC4xLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLmlzT2JqZWN0KHt9KTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc09iamVjdChfLm5vb3ApOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNPYmplY3QobnVsbCk7CiAqIC8vID0+IGZhbHNlCiAqLwpmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkgewogIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlOwogIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7Cn0KCnZhciBoYXNTZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nICYmIHNldEltbWVkaWF0ZTsKdmFyIGhhc05leHRUaWNrID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nOwoKZnVuY3Rpb24gZmFsbGJhY2soZm4pIHsKICAgIHNldFRpbWVvdXQoZm4sIDApOwp9CgpmdW5jdGlvbiB3cmFwKGRlZmVyKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKGZuLyosIC4uLmFyZ3MqLykgewogICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpOwogICAgICAgIH0pOwogICAgfTsKfQoKdmFyIF9kZWZlcjsKCmlmIChoYXNTZXRJbW1lZGlhdGUpIHsKICAgIF9kZWZlciA9IHNldEltbWVkaWF0ZTsKfSBlbHNlIGlmIChoYXNOZXh0VGljaykgewogICAgX2RlZmVyID0gcHJvY2Vzcy5uZXh0VGljazsKfSBlbHNlIHsKICAgIF9kZWZlciA9IGZhbGxiYWNrOwp9Cgp2YXIgc2V0SW1tZWRpYXRlJDEgPSB3cmFwKF9kZWZlcik7CgovKioKICogVGFrZSBhIHN5bmMgZnVuY3Rpb24gYW5kIG1ha2UgaXQgYXN5bmMsIHBhc3NpbmcgaXRzIHJldHVybiB2YWx1ZSB0byBhCiAqIGNhbGxiYWNrLiBUaGlzIGlzIHVzZWZ1bCBmb3IgcGx1Z2dpbmcgc3luYyBmdW5jdGlvbnMgaW50byBhIHdhdGVyZmFsbCwKICogc2VyaWVzLCBvciBvdGhlciBhc3luYyBmdW5jdGlvbnMuIEFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBnZW5lcmF0ZWQKICogZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb24gKGV4Y2VwdCBmb3IgdGhlIGZpbmFsCiAqIGNhbGxiYWNrIGFyZ3VtZW50KS4gRXJyb3JzIHRocm93biB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2suCiAqCiAqIElmIHRoZSBmdW5jdGlvbiBwYXNzZWQgdG8gYGFzeW5jaWZ5YCByZXR1cm5zIGEgUHJvbWlzZSwgdGhhdCBwcm9taXNlcydzCiAqIHJlc29sdmVkL3JlamVjdGVkIHN0YXRlIHdpbGwgYmUgdXNlZCB0byBjYWxsIHRoZSBjYWxsYmFjaywgcmF0aGVyIHRoYW4gc2ltcGx5CiAqIHRoZSBzeW5jaHJvbm91cyByZXR1cm4gdmFsdWUuCiAqCiAqIFRoaXMgYWxzbyBtZWFucyB5b3UgY2FuIGFzeW5jaWZ5IEVTMjAxNyBgYXN5bmNgIGZ1bmN0aW9ucy4KICoKICogQG5hbWUgYXN5bmNpZnkKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQGFsaWFzIHdyYXBTeW5jCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBUaGUgc3luY2hyb25vdXMgZnVuY3Rpb24sIG9yIFByb21pc2UtcmV0dXJuaW5nCiAqIGZ1bmN0aW9uIHRvIGNvbnZlcnQgdG8gYW4ge0BsaW5rIEFzeW5jRnVuY3Rpb259LgogKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gQW4gYXN5bmNocm9ub3VzIHdyYXBwZXIgb2YgdGhlIGBmdW5jYC4gVG8gYmUKICogaW52b2tlZCB3aXRoIGAoYXJncy4uLiwgY2FsbGJhY2spYC4KICogQGV4YW1wbGUKICoKICogLy8gcGFzc2luZyBhIHJlZ3VsYXIgc3luY2hyb25vdXMgZnVuY3Rpb24KICogYXN5bmMud2F0ZXJmYWxsKFsKICogICAgIGFzeW5jLmFwcGx5KGZzLnJlYWRGaWxlLCBmaWxlbmFtZSwgInV0ZjgiKSwKICogICAgIGFzeW5jLmFzeW5jaWZ5KEpTT04ucGFyc2UpLAogKiAgICAgZnVuY3Rpb24gKGRhdGEsIG5leHQpIHsKICogICAgICAgICAvLyBkYXRhIGlzIHRoZSByZXN1bHQgb2YgcGFyc2luZyB0aGUgdGV4dC4KICogICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwYXJzaW5nIGVycm9yLCBpdCB3b3VsZCBoYXZlIGJlZW4gY2F1Z2h0LgogKiAgICAgfQogKiBdLCBjYWxsYmFjayk7CiAqCiAqIC8vIHBhc3NpbmcgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBwcm9taXNlCiAqIGFzeW5jLndhdGVyZmFsbChbCiAqICAgICBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgZmlsZW5hbWUsICJ1dGY4IiksCiAqICAgICBhc3luYy5hc3luY2lmeShmdW5jdGlvbiAoY29udGVudHMpIHsKICogICAgICAgICByZXR1cm4gZGIubW9kZWwuY3JlYXRlKGNvbnRlbnRzKTsKICogICAgIH0pLAogKiAgICAgZnVuY3Rpb24gKG1vZGVsLCBuZXh0KSB7CiAqICAgICAgICAgLy8gYG1vZGVsYCBpcyB0aGUgaW5zdGFudGlhdGVkIG1vZGVsIG9iamVjdC4KICogICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYW4gZXJyb3IsIHRoaXMgZnVuY3Rpb24gd291bGQgYmUgc2tpcHBlZC4KICogICAgIH0KICogXSwgY2FsbGJhY2spOwogKgogKiAvLyBlczIwMTcgZXhhbXBsZSwgdGhvdWdoIGBhc3luY2lmeWAgaXMgbm90IG5lZWRlZCBpZiB5b3VyIEpTIGVudmlyb25tZW50CiAqIC8vIHN1cHBvcnRzIGFzeW5jIGZ1bmN0aW9ucyBvdXQgb2YgdGhlIGJveAogKiB2YXIgcSA9IGFzeW5jLnF1ZXVlKGFzeW5jLmFzeW5jaWZ5KGFzeW5jIGZ1bmN0aW9uKGZpbGUpIHsKICogICAgIHZhciBpbnRlcm1lZGlhdGVTdGVwID0gYXdhaXQgcHJvY2Vzc0ZpbGUoZmlsZSk7CiAqICAgICByZXR1cm4gYXdhaXQgc29tZVByb21pc2UoaW50ZXJtZWRpYXRlU3RlcCkKICogfSkpOwogKgogKiBxLnB1c2goZmlsZXMpOwogKi8KZnVuY3Rpb24gYXN5bmNpZnkoZnVuYykgewogICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7CiAgICAgICAgdmFyIHJlc3VsdDsKICAgICAgICB0cnkgewogICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpOwogICAgICAgIH0KICAgICAgICAvLyBpZiByZXN1bHQgaXMgUHJvbWlzZSBvYmplY3QKICAgICAgICBpZiAoaXNPYmplY3QocmVzdWx0KSAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24odmFsdWUpIHsKICAgICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBudWxsLCB2YWx1ZSk7CiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikgewogICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIGVyci5tZXNzYWdlID8gZXJyIDogbmV3IEVycm9yKGVycikpOwogICAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpOwogICAgICAgIH0KICAgIH0pOwp9CgpmdW5jdGlvbiBpbnZva2VDYWxsYmFjayhjYWxsYmFjaywgZXJyb3IsIHZhbHVlKSB7CiAgICB0cnkgewogICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7CiAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgc2V0SW1tZWRpYXRlJDEocmV0aHJvdywgZSk7CiAgICB9Cn0KCmZ1bmN0aW9uIHJldGhyb3coZXJyb3IpIHsKICAgIHRocm93IGVycm9yOwp9Cgp2YXIgc3VwcG9ydHNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nOwoKZnVuY3Rpb24gaXNBc3luYyhmbikgewogICAgcmV0dXJuIHN1cHBvcnRzU3ltYm9sICYmIGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0Z1bmN0aW9uJzsKfQoKZnVuY3Rpb24gd3JhcEFzeW5jKGFzeW5jRm4pIHsKICAgIHJldHVybiBpc0FzeW5jKGFzeW5jRm4pID8gYXN5bmNpZnkoYXN5bmNGbikgOiBhc3luY0ZuOwp9CgpmdW5jdGlvbiBhcHBseUVhY2gkMShlYWNoZm4pIHsKICAgIHJldHVybiBmdW5jdGlvbihmbnMvKiwgLi4uYXJncyovKSB7CiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgICAgIHZhciBnbyA9IGluaXRpYWxQYXJhbXMoZnVuY3Rpb24oYXJncywgY2FsbGJhY2spIHsKICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzOwogICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgZnVuY3Rpb24gKGZuLCBjYikgewogICAgICAgICAgICAgICAgd3JhcEFzeW5jKGZuKS5hcHBseSh0aGF0LCBhcmdzLmNvbmNhdChjYikpOwogICAgICAgICAgICB9LCBjYWxsYmFjayk7CiAgICAgICAgfSk7CiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7CiAgICAgICAgICAgIHJldHVybiBnby5hcHBseSh0aGlzLCBhcmdzKTsKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBnbzsKICAgICAgICB9CiAgICB9Owp9CgovKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqLwp2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7CgovKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqLwp2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjsKCi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqLwp2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTsKCi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqLwp2YXIgU3ltYm9sJDEgPSByb290LlN5bWJvbDsKCi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi8KdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTsKCi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqLwp2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTsKCi8qKgogKiBVc2VkIHRvIHJlc29sdmUgdGhlCiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKQogKiBvZiB2YWx1ZXMuCiAqLwp2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZzsKCi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqLwp2YXIgc3ltVG9TdHJpbmdUYWckMSA9IFN5bWJvbCQxID8gU3ltYm9sJDEudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7CgovKioKICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuCiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLgogKi8KZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7CiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWckMSksCiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdOwoKICB0cnkgewogICAgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV0gPSB1bmRlZmluZWQ7CiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlOwogIH0gY2F0Y2ggKGUpIHt9CgogIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTsKICBpZiAodW5tYXNrZWQpIHsKICAgIGlmIChpc093bikgewogICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHRhZzsKICAgIH0gZWxzZSB7CiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXTsKICAgIH0KICB9CiAgcmV0dXJuIHJlc3VsdDsKfQoKLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqLwp2YXIgb2JqZWN0UHJvdG8kMSA9IE9iamVjdC5wcm90b3R5cGU7CgovKioKICogVXNlZCB0byByZXNvbHZlIHRoZQogKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZykKICogb2YgdmFsdWVzLgogKi8KdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nJDEgPSBvYmplY3RQcm90byQxLnRvU3RyaW5nOwoKLyoqCiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LgogKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLgogKi8KZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHsKICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmckMS5jYWxsKHZhbHVlKTsKfQoKLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqLwp2YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJzsKdmFyIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nOwoKLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovCnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCQxID8gU3ltYm9sJDEudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuCiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuCiAqLwpmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7CiAgaWYgKHZhbHVlID09IG51bGwpIHsKICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZzsKICB9CiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKQogICAgPyBnZXRSYXdUYWcodmFsdWUpCiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTsKfQoKLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqLwp2YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7CnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJzsKdmFyIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7CnZhciBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAwLjEuMAogKiBAY2F0ZWdvcnkgTGFuZwogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLmlzRnVuY3Rpb24oXyk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc0Z1bmN0aW9uKC9hYmMvKTsKICogLy8gPT4gZmFsc2UKICovCmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHsKICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkgewogICAgcmV0dXJuIGZhbHNlOwogIH0KICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3IKICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy4KICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7CiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZzsKfQoKLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovCnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLgogKgogKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbgogKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSA0LjAuMAogKiBAY2F0ZWdvcnkgTGFuZwogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc0xlbmd0aCgzKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpOwogKiAvLyA9PiBmYWxzZQogKgogKiBfLmlzTGVuZ3RoKEluZmluaXR5KTsKICogLy8gPT4gZmFsc2UKICoKICogXy5pc0xlbmd0aCgnMycpOwogKiAvLyA9PiBmYWxzZQogKi8KZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHsKICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmCiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7Cn0KCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzCiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3IKICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4wLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7CiAqIC8vID0+IHRydWUKICoKICogXy5pc0FycmF5TGlrZSgnYWJjJyk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc0FycmF5TGlrZShfLm5vb3ApOwogKiAvLyA9PiBmYWxzZQogKi8KZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHsKICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTsKfQoKLy8gQSB0ZW1wb3JhcnkgdmFsdWUgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgbG9vcCBzaG91bGQgYmUgYnJva2VuLgovLyBTZWUgIzEwNjQsICMxMjkzCnZhciBicmVha0xvb3AgPSB7fTsKCi8qKgogKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAyLjMuMAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAZXhhbXBsZQogKgogKiBfLnRpbWVzKDIsIF8ubm9vcCk7CiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF0KICovCmZ1bmN0aW9uIG5vb3AoKSB7CiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC4KfQoKZnVuY3Rpb24gb25jZShmbikgewogICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICBpZiAoZm4gPT09IG51bGwpIHJldHVybjsKICAgICAgICB2YXIgY2FsbEZuID0gZm47CiAgICAgICAgZm4gPSBudWxsOwogICAgICAgIGNhbGxGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfTsKfQoKdmFyIGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7Cgp2YXIgZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAoY29sbCkgewogICAgcmV0dXJuIGl0ZXJhdG9yU3ltYm9sICYmIGNvbGxbaXRlcmF0b3JTeW1ib2xdICYmIGNvbGxbaXRlcmF0b3JTeW1ib2xdKCk7Cn07CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcwogKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC4KICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLgogKi8KZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7CiAgdmFyIGluZGV4ID0gLTEsCiAgICAgIHJlc3VsdCA9IEFycmF5KG4pOwoKICB3aGlsZSAoKytpbmRleCA8IG4pIHsKICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7CiAgfQogIHJldHVybiByZXN1bHQ7Cn0KCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGAKICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiAib2JqZWN0Ii4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4wLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8uaXNPYmplY3RMaWtlKHt9KTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7CiAqIC8vID0+IGZhbHNlCiAqCiAqIF8uaXNPYmplY3RMaWtlKG51bGwpOwogKiAvLyA9PiBmYWxzZQogKi8KZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7CiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnOwp9CgovKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovCnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LAogKi8KZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7CiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZzsKfQoKLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqLwp2YXIgb2JqZWN0UHJvdG8kMyA9IE9iamVjdC5wcm90b3R5cGU7CgovKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi8KdmFyIGhhc093blByb3BlcnR5JDIgPSBvYmplY3RQcm90byQzLmhhc093blByb3BlcnR5OwoKLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovCnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvJDMucHJvcGVydHlJc0VudW1lcmFibGU7CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgMC4xLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCwKICogIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7CiAqIC8vID0+IGZhbHNlCiAqLwp2YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkgewogIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5JDIuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmCiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpOwp9OwoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDAuMS4wCiAqIEBjYXRlZ29yeSBMYW5nCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7CiAqIC8vID0+IGZhbHNlCiAqCiAqIF8uaXNBcnJheSgnYWJjJyk7CiAqIC8vID0+IGZhbHNlCiAqCiAqIF8uaXNBcnJheShfLm5vb3ApOwogKiAvLyA9PiBmYWxzZQogKi8KdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5OwoKLyoqCiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4xMy4wCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpOwogKiAvLyA9PiBbZmFsc2UsIGZhbHNlXQogKi8KZnVuY3Rpb24gc3R1YkZhbHNlKCkgewogIHJldHVybiBmYWxzZTsKfQoKLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi8KdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzOwoKLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqLwp2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlOwoKLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi8KdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7CgovKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi8KdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDsKCi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi8KdmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkOwoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSA0LjMuMAogKiBAY2F0ZWdvcnkgTGFuZwogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTsKICogLy8gPT4gZmFsc2UKICovCnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTsKCi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqLwp2YXIgTUFYX1NBRkVfSU5URUdFUiQxID0gOTAwNzE5OTI1NDc0MDk5MTsKCi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi8KdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXGQqKSQvOwoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLgogKi8KZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7CiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSJDEgOiBsZW5ndGg7CiAgcmV0dXJuICEhbGVuZ3RoICYmCiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJgogICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpOwp9CgovKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovCnZhciBhcmdzVGFnJDEgPSAnW29iamVjdCBBcmd1bWVudHNdJzsKdmFyIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJzsKdmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXSc7CnZhciBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nOwp2YXIgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nOwp2YXIgZnVuY1RhZyQxID0gJ1tvYmplY3QgRnVuY3Rpb25dJzsKdmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nOwp2YXIgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXSc7CnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJzsKdmFyIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nOwp2YXIgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7CnZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJzsKdmFyIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7Cgp2YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nOwp2YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nOwp2YXIgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nOwp2YXIgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nOwp2YXIgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nOwp2YXIgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XSc7CnZhciBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJzsKdmFyIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nOwp2YXIgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJzsKdmFyIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XSc7CnZhciB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nOwoKLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqLwp2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTsKdHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9CnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID0KdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID0KdHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPQp0eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTsKdHlwZWRBcnJheVRhZ3NbYXJnc1RhZyQxXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9CnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID0KdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPQp0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnJDFdID0KdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPQp0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9CnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID0KdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTsKCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLgogKi8KZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkgewogIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmCiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldOwp9CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi4KICovCmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7CiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7CiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7CiAgfTsKfQoKLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi8KdmFyIGZyZWVFeHBvcnRzJDEgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7CgovKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovCnZhciBmcmVlTW9kdWxlJDEgPSBmcmVlRXhwb3J0cyQxICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlOwoKLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi8KdmFyIG1vZHVsZUV4cG9ydHMkMSA9IGZyZWVNb2R1bGUkMSAmJiBmcmVlTW9kdWxlJDEuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHMkMTsKCi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqLwp2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzJDEgJiYgZnJlZUdsb2JhbC5wcm9jZXNzOwoKLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovCnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHsKICB0cnkgewogICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpOwogIH0gY2F0Y2ggKGUpIHt9Cn0oKSk7CgovKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqLwp2YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDMuMC4wCiAqIEBjYXRlZ29yeSBMYW5nCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzVHlwZWRBcnJheShbXSk7CiAqIC8vID0+IGZhbHNlCiAqLwp2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7CgovKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovCnZhciBvYmplY3RQcm90byQyID0gT2JqZWN0LnByb3RvdHlwZTsKCi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqLwp2YXIgaGFzT3duUHJvcGVydHkkMSA9IG9iamVjdFByb3RvJDIuaGFzT3duUHJvcGVydHk7CgovKioKICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS4KICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLgogKi8KZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7CiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksCiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSwKICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksCiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLAogICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsCiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLAogICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoOwoKICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHsKICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5JDEuY2FsbCh2YWx1ZSwga2V5KSkgJiYKICAgICAgICAhKHNraXBJbmRleGVzICYmICgKICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuCiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8CiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuCiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8CiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLgogICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fAogICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy4KICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKQogICAgICAgICkpKSB7CiAgICAgIHJlc3VsdC5wdXNoKGtleSk7CiAgICB9CiAgfQogIHJldHVybiByZXN1bHQ7Cn0KCi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi8KdmFyIG9iamVjdFByb3RvJDUgPSBPYmplY3QucHJvdG90eXBlOwoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLgogKi8KZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHsKICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLAogICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90byQ1OwoKICByZXR1cm4gdmFsdWUgPT09IHByb3RvOwp9CgovKioKICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuCiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLgogKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi4KICovCmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7CiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykgewogICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpOwogIH07Cn0KCi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi8KdmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpOwoKLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqLwp2YXIgb2JqZWN0UHJvdG8kNCA9IE9iamVjdC5wcm90b3R5cGU7CgovKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi8KdmFyIGhhc093blByb3BlcnR5JDMgPSBvYmplY3RQcm90byQ0Lmhhc093blByb3BlcnR5OwoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLgogKi8KZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7CiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7CiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpOwogIH0KICB2YXIgcmVzdWx0ID0gW107CiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7CiAgICBpZiAoaGFzT3duUHJvcGVydHkkMy5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykgewogICAgICByZXN1bHQucHVzaChrZXkpOwogICAgfQogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovKioKICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuCiAqCiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlCiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cykKICogZm9yIG1vcmUgZGV0YWlscy4KICoKICogQHN0YXRpYwogKiBAc2luY2UgMC4xLjAKICogQG1lbWJlck9mIF8KICogQGNhdGVnb3J5IE9iamVjdAogKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuCiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuCiAqIEBleGFtcGxlCiAqCiAqIGZ1bmN0aW9uIEZvbygpIHsKICogICB0aGlzLmEgPSAxOwogKiAgIHRoaXMuYiA9IDI7CiAqIH0KICoKICogRm9vLnByb3RvdHlwZS5jID0gMzsKICoKICogXy5rZXlzKG5ldyBGb28pOwogKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpCiAqCiAqIF8ua2V5cygnaGknKTsKICogLy8gPT4gWycwJywgJzEnXQogKi8KZnVuY3Rpb24ga2V5cyhvYmplY3QpIHsKICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7Cn0KCmZ1bmN0aW9uIGNyZWF0ZUFycmF5SXRlcmF0b3IoY29sbCkgewogICAgdmFyIGkgPSAtMTsKICAgIHZhciBsZW4gPSBjb2xsLmxlbmd0aDsKICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkgewogICAgICAgIHJldHVybiArK2kgPCBsZW4gPyB7dmFsdWU6IGNvbGxbaV0sIGtleTogaX0gOiBudWxsOwogICAgfQp9CgpmdW5jdGlvbiBjcmVhdGVFUzIwMTVJdGVyYXRvcihpdGVyYXRvcikgewogICAgdmFyIGkgPSAtMTsKICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkgewogICAgICAgIHZhciBpdGVtID0gaXRlcmF0b3IubmV4dCgpOwogICAgICAgIGlmIChpdGVtLmRvbmUpCiAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgIGkrKzsKICAgICAgICByZXR1cm4ge3ZhbHVlOiBpdGVtLnZhbHVlLCBrZXk6IGl9OwogICAgfQp9CgpmdW5jdGlvbiBjcmVhdGVPYmplY3RJdGVyYXRvcihvYmopIHsKICAgIHZhciBva2V5cyA9IGtleXMob2JqKTsKICAgIHZhciBpID0gLTE7CiAgICB2YXIgbGVuID0gb2tleXMubGVuZ3RoOwogICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7CiAgICAgICAgdmFyIGtleSA9IG9rZXlzWysraV07CiAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyB7dmFsdWU6IG9ialtrZXldLCBrZXk6IGtleX0gOiBudWxsOwogICAgfTsKfQoKZnVuY3Rpb24gaXRlcmF0b3IoY29sbCkgewogICAgaWYgKGlzQXJyYXlMaWtlKGNvbGwpKSB7CiAgICAgICAgcmV0dXJuIGNyZWF0ZUFycmF5SXRlcmF0b3IoY29sbCk7CiAgICB9CgogICAgdmFyIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoY29sbCk7CiAgICByZXR1cm4gaXRlcmF0b3IgPyBjcmVhdGVFUzIwMTVJdGVyYXRvcihpdGVyYXRvcikgOiBjcmVhdGVPYmplY3RJdGVyYXRvcihjb2xsKTsKfQoKZnVuY3Rpb24gb25seU9uY2UoZm4pIHsKICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICBpZiAoZm4gPT09IG51bGwpIHRocm93IG5ldyBFcnJvcigiQ2FsbGJhY2sgd2FzIGFscmVhZHkgY2FsbGVkLiIpOwogICAgICAgIHZhciBjYWxsRm4gPSBmbjsKICAgICAgICBmbiA9IG51bGw7CiAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICB9Owp9CgpmdW5jdGlvbiBfZWFjaE9mTGltaXQobGltaXQpIHsKICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgICAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7CiAgICAgICAgaWYgKGxpbWl0IDw9IDAgfHwgIW9iaikgewogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7CiAgICAgICAgfQogICAgICAgIHZhciBuZXh0RWxlbSA9IGl0ZXJhdG9yKG9iaik7CiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTsKICAgICAgICB2YXIgcnVubmluZyA9IDA7CgogICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVlQ2FsbGJhY2soZXJyLCB2YWx1ZSkgewogICAgICAgICAgICBydW5uaW5nIC09IDE7CiAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlOwogICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gYnJlYWtMb29wIHx8IChkb25lICYmIHJ1bm5pbmcgPD0gMCkpIHsKICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlOwogICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgcmVwbGVuaXNoKCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIHJlcGxlbmlzaCAoKSB7CiAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgIWRvbmUpIHsKICAgICAgICAgICAgICAgIHZhciBlbGVtID0gbmV4dEVsZW0oKTsKICAgICAgICAgICAgICAgIGlmIChlbGVtID09PSBudWxsKSB7CiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7CiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmcgPD0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcnVubmluZyArPSAxOwogICAgICAgICAgICAgICAgaXRlcmF0ZWUoZWxlbS52YWx1ZSwgZWxlbS5rZXksIG9ubHlPbmNlKGl0ZXJhdGVlQ2FsbGJhY2spKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmVwbGVuaXNoKCk7CiAgICB9Owp9CgovKioKICogVGhlIHNhbWUgYXMgW2BlYWNoT2ZgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEKICogdGltZS4KICoKICogQG5hbWUgZWFjaE9mTGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZWFjaE9mXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfQogKiBAYWxpYXMgZm9yRWFjaE9mTGltaXQKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoCiAqIGl0ZW0gaW4gYGNvbGxgLiBUaGUgYGtleWAgaXMgdGhlIGl0ZW0ncyBrZXksIG9yIGluZGV4IGluIHRoZSBjYXNlIG9mIGFuCiAqIGFycmF5LgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGtleSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuCiAqLwpmdW5jdGlvbiBlYWNoT2ZMaW1pdChjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBfZWFjaE9mTGltaXQobGltaXQpKGNvbGwsIHdyYXBBc3luYyhpdGVyYXRlZSksIGNhbGxiYWNrKTsKfQoKZnVuY3Rpb24gZG9MaW1pdChmbiwgbGltaXQpIHsKICAgIHJldHVybiBmdW5jdGlvbiAoaXRlcmFibGUsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgICAgIHJldHVybiBmbihpdGVyYWJsZSwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjayk7CiAgICB9Owp9CgovLyBlYWNoT2YgaW1wbGVtZW50YXRpb24gb3B0aW1pemVkIGZvciBhcnJheS1saWtlcwpmdW5jdGlvbiBlYWNoT2ZBcnJheUxpa2UoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7CiAgICB2YXIgaW5kZXggPSAwLAogICAgICAgIGNvbXBsZXRlZCA9IDAsCiAgICAgICAgbGVuZ3RoID0gY29sbC5sZW5ndGg7CiAgICBpZiAobGVuZ3RoID09PSAwKSB7CiAgICAgICAgY2FsbGJhY2sobnVsbCk7CiAgICB9CgogICAgZnVuY3Rpb24gaXRlcmF0b3JDYWxsYmFjayhlcnIsIHZhbHVlKSB7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICBjYWxsYmFjayhlcnIpOwogICAgICAgIH0gZWxzZSBpZiAoKCsrY29tcGxldGVkID09PSBsZW5ndGgpIHx8IHZhbHVlID09PSBicmVha0xvb3ApIHsKICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7CiAgICAgICAgfQogICAgfQoKICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykgewogICAgICAgIGl0ZXJhdGVlKGNvbGxbaW5kZXhdLCBpbmRleCwgb25seU9uY2UoaXRlcmF0b3JDYWxsYmFjaykpOwogICAgfQp9CgovLyBhIGdlbmVyaWMgdmVyc2lvbiBvZiBlYWNoT2Ygd2hpY2ggY2FuIGhhbmRsZSBhcnJheSwgb2JqZWN0LCBhbmQgaXRlcmF0b3IgY2FzZXMuCnZhciBlYWNoT2ZHZW5lcmljID0gZG9MaW1pdChlYWNoT2ZMaW1pdCwgSW5maW5pdHkpOwoKLyoqCiAqIExpa2UgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9LCBleGNlcHQgdGhhdCBpdCBwYXNzZXMgdGhlIGtleSAob3IgaW5kZXgpIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQKICogdG8gdGhlIGl0ZXJhdGVlLgogKgogKiBAbmFtZSBlYWNoT2YKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGFsaWFzIGZvckVhY2hPZgogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoCiAqIGl0ZW0gaW4gYGNvbGxgLgogKiBUaGUgYGtleWAgaXMgdGhlIGl0ZW0ncyBrZXksIG9yIGluZGV4IGluIHRoZSBjYXNlIG9mIGFuIGFycmF5LgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGtleSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuCiAqIEBleGFtcGxlCiAqCiAqIHZhciBvYmogPSB7ZGV2OiAiL2Rldi5qc29uIiwgdGVzdDogIi90ZXN0Lmpzb24iLCBwcm9kOiAiL3Byb2QuanNvbiJ9OwogKiB2YXIgY29uZmlncyA9IHt9OwogKgogKiBhc3luYy5mb3JFYWNoT2Yob2JqLCBmdW5jdGlvbiAodmFsdWUsIGtleSwgY2FsbGJhY2spIHsKICogICAgIGZzLnJlYWRGaWxlKF9fZGlybmFtZSArIHZhbHVlLCAidXRmOCIsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHsKICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICogICAgICAgICB0cnkgewogKiAgICAgICAgICAgICBjb25maWdzW2tleV0gPSBKU09OLnBhcnNlKGRhdGEpOwogKiAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICogICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpOwogKiAgICAgICAgIH0KICogICAgICAgICBjYWxsYmFjaygpOwogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uIChlcnIpIHsKICogICAgIGlmIChlcnIpIGNvbnNvbGUuZXJyb3IoZXJyLm1lc3NhZ2UpOwogKiAgICAgLy8gY29uZmlncyBpcyBub3cgYSBtYXAgb2YgSlNPTiBkYXRhCiAqICAgICBkb1NvbWV0aGluZ1dpdGgoY29uZmlncyk7CiAqIH0pOwogKi8KdmFyIGVhY2hPZiA9IGZ1bmN0aW9uKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgdmFyIGVhY2hPZkltcGxlbWVudGF0aW9uID0gaXNBcnJheUxpa2UoY29sbCkgPyBlYWNoT2ZBcnJheUxpa2UgOiBlYWNoT2ZHZW5lcmljOwogICAgZWFjaE9mSW1wbGVtZW50YXRpb24oY29sbCwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2spOwp9OwoKZnVuY3Rpb24gZG9QYXJhbGxlbChmbikgewogICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgICAgIHJldHVybiBmbihlYWNoT2YsIG9iaiwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2spOwogICAgfTsKfQoKZnVuY3Rpb24gX2FzeW5jTWFwKGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDsKICAgIGFyciA9IGFyciB8fCBbXTsKICAgIHZhciByZXN1bHRzID0gW107CiAgICB2YXIgY291bnRlciA9IDA7CiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTsKCiAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAodmFsdWUsIF8sIGNhbGxiYWNrKSB7CiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrOwogICAgICAgIF9pdGVyYXRlZSh2YWx1ZSwgZnVuY3Rpb24gKGVyciwgdikgewogICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHY7CiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7CiAgICAgICAgfSk7CiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7CiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTsKICAgIH0pOwp9CgovKioKICogUHJvZHVjZXMgYSBuZXcgY29sbGVjdGlvbiBvZiB2YWx1ZXMgYnkgbWFwcGluZyBlYWNoIHZhbHVlIGluIGBjb2xsYCB0aHJvdWdoCiAqIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgd2l0aCBhbiBpdGVtIGZyb20gYGNvbGxgCiAqIGFuZCBhIGNhbGxiYWNrIGZvciB3aGVuIGl0IGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nLiBFYWNoIG9mIHRoZXNlIGNhbGxiYWNrCiAqIHRha2VzIDIgYXJndW1lbnRzOiBhbiBgZXJyb3JgLCBhbmQgdGhlIHRyYW5zZm9ybWVkIGl0ZW0gZnJvbSBgY29sbGAuIElmCiAqIGBpdGVyYXRlZWAgcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZQogKiBgbWFwYCBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLgogKgogKiBOb3RlLCB0aGF0IHNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyB0aGUgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4KICogcGFyYWxsZWwsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyB3aWxsIGNvbXBsZXRlCiAqIGluIG9yZGVyLiBIb3dldmVyLCB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGJlIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZQogKiBvcmlnaW5hbCBgY29sbGAuCiAqCiAqIElmIGBtYXBgIGlzIHBhc3NlZCBhbiBPYmplY3QsIHRoZSByZXN1bHRzIHdpbGwgYmUgYW4gQXJyYXkuICBUaGUgcmVzdWx0cwogKiB3aWxsIHJvdWdobHkgYmUgaW4gdGhlIG9yZGVyIG9mIHRoZSBvcmlnaW5hbCBPYmplY3RzJyBrZXlzIChidXQgdGhpcyBjYW4KICogdmFyeSBhY3Jvc3MgSmF2YVNjcmlwdCBlbmdpbmVzKS4KICoKICogQG5hbWUgbWFwCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgaXRlbS4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gQXJyYXkgb2YgdGhlCiAqIHRyYW5zZm9ybWVkIGl0ZW1zIGZyb20gdGhlIGBjb2xsYC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5tYXAoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnMuc3RhdCwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBhbiBhcnJheSBvZiBzdGF0cyBmb3IgZWFjaCBmaWxlCiAqIH0pOwogKi8KdmFyIG1hcCA9IGRvUGFyYWxsZWwoX2FzeW5jTWFwKTsKCi8qKgogKiBBcHBsaWVzIHRoZSBwcm92aWRlZCBhcmd1bWVudHMgdG8gZWFjaCBmdW5jdGlvbiBpbiB0aGUgYXJyYXksIGNhbGxpbmcKICogYGNhbGxiYWNrYCBhZnRlciBhbGwgZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBJZiB5b3Ugb25seSBwcm92aWRlIHRoZSBmaXJzdAogKiBhcmd1bWVudCwgYGZuc2AsIHRoZW4gaXQgd2lsbCByZXR1cm4gYSBmdW5jdGlvbiB3aGljaCBsZXRzIHlvdSBwYXNzIGluIHRoZQogKiBhcmd1bWVudHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsLiBJZiBtb3JlIGFyZ3VtZW50cyBhcmUKICogcHJvdmlkZWQsIGBjYWxsYmFja2AgaXMgcmVxdWlyZWQgd2hpbGUgYGFyZ3NgIGlzIHN0aWxsIG9wdGlvbmFsLgogKgogKiBAbmFtZSBhcHBseUVhY2gKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gZm5zIC0gQSBjb2xsZWN0aW9uIG9mIHtAbGluayBBc3luY0Z1bmN0aW9ufXMKICogdG8gYWxsIGNhbGwgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMKICogQHBhcmFtIHsuLi4qfSBbYXJnc10gLSBhbnkgbnVtYmVyIG9mIHNlcGFyYXRlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZQogKiBmdW5jdGlvbi4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIHRoZSBmaW5hbCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNhbGxiYWNrLAogKiBjYWxsZWQgd2hlbiBhbGwgZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkIHByb2Nlc3NpbmcuCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gLSBJZiBvbmx5IHRoZSBmaXJzdCBhcmd1bWVudCwgYGZuc2AsIGlzIHByb3ZpZGVkLCBpdCB3aWxsCiAqIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGxldHMgeW91IHBhc3MgaW4gdGhlIGFyZ3VtZW50cyBhcyBpZiBpdCB3ZXJlIGEgc2luZ2xlCiAqIGZ1bmN0aW9uIGNhbGwuIFRoZSBzaWduYXR1cmUgaXMgYCguLmFyZ3MsIGNhbGxiYWNrKWAuIElmIGludm9rZWQgd2l0aCBhbnkKICogYXJndW1lbnRzLCBgY2FsbGJhY2tgIGlzIHJlcXVpcmVkLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5hcHBseUVhY2goW2VuYWJsZVNlYXJjaCwgdXBkYXRlU2NoZW1hXSwgJ2J1Y2tldCcsIGNhbGxiYWNrKTsKICoKICogLy8gcGFydGlhbCBhcHBsaWNhdGlvbiBleGFtcGxlOgogKiBhc3luYy5lYWNoKAogKiAgICAgYnVja2V0cywKICogICAgIGFzeW5jLmFwcGx5RWFjaChbZW5hYmxlU2VhcmNoLCB1cGRhdGVTY2hlbWFdKSwKICogICAgIGNhbGxiYWNrCiAqICk7CiAqLwp2YXIgYXBwbHlFYWNoID0gYXBwbHlFYWNoJDEobWFwKTsKCmZ1bmN0aW9uIGRvUGFyYWxsZWxMaW1pdChmbikgewogICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgICAgICByZXR1cm4gZm4oX2VhY2hPZkxpbWl0KGxpbWl0KSwgb2JqLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7CiAgICB9Owp9CgovKioKICogVGhlIHNhbWUgYXMgW2BtYXBgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICoKICogQG5hbWUgbWFwTGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgaXRlbS4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXkgb2YgdGhlCiAqIHRyYW5zZm9ybWVkIGl0ZW1zIGZyb20gdGhlIGBjb2xsYC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLgogKi8KdmFyIG1hcExpbWl0ID0gZG9QYXJhbGxlbExpbWl0KF9hc3luY01hcCk7CgovKioKICogVGhlIHNhbWUgYXMgW2BtYXBgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIG1hcFNlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgaXRlbS4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXkgb2YgdGhlCiAqIHRyYW5zZm9ybWVkIGl0ZW1zIGZyb20gdGhlIGBjb2xsYC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLgogKi8KdmFyIG1hcFNlcmllcyA9IGRvTGltaXQobWFwTGltaXQsIDEpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgYXBwbHlFYWNoYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmFwcGx5RWFjaH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBhcHBseUVhY2hTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuYXBwbHlFYWNoXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXBwbHlFYWNofQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBmbnMgLSBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFzeW5jRnVuY3Rpb259cyB0byBhbGwKICogY2FsbCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cwogKiBAcGFyYW0gey4uLip9IFthcmdzXSAtIGFueSBudW1iZXIgb2Ygc2VwYXJhdGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlCiAqIGZ1bmN0aW9uLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gdGhlIGZpbmFsIGFyZ3VtZW50IHNob3VsZCBiZSB0aGUgY2FsbGJhY2ssCiAqIGNhbGxlZCB3aGVuIGFsbCBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgcHJvY2Vzc2luZy4KICogQHJldHVybnMge0Z1bmN0aW9ufSAtIElmIG9ubHkgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBpdCB3aWxsIHJldHVybgogKiBhIGZ1bmN0aW9uIHdoaWNoIGxldHMgeW91IHBhc3MgaW4gdGhlIGFyZ3VtZW50cyBhcyBpZiBpdCB3ZXJlIGEgc2luZ2xlCiAqIGZ1bmN0aW9uIGNhbGwuCiAqLwp2YXIgYXBwbHlFYWNoU2VyaWVzID0gYXBwbHlFYWNoJDEobWFwU2VyaWVzKTsKCi8qKgogKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yCiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuCiAqLwpmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7CiAgdmFyIGluZGV4ID0gLTEsCiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoOwoKICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkgewogICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHsKICAgICAgYnJlYWs7CiAgICB9CiAgfQogIHJldHVybiBhcnJheTsKfQoKLyoqCiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC4KICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi4KICovCmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7CiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7CiAgICB2YXIgaW5kZXggPSAtMSwKICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLAogICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSwKICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7CgogICAgd2hpbGUgKGxlbmd0aC0tKSB7CiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTsKICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkgewogICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gb2JqZWN0OwogIH07Cn0KCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YAogKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4KICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLgogKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLgogKi8KdmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uCiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuCiAqLwpmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHsKICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7Cn0KCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0CiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi4KICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uCiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LgogKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLgogKi8KZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkgewogIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsCiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7CgogIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7CiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgewogICAgICByZXR1cm4gaW5kZXg7CiAgICB9CiAgfQogIHJldHVybiAtMTsKfQoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC4KICovCmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkgewogIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7Cn0KCi8qKgogKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5CiAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuCiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLgogKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLgogKi8KZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkgewogIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsCiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsKCiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHsKICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7CiAgICAgIHJldHVybiBpbmRleDsKICAgIH0KICB9CiAgcmV0dXJuIC0xOwp9CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC4KICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci4KICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uCiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuCiAqLwpmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkgewogIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUKICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkKICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpOwp9CgovKioKICogRGV0ZXJtaW5lcyB0aGUgYmVzdCBvcmRlciBmb3IgcnVubmluZyB0aGUge0BsaW5rIEFzeW5jRnVuY3Rpb259cyBpbiBgdGFza3NgLCBiYXNlZCBvbgogKiB0aGVpciByZXF1aXJlbWVudHMuIEVhY2ggZnVuY3Rpb24gY2FuIG9wdGlvbmFsbHkgZGVwZW5kIG9uIG90aGVyIGZ1bmN0aW9ucwogKiBiZWluZyBjb21wbGV0ZWQgZmlyc3QsIGFuZCBlYWNoIGZ1bmN0aW9uIGlzIHJ1biBhcyBzb29uIGFzIGl0cyByZXF1aXJlbWVudHMKICogYXJlIHNhdGlzZmllZC4KICoKICogSWYgYW55IG9mIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXIgY2FsbGJhY2ssIHRoZSBgYXV0b2Agc2VxdWVuY2UKICogd2lsbCBzdG9wLiBGdXJ0aGVyIHRhc2tzIHdpbGwgbm90IGV4ZWN1dGUgKHNvIGFueSBvdGhlciBmdW5jdGlvbnMgZGVwZW5kaW5nCiAqIG9uIGl0IHdpbGwgbm90IHJ1biksIGFuZCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZQogKiBlcnJvci4KICoKICoge0BsaW5rIEFzeW5jRnVuY3Rpb259cyBhbHNvIHJlY2VpdmUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlc3VsdHMgb2YgZnVuY3Rpb25zIHdoaWNoCiAqIGhhdmUgY29tcGxldGVkIHNvIGZhciBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIGlmIHRoZXkgaGF2ZSBkZXBlbmRlbmNpZXMuIElmIGEKICogdGFzayBmdW5jdGlvbiBoYXMgbm8gZGVwZW5kZW5jaWVzLCBpdCB3aWxsIG9ubHkgYmUgcGFzc2VkIGEgY2FsbGJhY2suCiAqCiAqIEBuYW1lIGF1dG8KICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge09iamVjdH0gdGFza3MgLSBBbiBvYmplY3QuIEVhY2ggb2YgaXRzIHByb3BlcnRpZXMgaXMgZWl0aGVyIGEKICogZnVuY3Rpb24gb3IgYW4gYXJyYXkgb2YgcmVxdWlyZW1lbnRzLCB3aXRoIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn0gaXRzZWxmIHRoZSBsYXN0IGl0ZW0KICogaW4gdGhlIGFycmF5LiBUaGUgb2JqZWN0J3Mga2V5IG9mIGEgcHJvcGVydHkgc2VydmVzIGFzIHRoZSBuYW1lIG9mIHRoZSB0YXNrCiAqIGRlZmluZWQgYnkgdGhhdCBwcm9wZXJ0eSwgaS5lLiBjYW4gYmUgdXNlZCB3aGVuIHNwZWNpZnlpbmcgcmVxdWlyZW1lbnRzIGZvcgogKiBvdGhlciB0YXNrcy4gVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIG9uZSBvciB0d28gYXJndW1lbnRzOgogKiAqIGEgYHJlc3VsdHNgIG9iamVjdCwgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXNseSBleGVjdXRlZAogKiAgIGZ1bmN0aW9ucywgb25seSBwYXNzZWQgaWYgdGhlIHRhc2sgaGFzIGFueSBkZXBlbmRlbmNpZXMsCiAqICogYSBgY2FsbGJhY2soZXJyLCByZXN1bHQpYCBmdW5jdGlvbiwgd2hpY2ggbXVzdCBiZSBjYWxsZWQgd2hlbiBmaW5pc2hlZCwKICogICBwYXNzaW5nIGFuIGBlcnJvcmAgKHdoaWNoIGNhbiBiZSBgbnVsbGApIGFuZCB0aGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbidzCiAqICAgZXhlY3V0aW9uLgogKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSAtIEFuIG9wdGlvbmFsIGBpbnRlZ2VyYCBmb3IKICogZGV0ZXJtaW5pbmcgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRhc2tzIHRoYXQgY2FuIGJlIHJ1biBpbiBwYXJhbGxlbC4gQnkKICogZGVmYXVsdCwgYXMgbWFueSBhcyBwb3NzaWJsZS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbAogKiB0aGUgdGFza3MgaGF2ZSBiZWVuIGNvbXBsZXRlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFyZ3VtZW50IGlmIGFueSBgdGFza3NgCiAqIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXIgY2FsbGJhY2suIFJlc3VsdHMgYXJlIGFsd2F5cyByZXR1cm5lZDsgaG93ZXZlciwgaWYgYW4KICogZXJyb3Igb2NjdXJzLCBubyBmdXJ0aGVyIGB0YXNrc2Agd2lsbCBiZSBwZXJmb3JtZWQsIGFuZCB0aGUgcmVzdWx0cyBvYmplY3QKICogd2lsbCBvbmx5IGNvbnRhaW4gcGFydGlhbCByZXN1bHRzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqIEByZXR1cm5zIHVuZGVmaW5lZAogKiBAZXhhbXBsZQogKgogKiBhc3luYy5hdXRvKHsKICogICAgIC8vIHRoaXMgZnVuY3Rpb24gd2lsbCBqdXN0IGJlIHBhc3NlZCBhIGNhbGxiYWNrCiAqICAgICByZWFkRGF0YTogYXN5bmMuYXBwbHkoZnMucmVhZEZpbGUsICdkYXRhLnR4dCcsICd1dGYtOCcpLAogKiAgICAgc2hvd0RhdGE6IFsncmVhZERhdGEnLCBmdW5jdGlvbihyZXN1bHRzLCBjYikgewogKiAgICAgICAgIC8vIHJlc3VsdHMucmVhZERhdGEgaXMgdGhlIGZpbGUncyBjb250ZW50cwogKiAgICAgICAgIC8vIC4uLgogKiAgICAgfV0KICogfSwgY2FsbGJhY2spOwogKgogKiBhc3luYy5hdXRvKHsKICogICAgIGdldF9kYXRhOiBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiBnZXRfZGF0YScpOwogKiAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gZ2V0IHNvbWUgZGF0YQogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdkYXRhJywgJ2NvbnZlcnRlZCB0byBhcnJheScpOwogKiAgICAgfSwKICogICAgIG1ha2VfZm9sZGVyOiBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiBtYWtlX2ZvbGRlcicpOwogKiAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gY3JlYXRlIGEgZGlyZWN0b3J5IHRvIHN0b3JlIGEgZmlsZSBpbgogKiAgICAgICAgIC8vIHRoaXMgaXMgcnVuIGF0IHRoZSBzYW1lIHRpbWUgYXMgZ2V0dGluZyB0aGUgZGF0YQogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmb2xkZXInKTsKICogICAgIH0sCiAqICAgICB3cml0ZV9maWxlOiBbJ2dldF9kYXRhJywgJ21ha2VfZm9sZGVyJywgZnVuY3Rpb24ocmVzdWx0cywgY2FsbGJhY2spIHsKICogICAgICAgICBjb25zb2xlLmxvZygnaW4gd3JpdGVfZmlsZScsIEpTT04uc3RyaW5naWZ5KHJlc3VsdHMpKTsKICogICAgICAgICAvLyBvbmNlIHRoZXJlIGlzIHNvbWUgZGF0YSBhbmQgdGhlIGRpcmVjdG9yeSBleGlzdHMsCiAqICAgICAgICAgLy8gd3JpdGUgdGhlIGRhdGEgdG8gYSBmaWxlIGluIHRoZSBkaXJlY3RvcnkKICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTsKICogICAgIH1dLAogKiAgICAgZW1haWxfbGluazogWyd3cml0ZV9maWxlJywgZnVuY3Rpb24ocmVzdWx0cywgY2FsbGJhY2spIHsKICogICAgICAgICBjb25zb2xlLmxvZygnaW4gZW1haWxfbGluaycsIEpTT04uc3RyaW5naWZ5KHJlc3VsdHMpKTsKICogICAgICAgICAvLyBvbmNlIHRoZSBmaWxlIGlzIHdyaXR0ZW4gbGV0J3MgZW1haWwgYSBsaW5rIHRvIGl0Li4uCiAqICAgICAgICAgLy8gcmVzdWx0cy53cml0ZV9maWxlIGNvbnRhaW5zIHRoZSBmaWxlbmFtZSByZXR1cm5lZCBieSB3cml0ZV9maWxlLgogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6cmVzdWx0cy53cml0ZV9maWxlLCAnZW1haWwnOid1c2VyQGV4YW1wbGUuY29tJ30pOwogKiAgICAgfV0KICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTsKICogICAgIGNvbnNvbGUubG9nKCdyZXN1bHRzID0gJywgcmVzdWx0cyk7CiAqIH0pOwogKi8KdmFyIGF1dG8gPSBmdW5jdGlvbiAodGFza3MsIGNvbmN1cnJlbmN5LCBjYWxsYmFjaykgewogICAgaWYgKHR5cGVvZiBjb25jdXJyZW5jeSA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgIC8vIGNvbmN1cnJlbmN5IGlzIG9wdGlvbmFsLCBzaGlmdCB0aGUgYXJncy4KICAgICAgICBjYWxsYmFjayA9IGNvbmN1cnJlbmN5OwogICAgICAgIGNvbmN1cnJlbmN5ID0gbnVsbDsKICAgIH0KICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIHZhciBrZXlzJCQxID0ga2V5cyh0YXNrcyk7CiAgICB2YXIgbnVtVGFza3MgPSBrZXlzJCQxLmxlbmd0aDsKICAgIGlmICghbnVtVGFza3MpIHsKICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7CiAgICB9CiAgICBpZiAoIWNvbmN1cnJlbmN5KSB7CiAgICAgICAgY29uY3VycmVuY3kgPSBudW1UYXNrczsKICAgIH0KCiAgICB2YXIgcmVzdWx0cyA9IHt9OwogICAgdmFyIHJ1bm5pbmdUYXNrcyA9IDA7CiAgICB2YXIgaGFzRXJyb3IgPSBmYWxzZTsKCiAgICB2YXIgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKCiAgICB2YXIgcmVhZHlUYXNrcyA9IFtdOwoKICAgIC8vIGZvciBjeWNsZSBkZXRlY3Rpb246CiAgICB2YXIgcmVhZHlUb0NoZWNrID0gW107IC8vIHRhc2tzIHRoYXQgaGF2ZSBiZWVuIGlkZW50aWZpZWQgYXMgcmVhY2hhYmxlCiAgICAvLyB3aXRob3V0IHRoZSBwb3NzaWJpbGl0eSBvZiByZXR1cm5pbmcgdG8gYW4gYW5jZXN0b3IgdGFzawogICAgdmFyIHVuY2hlY2tlZERlcGVuZGVuY2llcyA9IHt9OwoKICAgIGJhc2VGb3JPd24odGFza3MsIGZ1bmN0aW9uICh0YXNrLCBrZXkpIHsKICAgICAgICBpZiAoIWlzQXJyYXkodGFzaykpIHsKICAgICAgICAgICAgLy8gbm8gZGVwZW5kZW5jaWVzCiAgICAgICAgICAgIGVucXVldWVUYXNrKGtleSwgW3Rhc2tdKTsKICAgICAgICAgICAgcmVhZHlUb0NoZWNrLnB1c2goa2V5KTsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IHRhc2suc2xpY2UoMCwgdGFzay5sZW5ndGggLSAxKTsKICAgICAgICB2YXIgcmVtYWluaW5nRGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzLmxlbmd0aDsKICAgICAgICBpZiAocmVtYWluaW5nRGVwZW5kZW5jaWVzID09PSAwKSB7CiAgICAgICAgICAgIGVucXVldWVUYXNrKGtleSwgdGFzayk7CiAgICAgICAgICAgIHJlYWR5VG9DaGVjay5wdXNoKGtleSk7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgdW5jaGVja2VkRGVwZW5kZW5jaWVzW2tleV0gPSByZW1haW5pbmdEZXBlbmRlbmNpZXM7CgogICAgICAgIGFycmF5RWFjaChkZXBlbmRlbmNpZXMsIGZ1bmN0aW9uIChkZXBlbmRlbmN5TmFtZSkgewogICAgICAgICAgICBpZiAoIXRhc2tzW2RlcGVuZGVuY3lOYW1lXSkgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3luYy5hdXRvIHRhc2sgYCcgKyBrZXkgKwogICAgICAgICAgICAgICAgICAgICdgIGhhcyBhIG5vbi1leGlzdGVudCBkZXBlbmRlbmN5IGAnICsKICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5TmFtZSArICdgIGluICcgKwogICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5qb2luKCcsICcpKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBhZGRMaXN0ZW5lcihkZXBlbmRlbmN5TmFtZSwgZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgcmVtYWluaW5nRGVwZW5kZW5jaWVzLS07CiAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nRGVwZW5kZW5jaWVzID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICB9KTsKCiAgICBjaGVja0ZvckRlYWRsb2NrcygpOwogICAgcHJvY2Vzc1F1ZXVlKCk7CgogICAgZnVuY3Rpb24gZW5xdWV1ZVRhc2soa2V5LCB0YXNrKSB7CiAgICAgICAgcmVhZHlUYXNrcy5wdXNoKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgcnVuVGFzayhrZXksIHRhc2spOwogICAgICAgIH0pOwogICAgfQoKICAgIGZ1bmN0aW9uIHByb2Nlc3NRdWV1ZSgpIHsKICAgICAgICBpZiAocmVhZHlUYXNrcy5sZW5ndGggPT09IDAgJiYgcnVubmluZ1Rhc2tzID09PSAwKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXN1bHRzKTsKICAgICAgICB9CiAgICAgICAgd2hpbGUocmVhZHlUYXNrcy5sZW5ndGggJiYgcnVubmluZ1Rhc2tzIDwgY29uY3VycmVuY3kpIHsKICAgICAgICAgICAgdmFyIHJ1biA9IHJlYWR5VGFza3Muc2hpZnQoKTsKICAgICAgICAgICAgcnVuKCk7CiAgICAgICAgfQoKICAgIH0KCiAgICBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0YXNrTmFtZSwgZm4pIHsKICAgICAgICB2YXIgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV07CiAgICAgICAgaWYgKCF0YXNrTGlzdGVuZXJzKSB7CiAgICAgICAgICAgIHRhc2tMaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbdGFza05hbWVdID0gW107CiAgICAgICAgfQoKICAgICAgICB0YXNrTGlzdGVuZXJzLnB1c2goZm4pOwogICAgfQoKICAgIGZ1bmN0aW9uIHRhc2tDb21wbGV0ZSh0YXNrTmFtZSkgewogICAgICAgIHZhciB0YXNrTGlzdGVuZXJzID0gbGlzdGVuZXJzW3Rhc2tOYW1lXSB8fCBbXTsKICAgICAgICBhcnJheUVhY2godGFza0xpc3RlbmVycywgZnVuY3Rpb24gKGZuKSB7CiAgICAgICAgICAgIGZuKCk7CiAgICAgICAgfSk7CiAgICAgICAgcHJvY2Vzc1F1ZXVlKCk7CiAgICB9CgoKICAgIGZ1bmN0aW9uIHJ1blRhc2soa2V5LCB0YXNrKSB7CiAgICAgICAgaWYgKGhhc0Vycm9yKSByZXR1cm47CgogICAgICAgIHZhciB0YXNrQ2FsbGJhY2sgPSBvbmx5T25jZShmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogICAgICAgICAgICBydW5uaW5nVGFza3MtLTsKICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgIHZhciBzYWZlUmVzdWx0cyA9IHt9OwogICAgICAgICAgICAgICAgYmFzZUZvck93bihyZXN1bHRzLCBmdW5jdGlvbih2YWwsIHJrZXkpIHsKICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1tya2V5XSA9IHZhbDsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba2V5XSA9IHJlc3VsdDsKICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTsKICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7CgogICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBzYWZlUmVzdWx0cyk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZXN1bHQ7CiAgICAgICAgICAgICAgICB0YXNrQ29tcGxldGUoa2V5KTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwoKICAgICAgICBydW5uaW5nVGFza3MrKzsKICAgICAgICB2YXIgdGFza0ZuID0gd3JhcEFzeW5jKHRhc2tbdGFzay5sZW5ndGggLSAxXSk7CiAgICAgICAgaWYgKHRhc2subGVuZ3RoID4gMSkgewogICAgICAgICAgICB0YXNrRm4ocmVzdWx0cywgdGFza0NhbGxiYWNrKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB0YXNrRm4odGFza0NhbGxiYWNrKTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gY2hlY2tGb3JEZWFkbG9ja3MoKSB7CiAgICAgICAgLy8gS2FobidzIGFsZ29yaXRobQogICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvcG9sb2dpY2FsX3NvcnRpbmcjS2Fobi4yN3NfYWxnb3JpdGhtCiAgICAgICAgLy8gaHR0cDovL2Nvbm5hbGxlLmJsb2dzcG90LmNvbS8yMDEzLzEwL3RvcG9sb2dpY2FsLXNvcnRpbmdrYWhuLWFsZ29yaXRobS5odG1sCiAgICAgICAgdmFyIGN1cnJlbnRUYXNrOwogICAgICAgIHZhciBjb3VudGVyID0gMDsKICAgICAgICB3aGlsZSAocmVhZHlUb0NoZWNrLmxlbmd0aCkgewogICAgICAgICAgICBjdXJyZW50VGFzayA9IHJlYWR5VG9DaGVjay5wb3AoKTsKICAgICAgICAgICAgY291bnRlcisrOwogICAgICAgICAgICBhcnJheUVhY2goZ2V0RGVwZW5kZW50cyhjdXJyZW50VGFzayksIGZ1bmN0aW9uIChkZXBlbmRlbnQpIHsKICAgICAgICAgICAgICAgIGlmICgtLXVuY2hlY2tlZERlcGVuZGVuY2llc1tkZXBlbmRlbnRdID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgcmVhZHlUb0NoZWNrLnB1c2goZGVwZW5kZW50KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgfQoKICAgICAgICBpZiAoY291bnRlciAhPT0gbnVtVGFza3MpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKAogICAgICAgICAgICAgICAgJ2FzeW5jLmF1dG8gY2Fubm90IGV4ZWN1dGUgdGFza3MgZHVlIHRvIGEgcmVjdXJzaXZlIGRlcGVuZGVuY3knCiAgICAgICAgICAgICk7CiAgICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIGdldERlcGVuZGVudHModGFza05hbWUpIHsKICAgICAgICB2YXIgcmVzdWx0ID0gW107CiAgICAgICAgYmFzZUZvck93bih0YXNrcywgZnVuY3Rpb24gKHRhc2ssIGtleSkgewogICAgICAgICAgICBpZiAoaXNBcnJheSh0YXNrKSAmJiBiYXNlSW5kZXhPZih0YXNrLCB0YXNrTmFtZSwgMCkgPj0gMCkgewogICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9Cn07CgovKioKICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlCiAqIHNob3J0aGFuZHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LgogKi8KZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7CiAgdmFyIGluZGV4ID0gLTEsCiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLAogICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpOwoKICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkgewogICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTsKICB9CiAgcmV0dXJuIHJlc3VsdDsKfQoKLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqLwp2YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDQuMC4wCiAqIEBjYXRlZ29yeSBMYW5nCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7CiAqIC8vID0+IHRydWUKICoKICogXy5pc1N5bWJvbCgnYWJjJyk7CiAqIC8vID0+IGZhbHNlCiAqLwpmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkgewogIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHwKICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7Cn0KCi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqLwp2YXIgSU5GSU5JVFkgPSAxIC8gMDsKCi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqLwp2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wkMSA/IFN5bWJvbCQxLnByb3RvdHlwZSA6IHVuZGVmaW5lZDsKdmFyIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDsKCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2gKICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuCiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy4KICovCmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkgewogIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuCiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykgewogICAgcmV0dXJuIHZhbHVlOwogIH0KICBpZiAoaXNBcnJheSh2YWx1ZSkpIHsKICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuCiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJzsKICB9CiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkgewogICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJzsKICB9CiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTsKICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7Cn0KCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuCiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLgogKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uCiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC4KICovCmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkgewogIHZhciBpbmRleCA9IC0xLAogICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7CgogIGlmIChzdGFydCA8IDApIHsKICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7CiAgfQogIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDsKICBpZiAoZW5kIDwgMCkgewogICAgZW5kICs9IGxlbmd0aDsKICB9CiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApOwogIHN0YXJ0ID4+Pj0gMDsKCiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7CiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHsKICAgIHJlc3VsdFtpbmRleF0gPSBhcnJheVtpbmRleCArIHN0YXJ0XTsKICB9CiAgcmV0dXJuIHJlc3VsdDsKfQoKLyoqCiAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuCiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgcG9zaXRpb24uCiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLgogKi8KZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7CiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsKICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZDsKICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTsKfQoKLyoqCiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgc3RyaW5nIHN5bWJvbAogKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuCiAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuCiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLgogKi8KZnVuY3Rpb24gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7CiAgdmFyIGluZGV4ID0gc3RyU3ltYm9scy5sZW5ndGg7CgogIHdoaWxlIChpbmRleC0tICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fQogIHJldHVybiBpbmRleDsKfQoKLyoqCiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1TdGFydGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgc3RyaW5nIHN5bWJvbAogKiB0aGF0IGlzIG5vdCBmb3VuZCBpbiB0aGUgY2hhcmFjdGVyIHN5bWJvbHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7QXJyYXl9IHN0clN5bWJvbHMgVGhlIHN0cmluZyBzeW1ib2xzIHRvIGluc3BlY3QuCiAqIEBwYXJhbSB7QXJyYXl9IGNoclN5bWJvbHMgVGhlIGNoYXJhY3RlciBzeW1ib2xzIHRvIGZpbmQuCiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC4KICovCmZ1bmN0aW9uIGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSB7CiAgdmFyIGluZGV4ID0gLTEsCiAgICAgIGxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoOwoKICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge30KICByZXR1cm4gaW5kZXg7Cn0KCi8qKgogKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuCiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LgogKi8KZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykgewogIHJldHVybiBzdHJpbmcuc3BsaXQoJycpOwp9CgovKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovCnZhciByc0FzdHJhbFJhbmdlID0gJ1xcdWQ4MDAtXFx1ZGZmZic7CnZhciByc0NvbWJvTWFya3NSYW5nZSA9ICdcXHUwMzAwLVxcdTAzNmYnOwp2YXIgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcdWZlMjAtXFx1ZmUyZic7CnZhciByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcdTIwZDAtXFx1MjBmZic7CnZhciByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2U7CnZhciByc1ZhclJhbmdlID0gJ1xcdWZlMGVcXHVmZTBmJzsKCi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi8KdmFyIHJzWldKID0gJ1xcdTIwMGQnOwoKLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovCnZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpOwoKLyoqCiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC4KICovCmZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7CiAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7Cn0KCi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi8KdmFyIHJzQXN0cmFsUmFuZ2UkMSA9ICdcXHVkODAwLVxcdWRmZmYnOwp2YXIgcnNDb21ib01hcmtzUmFuZ2UkMSA9ICdcXHUwMzAwLVxcdTAzNmYnOwp2YXIgcmVDb21ib0hhbGZNYXJrc1JhbmdlJDEgPSAnXFx1ZmUyMC1cXHVmZTJmJzsKdmFyIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMSA9ICdcXHUyMGQwLVxcdTIwZmYnOwp2YXIgcnNDb21ib1JhbmdlJDEgPSByc0NvbWJvTWFya3NSYW5nZSQxICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlJDEgKyByc0NvbWJvU3ltYm9sc1JhbmdlJDE7CnZhciByc1ZhclJhbmdlJDEgPSAnXFx1ZmUwZVxcdWZlMGYnOwoKLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqLwp2YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlJDEgKyAnXSc7CnZhciByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlJDEgKyAnXSc7CnZhciByc0ZpdHogPSAnXFx1ZDgzY1tcXHVkZmZiLVxcdWRmZmZdJzsKdmFyIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKSc7CnZhciByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlJDEgKyAnXSc7CnZhciByc1JlZ2lvbmFsID0gJyg/OlxcdWQ4M2NbXFx1ZGRlNi1cXHVkZGZmXSl7Mn0nOwp2YXIgcnNTdXJyUGFpciA9ICdbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdJzsKdmFyIHJzWldKJDEgPSAnXFx1MjAwZCc7CgovKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi8KdmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JzsKdmFyIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSQxICsgJ10/JzsKdmFyIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0okMSArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJzsKdmFyIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbjsKdmFyIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknOwoKLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi8KdmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpOwoKLyoqCiAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuCiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LgogKi8KZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7CiAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdOwp9CgovKioKICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS4KICovCmZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7CiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKQogICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpCiAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpOwp9CgovKioKICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGAKICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDQuMC4wCiAqIEBjYXRlZ29yeSBMYW5nCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuCiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuCiAqIEBleGFtcGxlCiAqCiAqIF8udG9TdHJpbmcobnVsbCk7CiAqIC8vID0+ICcnCiAqCiAqIF8udG9TdHJpbmcoLTApOwogKiAvLyA9PiAnLTAnCiAqCiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTsKICogLy8gPT4gJzEsMiwzJwogKi8KZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHsKICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTsKfQoKLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi8KdmFyIHJlVHJpbSA9IC9eXHMrfFxzKyQvZzsKCi8qKgogKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgMy4wLjAKICogQGNhdGVnb3J5IFN0cmluZwogKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLgogKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uCiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuCiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLgogKiBAZXhhbXBsZQogKgogKiBfLnRyaW0oJyAgYWJjICAnKTsKICogLy8gPT4gJ2FiYycKICoKICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTsKICogLy8gPT4gJ2FiYycKICoKICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTsKICogLy8gPT4gWydmb28nLCAnYmFyJ10KICovCmZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHsKICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpOwogIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7CiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltLCAnJyk7CiAgfQogIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkgewogICAgcmV0dXJuIHN0cmluZzsKICB9CiAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksCiAgICAgIGNoclN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KGNoYXJzKSwKICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scyksCiAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykgKyAxOwoKICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0LCBlbmQpLmpvaW4oJycpOwp9Cgp2YXIgRk5fQVJHUyA9IC9eKD86YXN5bmNccyspPyhmdW5jdGlvbik/XHMqW15cKF0qXChccyooW15cKV0qKVwpL207CnZhciBGTl9BUkdfU1BMSVQgPSAvLC87CnZhciBGTl9BUkcgPSAvKD0uKyk/KFxzKikkLzsKdmFyIFNUUklQX0NPTU1FTlRTID0gLygoXC9cLy4qJCl8KFwvXCpbXHNcU10qP1wqXC8pKS9tZzsKCmZ1bmN0aW9uIHBhcnNlUGFyYW1zKGZ1bmMpIHsKICAgIGZ1bmMgPSBmdW5jLnRvU3RyaW5nKCkucmVwbGFjZShTVFJJUF9DT01NRU5UUywgJycpOwogICAgZnVuYyA9IGZ1bmMubWF0Y2goRk5fQVJHUylbMl0ucmVwbGFjZSgnICcsICcnKTsKICAgIGZ1bmMgPSBmdW5jID8gZnVuYy5zcGxpdChGTl9BUkdfU1BMSVQpIDogW107CiAgICBmdW5jID0gZnVuYy5tYXAoZnVuY3Rpb24gKGFyZyl7CiAgICAgICAgcmV0dXJuIHRyaW0oYXJnLnJlcGxhY2UoRk5fQVJHLCAnJykpOwogICAgfSk7CiAgICByZXR1cm4gZnVuYzsKfQoKLyoqCiAqIEEgZGVwZW5kZW5jeS1pbmplY3RlZCB2ZXJzaW9uIG9mIHRoZSBbYXN5bmMuYXV0b117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99IGZ1bmN0aW9uLiBEZXBlbmRlbnQKICogdGFza3MgYXJlIHNwZWNpZmllZCBhcyBwYXJhbWV0ZXJzIHRvIHRoZSBmdW5jdGlvbiwgYWZ0ZXIgdGhlIHVzdWFsIGNhbGxiYWNrCiAqIHBhcmFtZXRlciwgd2l0aCB0aGUgcGFyYW1ldGVyIG5hbWVzIG1hdGNoaW5nIHRoZSBuYW1lcyBvZiB0aGUgdGFza3MgaXQKICogZGVwZW5kcyBvbi4gVGhpcyBjYW4gcHJvdmlkZSBldmVuIG1vcmUgcmVhZGFibGUgdGFzayBncmFwaHMgd2hpY2ggY2FuIGJlCiAqIGVhc2llciB0byBtYWludGFpbi4KICoKICogSWYgYSBmaW5hbCBjYWxsYmFjayBpcyBzcGVjaWZpZWQsIHRoZSB0YXNrIHJlc3VsdHMgYXJlIHNpbWlsYXJseSBpbmplY3RlZCwKICogc3BlY2lmaWVkIGFzIG5hbWVkIHBhcmFtZXRlcnMgYWZ0ZXIgdGhlIGluaXRpYWwgZXJyb3IgcGFyYW1ldGVyLgogKgogKiBUaGUgYXV0b0luamVjdCBmdW5jdGlvbiBpcyBwdXJlbHkgc3ludGFjdGljIHN1Z2FyIGFuZCBpdHMgc2VtYW50aWNzIGFyZQogKiBvdGhlcndpc2UgZXF1aXZhbGVudCB0byBbYXN5bmMuYXV0b117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99LgogKgogKiBAbmFtZSBhdXRvSW5qZWN0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmF1dG9de0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hdXRvfQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrcyAtIEFuIG9iamVjdCwgZWFjaCBvZiB3aG9zZSBwcm9wZXJ0aWVzIGlzIGFuIHtAbGluayBBc3luY0Z1bmN0aW9ufSBvZgogKiB0aGUgZm9ybSAnZnVuYyhbZGVwZW5kZW5jaWVzLi4uXSwgY2FsbGJhY2spLiBUaGUgb2JqZWN0J3Mga2V5IG9mIGEgcHJvcGVydHkKICogc2VydmVzIGFzIHRoZSBuYW1lIG9mIHRoZSB0YXNrIGRlZmluZWQgYnkgdGhhdCBwcm9wZXJ0eSwgaS5lLiBjYW4gYmUgdXNlZAogKiB3aGVuIHNwZWNpZnlpbmcgcmVxdWlyZW1lbnRzIGZvciBvdGhlciB0YXNrcy4KICogKiBUaGUgYGNhbGxiYWNrYCBwYXJhbWV0ZXIgaXMgYSBgY2FsbGJhY2soZXJyLCByZXN1bHQpYCB3aGljaCBtdXN0IGJlIGNhbGxlZAogKiAgIHdoZW4gZmluaXNoZWQsIHBhc3NpbmcgYW4gYGVycm9yYCAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIHRoZSByZXN1bHQgb2YKICogICB0aGUgZnVuY3Rpb24ncyBleGVjdXRpb24uIFRoZSByZW1haW5pbmcgcGFyYW1ldGVycyBuYW1lIG90aGVyIHRhc2tzIG9uCiAqICAgd2hpY2ggdGhlIHRhc2sgaXMgZGVwZW5kZW50LCBhbmQgdGhlIHJlc3VsdHMgZnJvbSB0aG9zZSB0YXNrcyBhcmUgdGhlCiAqICAgYXJndW1lbnRzIG9mIHRob3NlIHBhcmFtZXRlcnMuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwKICogdGhlIHRhc2tzIGhhdmUgYmVlbiBjb21wbGV0ZWQuIEl0IHJlY2VpdmVzIHRoZSBgZXJyYCBhcmd1bWVudCBpZiBhbnkgYHRhc2tzYAogKiBwYXNzIGFuIGVycm9yIHRvIHRoZWlyIGNhbGxiYWNrLCBhbmQgYSBgcmVzdWx0c2Agb2JqZWN0IHdpdGggYW55IGNvbXBsZXRlZAogKiB0YXNrIHJlc3VsdHMsIHNpbWlsYXIgdG8gYGF1dG9gLgogKiBAZXhhbXBsZQogKgogKiAvLyAgVGhlIGV4YW1wbGUgZnJvbSBgYXV0b2AgY2FuIGJlIHJld3JpdHRlbiBhcyBmb2xsb3dzOgogKiBhc3luYy5hdXRvSW5qZWN0KHsKICogICAgIGdldF9kYXRhOiBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gZ2V0IHNvbWUgZGF0YQogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdkYXRhJywgJ2NvbnZlcnRlZCB0byBhcnJheScpOwogKiAgICAgfSwKICogICAgIG1ha2VfZm9sZGVyOiBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIC8vIGFzeW5jIGNvZGUgdG8gY3JlYXRlIGEgZGlyZWN0b3J5IHRvIHN0b3JlIGEgZmlsZSBpbgogKiAgICAgICAgIC8vIHRoaXMgaXMgcnVuIGF0IHRoZSBzYW1lIHRpbWUgYXMgZ2V0dGluZyB0aGUgZGF0YQogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmb2xkZXInKTsKICogICAgIH0sCiAqICAgICB3cml0ZV9maWxlOiBmdW5jdGlvbihnZXRfZGF0YSwgbWFrZV9mb2xkZXIsIGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gb25jZSB0aGVyZSBpcyBzb21lIGRhdGEgYW5kIHRoZSBkaXJlY3RvcnkgZXhpc3RzLAogKiAgICAgICAgIC8vIHdyaXRlIHRoZSBkYXRhIHRvIGEgZmlsZSBpbiB0aGUgZGlyZWN0b3J5CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZpbGVuYW1lJyk7CiAqICAgICB9LAogKiAgICAgZW1haWxfbGluazogZnVuY3Rpb24od3JpdGVfZmlsZSwgY2FsbGJhY2spIHsKICogICAgICAgICAvLyBvbmNlIHRoZSBmaWxlIGlzIHdyaXR0ZW4gbGV0J3MgZW1haWwgYSBsaW5rIHRvIGl0Li4uCiAqICAgICAgICAgLy8gd3JpdGVfZmlsZSBjb250YWlucyB0aGUgZmlsZW5hbWUgcmV0dXJuZWQgYnkgd3JpdGVfZmlsZS4KICogICAgICAgICBjYWxsYmFjayhudWxsLCB7J2ZpbGUnOndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7CiAqICAgICB9CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgY29uc29sZS5sb2coJ2VyciA9ICcsIGVycik7CiAqICAgICBjb25zb2xlLmxvZygnZW1haWxfbGluayA9ICcsIHJlc3VsdHMuZW1haWxfbGluayk7CiAqIH0pOwogKgogKiAvLyBJZiB5b3UgYXJlIHVzaW5nIGEgSlMgbWluaWZpZXIgdGhhdCBtYW5nbGVzIHBhcmFtZXRlciBuYW1lcywgYGF1dG9JbmplY3RgCiAqIC8vIHdpbGwgbm90IHdvcmsgd2l0aCBwbGFpbiBmdW5jdGlvbnMsIHNpbmNlIHRoZSBwYXJhbWV0ZXIgbmFtZXMgd2lsbCBiZQogKiAvLyBjb2xsYXBzZWQgdG8gYSBzaW5nbGUgbGV0dGVyIGlkZW50aWZpZXIuICBUbyB3b3JrIGFyb3VuZCB0aGlzLCB5b3UgY2FuCiAqIC8vIGV4cGxpY2l0bHkgc3BlY2lmeSB0aGUgbmFtZXMgb2YgdGhlIHBhcmFtZXRlcnMgeW91ciB0YXNrIGZ1bmN0aW9uIG5lZWRzCiAqIC8vIGluIGFuIGFycmF5LCBzaW1pbGFyIHRvIEFuZ3VsYXIuanMgZGVwZW5kZW5jeSBpbmplY3Rpb24uCiAqCiAqIC8vIFRoaXMgc3RpbGwgaGFzIGFuIGFkdmFudGFnZSBvdmVyIHBsYWluIGBhdXRvYCwgc2luY2UgdGhlIHJlc3VsdHMgYSB0YXNrCiAqIC8vIGRlcGVuZHMgb24gYXJlIHN0aWxsIHNwcmVhZCBpbnRvIGFyZ3VtZW50cy4KICogYXN5bmMuYXV0b0luamVjdCh7CiAqICAgICAvLy4uLgogKiAgICAgd3JpdGVfZmlsZTogWydnZXRfZGF0YScsICdtYWtlX2ZvbGRlcicsIGZ1bmN0aW9uKGdldF9kYXRhLCBtYWtlX2ZvbGRlciwgY2FsbGJhY2spIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTsKICogICAgIH1dLAogKiAgICAgZW1haWxfbGluazogWyd3cml0ZV9maWxlJywgZnVuY3Rpb24od3JpdGVfZmlsZSwgY2FsbGJhY2spIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCB7J2ZpbGUnOndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7CiAqICAgICB9XQogKiAgICAgLy8uLi4KICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTsKICogICAgIGNvbnNvbGUubG9nKCdlbWFpbF9saW5rID0gJywgcmVzdWx0cy5lbWFpbF9saW5rKTsKICogfSk7CiAqLwpmdW5jdGlvbiBhdXRvSW5qZWN0KHRhc2tzLCBjYWxsYmFjaykgewogICAgdmFyIG5ld1Rhc2tzID0ge307CgogICAgYmFzZUZvck93bih0YXNrcywgZnVuY3Rpb24gKHRhc2tGbiwga2V5KSB7CiAgICAgICAgdmFyIHBhcmFtczsKICAgICAgICB2YXIgZm5Jc0FzeW5jID0gaXNBc3luYyh0YXNrRm4pOwogICAgICAgIHZhciBoYXNOb0RlcHMgPQogICAgICAgICAgICAoIWZuSXNBc3luYyAmJiB0YXNrRm4ubGVuZ3RoID09PSAxKSB8fAogICAgICAgICAgICAoZm5Jc0FzeW5jICYmIHRhc2tGbi5sZW5ndGggPT09IDApOwoKICAgICAgICBpZiAoaXNBcnJheSh0YXNrRm4pKSB7CiAgICAgICAgICAgIHBhcmFtcyA9IHRhc2tGbi5zbGljZSgwLCAtMSk7CiAgICAgICAgICAgIHRhc2tGbiA9IHRhc2tGblt0YXNrRm4ubGVuZ3RoIC0gMV07CgogICAgICAgICAgICBuZXdUYXNrc1trZXldID0gcGFyYW1zLmNvbmNhdChwYXJhbXMubGVuZ3RoID4gMCA/IG5ld1Rhc2sgOiB0YXNrRm4pOwogICAgICAgIH0gZWxzZSBpZiAoaGFzTm9EZXBzKSB7CiAgICAgICAgICAgIC8vIG5vIGRlcGVuZGVuY2llcywgdXNlIHRoZSBmdW5jdGlvbiBhcy1pcwogICAgICAgICAgICBuZXdUYXNrc1trZXldID0gdGFza0ZuOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHBhcmFtcyA9IHBhcnNlUGFyYW1zKHRhc2tGbik7CiAgICAgICAgICAgIGlmICh0YXNrRm4ubGVuZ3RoID09PSAwICYmICFmbklzQXN5bmMgJiYgcGFyYW1zLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJhdXRvSW5qZWN0IHRhc2sgZnVuY3Rpb25zIHJlcXVpcmUgZXhwbGljaXQgcGFyYW1ldGVycy4iKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgLy8gcmVtb3ZlIGNhbGxiYWNrIHBhcmFtCiAgICAgICAgICAgIGlmICghZm5Jc0FzeW5jKSBwYXJhbXMucG9wKCk7CgogICAgICAgICAgICBuZXdUYXNrc1trZXldID0gcGFyYW1zLmNvbmNhdChuZXdUYXNrKTsKICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIG5ld1Rhc2socmVzdWx0cywgdGFza0NiKSB7CiAgICAgICAgICAgIHZhciBuZXdBcmdzID0gYXJyYXlNYXAocGFyYW1zLCBmdW5jdGlvbiAobmFtZSkgewogICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbbmFtZV07CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBuZXdBcmdzLnB1c2godGFza0NiKTsKICAgICAgICAgICAgd3JhcEFzeW5jKHRhc2tGbikuYXBwbHkobnVsbCwgbmV3QXJncyk7CiAgICAgICAgfQogICAgfSk7CgogICAgYXV0byhuZXdUYXNrcywgY2FsbGJhY2spOwp9CgovLyBTaW1wbGUgZG91Ymx5IGxpbmtlZCBsaXN0IChodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibHlfbGlua2VkX2xpc3QpIGltcGxlbWVudGF0aW9uCi8vIHVzZWQgZm9yIHF1ZXVlcy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBhc3N1bWVzIHRoYXQgdGhlIG5vZGUgcHJvdmlkZWQgYnkgdGhlIHVzZXIgY2FuIGJlIG1vZGlmaWVkCi8vIHRvIGFkanVzdCB0aGUgbmV4dCBhbmQgbGFzdCBwcm9wZXJ0aWVzLiBXZSBpbXBsZW1lbnQgb25seSB0aGUgbWluaW1hbCBmdW5jdGlvbmFsaXR5Ci8vIGZvciBxdWV1ZSBzdXBwb3J0LgpmdW5jdGlvbiBETEwoKSB7CiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsOwogICAgdGhpcy5sZW5ndGggPSAwOwp9CgpmdW5jdGlvbiBzZXRJbml0aWFsKGRsbCwgbm9kZSkgewogICAgZGxsLmxlbmd0aCA9IDE7CiAgICBkbGwuaGVhZCA9IGRsbC50YWlsID0gbm9kZTsKfQoKRExMLnByb3RvdHlwZS5yZW1vdmVMaW5rID0gZnVuY3Rpb24obm9kZSkgewogICAgaWYgKG5vZGUucHJldikgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7CiAgICBlbHNlIHRoaXMuaGVhZCA9IG5vZGUubmV4dDsKICAgIGlmIChub2RlLm5leHQpIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2OwogICAgZWxzZSB0aGlzLnRhaWwgPSBub2RlLnByZXY7CgogICAgbm9kZS5wcmV2ID0gbm9kZS5uZXh0ID0gbnVsbDsKICAgIHRoaXMubGVuZ3RoIC09IDE7CiAgICByZXR1cm4gbm9kZTsKfTsKCkRMTC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7CiAgICB3aGlsZSh0aGlzLmhlYWQpIHRoaXMuc2hpZnQoKTsKICAgIHJldHVybiB0aGlzOwp9OwoKRExMLnByb3RvdHlwZS5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uKG5vZGUsIG5ld05vZGUpIHsKICAgIG5ld05vZGUucHJldiA9IG5vZGU7CiAgICBuZXdOb2RlLm5leHQgPSBub2RlLm5leHQ7CiAgICBpZiAobm9kZS5uZXh0KSBub2RlLm5leHQucHJldiA9IG5ld05vZGU7CiAgICBlbHNlIHRoaXMudGFpbCA9IG5ld05vZGU7CiAgICBub2RlLm5leHQgPSBuZXdOb2RlOwogICAgdGhpcy5sZW5ndGggKz0gMTsKfTsKCkRMTC5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24obm9kZSwgbmV3Tm9kZSkgewogICAgbmV3Tm9kZS5wcmV2ID0gbm9kZS5wcmV2OwogICAgbmV3Tm9kZS5uZXh0ID0gbm9kZTsKICAgIGlmIChub2RlLnByZXYpIG5vZGUucHJldi5uZXh0ID0gbmV3Tm9kZTsKICAgIGVsc2UgdGhpcy5oZWFkID0gbmV3Tm9kZTsKICAgIG5vZGUucHJldiA9IG5ld05vZGU7CiAgICB0aGlzLmxlbmd0aCArPSAxOwp9OwoKRExMLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24obm9kZSkgewogICAgaWYgKHRoaXMuaGVhZCkgdGhpcy5pbnNlcnRCZWZvcmUodGhpcy5oZWFkLCBub2RlKTsKICAgIGVsc2Ugc2V0SW5pdGlhbCh0aGlzLCBub2RlKTsKfTsKCkRMTC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKG5vZGUpIHsKICAgIGlmICh0aGlzLnRhaWwpIHRoaXMuaW5zZXJ0QWZ0ZXIodGhpcy50YWlsLCBub2RlKTsKICAgIGVsc2Ugc2V0SW5pdGlhbCh0aGlzLCBub2RlKTsKfTsKCkRMTC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbigpIHsKICAgIHJldHVybiB0aGlzLmhlYWQgJiYgdGhpcy5yZW1vdmVMaW5rKHRoaXMuaGVhZCk7Cn07CgpETEwucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIHRoaXMudGFpbCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy50YWlsKTsKfTsKCkRMTC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHsKICAgIHZhciBhcnIgPSBBcnJheSh0aGlzLmxlbmd0aCk7CiAgICB2YXIgY3VyciA9IHRoaXMuaGVhZDsKICAgIGZvcih2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5sZW5ndGg7IGlkeCsrKSB7CiAgICAgICAgYXJyW2lkeF0gPSBjdXJyLmRhdGE7CiAgICAgICAgY3VyciA9IGN1cnIubmV4dDsKICAgIH0KICAgIHJldHVybiBhcnI7Cn07CgpETEwucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0ZXN0Rm4pIHsKICAgIHZhciBjdXJyID0gdGhpcy5oZWFkOwogICAgd2hpbGUoISFjdXJyKSB7CiAgICAgICAgdmFyIG5leHQgPSBjdXJyLm5leHQ7CiAgICAgICAgaWYgKHRlc3RGbihjdXJyKSkgewogICAgICAgICAgICB0aGlzLnJlbW92ZUxpbmsoY3Vycik7CiAgICAgICAgfQogICAgICAgIGN1cnIgPSBuZXh0OwogICAgfQogICAgcmV0dXJuIHRoaXM7Cn07CgpmdW5jdGlvbiBxdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5LCBwYXlsb2FkKSB7CiAgICBpZiAoY29uY3VycmVuY3kgPT0gbnVsbCkgewogICAgICAgIGNvbmN1cnJlbmN5ID0gMTsKICAgIH0KICAgIGVsc2UgaWYoY29uY3VycmVuY3kgPT09IDApIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmN1cnJlbmN5IG11c3Qgbm90IGJlIHplcm8nKTsKICAgIH0KCiAgICB2YXIgX3dvcmtlciA9IHdyYXBBc3luYyh3b3JrZXIpOwogICAgdmFyIG51bVJ1bm5pbmcgPSAwOwogICAgdmFyIHdvcmtlcnNMaXN0ID0gW107CgogICAgdmFyIHByb2Nlc3NpbmdTY2hlZHVsZWQgPSBmYWxzZTsKICAgIGZ1bmN0aW9uIF9pbnNlcnQoZGF0YSwgaW5zZXJ0QXRGcm9udCwgY2FsbGJhY2spIHsKICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXNrIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpOwogICAgICAgIH0KICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlOwogICAgICAgIGlmICghaXNBcnJheShkYXRhKSkgewogICAgICAgICAgICBkYXRhID0gW2RhdGFdOwogICAgICAgIH0KICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDAgJiYgcS5pZGxlKCkpIHsKICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3MKICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcS5kcmFpbigpOwogICAgICAgICAgICB9KTsKICAgICAgICB9CgogICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgdmFyIGl0ZW0gPSB7CiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhW2ldLAogICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrIHx8IG5vb3AKICAgICAgICAgICAgfTsKCiAgICAgICAgICAgIGlmIChpbnNlcnRBdEZyb250KSB7CiAgICAgICAgICAgICAgICBxLl90YXNrcy51bnNoaWZ0KGl0ZW0pOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcS5fdGFza3MucHVzaChpdGVtKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgaWYgKCFwcm9jZXNzaW5nU2NoZWR1bGVkKSB7CiAgICAgICAgICAgIHByb2Nlc3NpbmdTY2hlZHVsZWQgPSB0cnVlOwogICAgICAgICAgICBzZXRJbW1lZGlhdGUkMShmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdTY2hlZHVsZWQgPSBmYWxzZTsKICAgICAgICAgICAgICAgIHEucHJvY2VzcygpOwogICAgICAgICAgICB9KTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gX25leHQodGFza3MpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXJyKXsKICAgICAgICAgICAgbnVtUnVubmluZyAtPSAxOwoKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0YXNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NbaV07CgogICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYmFzZUluZGV4T2Yod29ya2Vyc0xpc3QsIHRhc2ssIDApOwogICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3Quc2hpZnQoKTsKICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3Quc3BsaWNlKGluZGV4LCAxKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB0YXNrLmNhbGxiYWNrLmFwcGx5KHRhc2ssIGFyZ3VtZW50cyk7CgogICAgICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7CiAgICAgICAgICAgICAgICAgICAgcS5lcnJvcihlcnIsIHRhc2suZGF0YSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIChudW1SdW5uaW5nIDw9IChxLmNvbmN1cnJlbmN5IC0gcS5idWZmZXIpICkgewogICAgICAgICAgICAgICAgcS51bnNhdHVyYXRlZCgpOwogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiAocS5pZGxlKCkpIHsKICAgICAgICAgICAgICAgIHEuZHJhaW4oKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBxLnByb2Nlc3MoKTsKICAgICAgICB9OwogICAgfQoKICAgIHZhciBpc1Byb2Nlc3NpbmcgPSBmYWxzZTsKICAgIHZhciBxID0gewogICAgICAgIF90YXNrczogbmV3IERMTCgpLAogICAgICAgIGNvbmN1cnJlbmN5OiBjb25jdXJyZW5jeSwKICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLAogICAgICAgIHNhdHVyYXRlZDogbm9vcCwKICAgICAgICB1bnNhdHVyYXRlZDpub29wLAogICAgICAgIGJ1ZmZlcjogY29uY3VycmVuY3kgLyA0LAogICAgICAgIGVtcHR5OiBub29wLAogICAgICAgIGRyYWluOiBub29wLAogICAgICAgIGVycm9yOiBub29wLAogICAgICAgIHN0YXJ0ZWQ6IGZhbHNlLAogICAgICAgIHBhdXNlZDogZmFsc2UsCiAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIF9pbnNlcnQoZGF0YSwgZmFsc2UsIGNhbGxiYWNrKTsKICAgICAgICB9LAogICAgICAgIGtpbGw6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgcS5kcmFpbiA9IG5vb3A7CiAgICAgICAgICAgIHEuX3Rhc2tzLmVtcHR5KCk7CiAgICAgICAgfSwKICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHsKICAgICAgICAgICAgX2luc2VydChkYXRhLCB0cnVlLCBjYWxsYmFjayk7CiAgICAgICAgfSwKICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICh0ZXN0Rm4pIHsKICAgICAgICAgICAgcS5fdGFza3MucmVtb3ZlKHRlc3RGbik7CiAgICAgICAgfSwKICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIC8vIEF2b2lkIHRyeWluZyB0byBzdGFydCB0b28gbWFueSBwcm9jZXNzaW5nIG9wZXJhdGlvbnMuIFRoaXMgY2FuIG9jY3VyCiAgICAgICAgICAgIC8vIHdoZW4gY2FsbGJhY2tzIHJlc29sdmUgc3luY2hyb25vdXNseSAoIzEyNjcpLgogICAgICAgICAgICBpZiAoaXNQcm9jZXNzaW5nKSB7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaXNQcm9jZXNzaW5nID0gdHJ1ZTsKICAgICAgICAgICAgd2hpbGUoIXEucGF1c2VkICYmIG51bVJ1bm5pbmcgPCBxLmNvbmN1cnJlbmN5ICYmIHEuX3Rhc2tzLmxlbmd0aCl7CiAgICAgICAgICAgICAgICB2YXIgdGFza3MgPSBbXSwgZGF0YSA9IFtdOwogICAgICAgICAgICAgICAgdmFyIGwgPSBxLl90YXNrcy5sZW5ndGg7CiAgICAgICAgICAgICAgICBpZiAocS5wYXlsb2FkKSBsID0gTWF0aC5taW4obCwgcS5wYXlsb2FkKTsKICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBxLl90YXNrcy5zaGlmdCgpOwogICAgICAgICAgICAgICAgICAgIHRhc2tzLnB1c2gobm9kZSk7CiAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3QucHVzaChub2RlKTsKICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2gobm9kZS5kYXRhKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBudW1SdW5uaW5nICs9IDE7CgogICAgICAgICAgICAgICAgaWYgKHEuX3Rhc2tzLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgICAgIHEuZW1wdHkoKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBpZiAobnVtUnVubmluZyA9PT0gcS5jb25jdXJyZW5jeSkgewogICAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgdmFyIGNiID0gb25seU9uY2UoX25leHQodGFza3MpKTsKICAgICAgICAgICAgICAgIF93b3JrZXIoZGF0YSwgY2IpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IGZhbHNlOwogICAgICAgIH0sCiAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHJldHVybiBxLl90YXNrcy5sZW5ndGg7CiAgICAgICAgfSwKICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHJldHVybiBudW1SdW5uaW5nOwogICAgICAgIH0sCiAgICAgICAgd29ya2Vyc0xpc3Q6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnNMaXN0OwogICAgICAgIH0sCiAgICAgICAgaWRsZTogZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHJldHVybiBxLl90YXNrcy5sZW5ndGggKyBudW1SdW5uaW5nID09PSAwOwogICAgICAgIH0sCiAgICAgICAgcGF1c2U6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgcS5wYXVzZWQgPSB0cnVlOwogICAgICAgIH0sCiAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIGlmIChxLnBhdXNlZCA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9CiAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7CiAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKHEucHJvY2Vzcyk7CiAgICAgICAgfQogICAgfTsKICAgIHJldHVybiBxOwp9CgovKioKICogQSBjYXJnbyBvZiB0YXNrcyBmb3IgdGhlIHdvcmtlciBmdW5jdGlvbiB0byBjb21wbGV0ZS4gQ2FyZ28gaW5oZXJpdHMgYWxsIG9mCiAqIHRoZSBzYW1lIG1ldGhvZHMgYW5kIGV2ZW50IGNhbGxiYWNrcyBhcyBbYHF1ZXVlYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfS4KICogQHR5cGVkZWYge09iamVjdH0gQ2FyZ29PYmplY3QKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBsZW5ndGggLSBBIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIGl0ZW1zCiAqIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkLiBJbnZva2UgbGlrZSBgY2FyZ28ubGVuZ3RoKClgLgogKiBAcHJvcGVydHkge251bWJlcn0gcGF5bG9hZCAtIEFuIGBpbnRlZ2VyYCBmb3IgZGV0ZXJtaW5pbmcgaG93IG1hbnkgdGFza3MKICogc2hvdWxkIGJlIHByb2Nlc3MgcGVyIHJvdW5kLiBUaGlzIHByb3BlcnR5IGNhbiBiZSBjaGFuZ2VkIGFmdGVyIGEgYGNhcmdvYCBpcwogKiBjcmVhdGVkIHRvIGFsdGVyIHRoZSBwYXlsb2FkIG9uLXRoZS1mbHkuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHB1c2ggLSBBZGRzIGB0YXNrYCB0byB0aGUgYHF1ZXVlYC4gVGhlIGNhbGxiYWNrIGlzCiAqIGNhbGxlZCBvbmNlIHRoZSBgd29ya2VyYCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZyB0aGUgdGFzay4gSW5zdGVhZCBvZiBhCiAqIHNpbmdsZSB0YXNrLCBhbiBhcnJheSBvZiBgdGFza3NgIGNhbiBiZSBzdWJtaXR0ZWQuIFRoZSByZXNwZWN0aXZlIGNhbGxiYWNrIGlzCiAqIHVzZWQgZm9yIGV2ZXJ5IHRhc2sgaW4gdGhlIGxpc3QuIEludm9rZSBsaWtlIGBjYXJnby5wdXNoKHRhc2ssIFtjYWxsYmFja10pYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc2F0dXJhdGVkIC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZQogKiBgcXVldWUubGVuZ3RoKClgIGhpdHMgdGhlIGNvbmN1cnJlbmN5IGFuZCBmdXJ0aGVyIHRhc2tzIHdpbGwgYmUgcXVldWVkLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlbXB0eSAtIEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtCiAqIGZyb20gdGhlIGBxdWV1ZWAgaXMgZ2l2ZW4gdG8gYSBgd29ya2VyYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZHJhaW4gLSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGxhc3QgaXRlbQogKiBmcm9tIHRoZSBgcXVldWVgIGhhcyByZXR1cm5lZCBmcm9tIHRoZSBgd29ya2VyYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaWRsZSAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlIGlmIHRoZXJlIGFyZSBpdGVtcwogKiB3YWl0aW5nIG9yIGJlaW5nIHByb2Nlc3NlZCwgb3IgdHJ1ZSBpZiBub3QuIEludm9rZSBsaWtlIGBjYXJnby5pZGxlKClgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwYXVzZSAtIGEgZnVuY3Rpb24gdGhhdCBwYXVzZXMgdGhlIHByb2Nlc3Npbmcgb2YgdGFza3MKICogdW50aWwgYHJlc3VtZSgpYCBpcyBjYWxsZWQuIEludm9rZSBsaWtlIGBjYXJnby5wYXVzZSgpYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcmVzdW1lIC0gYSBmdW5jdGlvbiB0aGF0IHJlc3VtZXMgdGhlIHByb2Nlc3Npbmcgb2YKICogcXVldWVkIHRhc2tzIHdoZW4gdGhlIHF1ZXVlIGlzIHBhdXNlZC4gSW52b2tlIGxpa2UgYGNhcmdvLnJlc3VtZSgpYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0ga2lsbCAtIGEgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBgZHJhaW5gIGNhbGxiYWNrIGFuZAogKiBlbXB0aWVzIHJlbWFpbmluZyB0YXNrcyBmcm9tIHRoZSBxdWV1ZSBmb3JjaW5nIGl0IHRvIGdvIGlkbGUuIEludm9rZSBsaWtlIGBjYXJnby5raWxsKClgLgogKi8KCi8qKgogKiBDcmVhdGVzIGEgYGNhcmdvYCBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIHBheWxvYWQuIFRhc2tzIGFkZGVkIHRvIHRoZQogKiBjYXJnbyB3aWxsIGJlIHByb2Nlc3NlZCBhbHRvZ2V0aGVyICh1cCB0byB0aGUgYHBheWxvYWRgIGxpbWl0KS4gSWYgdGhlCiAqIGB3b3JrZXJgIGlzIGluIHByb2dyZXNzLCB0aGUgdGFzayBpcyBxdWV1ZWQgdW50aWwgaXQgYmVjb21lcyBhdmFpbGFibGUuIE9uY2UKICogdGhlIGB3b3JrZXJgIGhhcyBjb21wbGV0ZWQgc29tZSB0YXNrcywgZWFjaCBjYWxsYmFjayBvZiB0aG9zZSB0YXNrcyBpcwogKiBjYWxsZWQuIENoZWNrIG91dCBbdGhlc2VdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vNmJiZDM2ZjRjZjViMzVhMGYxMWE5NmRjZDJlOTc3MTFmZmMyZmIzNy82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDM4MmY2MjYyNjMzMDYzNjY2MjMwMmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM5MzczNDY2MmQzMzMzMzkzNzYzMzYzNDY0NjMzODM1MzgyZTY3Njk2NikgW2FuaW1hdGlvbnNdKGh0dHBzOi8vY2Ftby5naXRodWJ1c2VyY29udGVudC5jb20vZjQ4MTBlMDBlMWM1ZjVmOGFkZGJlM2U5ZjQ5MDY0ZmQ1ZDEwMjY5OS82ODc0NzQ3MDczM2EyZjJmNjYyZTYzNmM2Zjc1NjQyZTY3Njk3NDY4NzU2MjJlNjM2ZjZkMmY2MTczNzM2NTc0NzMyZjMxMzYzNzM2MzgzNzMxMmYzNjM4MzEzMDMxMmYzODM0NjMzOTMyMzAzNjM2MmQzNTY2MzIzOTJkMzEzMTY1MzIyZDM4MzEzNDY2MmQzOTY0MzM2NDMwMzIzNDMxMzM2MjY2NjQyZTY3Njk2NikKICogZm9yIGhvdyBgY2FyZ29gIGFuZCBgcXVldWVgIHdvcmsuCiAqCiAqIFdoaWxlIFtgcXVldWVgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IHBhc3NlcyBvbmx5IG9uZSB0YXNrIHRvIG9uZSBvZiBhIGdyb3VwIG9mIHdvcmtlcnMKICogYXQgYSB0aW1lLCBjYXJnbyBwYXNzZXMgYW4gYXJyYXkgb2YgdGFza3MgdG8gYSBzaW5nbGUgd29ya2VyLCByZXBlYXRpbmcKICogd2hlbiB0aGUgd29ya2VyIGlzIGZpbmlzaGVkLgogKgogKiBAbmFtZSBjYXJnbwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gd29ya2VyIC0gQW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIGFuIGFycmF5CiAqIG9mIHF1ZXVlZCB0YXNrcy4gSW52b2tlZCB3aXRoIGAodGFza3MsIGNhbGxiYWNrKWAuCiAqIEBwYXJhbSB7bnVtYmVyfSBbcGF5bG9hZD1JbmZpbml0eV0gLSBBbiBvcHRpb25hbCBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nCiAqIGhvdyBtYW55IHRhc2tzIHNob3VsZCBiZSBwcm9jZXNzZWQgcGVyIHJvdW5kOyBpZiBvbWl0dGVkLCB0aGUgZGVmYXVsdCBpcwogKiB1bmxpbWl0ZWQuCiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuQ2FyZ29PYmplY3R9IEEgY2FyZ28gb2JqZWN0IHRvIG1hbmFnZSB0aGUgdGFza3MuIENhbGxiYWNrcyBjYW4KICogYXR0YWNoZWQgYXMgY2VydGFpbiBwcm9wZXJ0aWVzIHRvIGxpc3RlbiBmb3Igc3BlY2lmaWMgZXZlbnRzIGR1cmluZyB0aGUKICogbGlmZWN5Y2xlIG9mIHRoZSBjYXJnbyBhbmQgaW5uZXIgcXVldWUuCiAqIEBleGFtcGxlCiAqCiAqIC8vIGNyZWF0ZSBhIGNhcmdvIG9iamVjdCB3aXRoIHBheWxvYWQgMgogKiB2YXIgY2FyZ28gPSBhc3luYy5jYXJnbyhmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHsKICogICAgIGZvciAodmFyIGk9MDsgaTx0YXNrcy5sZW5ndGg7IGkrKykgewogKiAgICAgICAgIGNvbnNvbGUubG9nKCdoZWxsbyAnICsgdGFza3NbaV0ubmFtZSk7CiAqICAgICB9CiAqICAgICBjYWxsYmFjaygpOwogKiB9LCAyKTsKICoKICogLy8gYWRkIHNvbWUgaXRlbXMKICogY2FyZ28ucHVzaCh7bmFtZTogJ2Zvbyd9LCBmdW5jdGlvbihlcnIpIHsKICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpOwogKiB9KTsKICogY2FyZ28ucHVzaCh7bmFtZTogJ2Jhcid9LCBmdW5jdGlvbihlcnIpIHsKICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpOwogKiB9KTsKICogY2FyZ28ucHVzaCh7bmFtZTogJ2Jheid9LCBmdW5jdGlvbihlcnIpIHsKICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJheicpOwogKiB9KTsKICovCmZ1bmN0aW9uIGNhcmdvKHdvcmtlciwgcGF5bG9hZCkgewogICAgcmV0dXJuIHF1ZXVlKHdvcmtlciwgMSwgcGF5bG9hZCk7Cn0KCi8qKgogKiBUaGUgc2FtZSBhcyBbYGVhY2hPZmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgZWFjaE9mU2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmVhY2hPZl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn0KICogQGFsaWFzIGZvckVhY2hPZlNlcmllcwogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGtleSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuCiAqLwp2YXIgZWFjaE9mU2VyaWVzID0gZG9MaW1pdChlYWNoT2ZMaW1pdCwgMSk7CgovKioKICogUmVkdWNlcyBgY29sbGAgaW50byBhIHNpbmdsZSB2YWx1ZSB1c2luZyBhbiBhc3luYyBgaXRlcmF0ZWVgIHRvIHJldHVybiBlYWNoCiAqIHN1Y2Nlc3NpdmUgc3RlcC4gYG1lbW9gIGlzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uIFRoaXMgZnVuY3Rpb24KICogb25seSBvcGVyYXRlcyBpbiBzZXJpZXMuCiAqCiAqIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBpdCBtYXkgbWFrZSBzZW5zZSB0byBzcGxpdCBhIGNhbGwgdG8gdGhpcyBmdW5jdGlvbgogKiBpbnRvIGEgcGFyYWxsZWwgbWFwLCBhbmQgdGhlbiB1c2UgdGhlIG5vcm1hbCBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgb24gdGhlCiAqIHJlc3VsdHMuIFRoaXMgZnVuY3Rpb24gaXMgZm9yIHNpdHVhdGlvbnMgd2hlcmUgZWFjaCBzdGVwIGluIHRoZSByZWR1Y3Rpb24KICogbmVlZHMgdG8gYmUgYXN5bmM7IGlmIHlvdSBjYW4gZ2V0IHRoZSBkYXRhIGJlZm9yZSByZWR1Y2luZyBpdCwgdGhlbiBpdCdzCiAqIHByb2JhYmx5IGEgZ29vZCBpZGVhIHRvIGRvIHNvLgogKgogKiBAbmFtZSByZWR1Y2UKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGFsaWFzIGluamVjdAogKiBAYWxpYXMgZm9sZGwKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0geyp9IG1lbW8gLSBUaGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiBhcHBsaWVkIHRvIGVhY2ggaXRlbSBpbiB0aGUKICogYXJyYXkgdG8gcHJvZHVjZSB0aGUgbmV4dCBzdGVwIGluIHRoZSByZWR1Y3Rpb24uCiAqIFRoZSBgaXRlcmF0ZWVgIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSBuZXh0IHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uCiAqIElmIHRoZSBpdGVyYXRlZSBjb21wbGV0ZSB3aXRoIGFuIGVycm9yLCB0aGUgcmVkdWN0aW9uIGlzIHN0b3BwZWQgYW5kIHRoZQogKiBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLgogKiBJbnZva2VkIHdpdGggKG1lbW8sIGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IGlzIHRoZSByZWR1Y2VkIHZhbHVlLiBJbnZva2VkIHdpdGgKICogKGVyciwgcmVzdWx0KS4KICogQGV4YW1wbGUKICoKICogYXN5bmMucmVkdWNlKFsxLDIsM10sIDAsIGZ1bmN0aW9uKG1lbW8sIGl0ZW0sIGNhbGxiYWNrKSB7CiAqICAgICAvLyBwb2ludGxlc3MgYXN5bmM6CiAqICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1lbW8gKyBpdGVtKQogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgaXMgbm93IGVxdWFsIHRvIHRoZSBsYXN0IHZhbHVlIG9mIG1lbW8sIHdoaWNoIGlzIDYKICogfSk7CiAqLwpmdW5jdGlvbiByZWR1Y2UoY29sbCwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7CiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTsKICAgIGVhY2hPZlNlcmllcyhjb2xsLCBmdW5jdGlvbih4LCBpLCBjYWxsYmFjaykgewogICAgICAgIF9pdGVyYXRlZShtZW1vLCB4LCBmdW5jdGlvbihlcnIsIHYpIHsKICAgICAgICAgICAgbWVtbyA9IHY7CiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7CiAgICAgICAgfSk7CiAgICB9LCBmdW5jdGlvbihlcnIpIHsKICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pOwogICAgfSk7Cn0KCi8qKgogKiBWZXJzaW9uIG9mIHRoZSBjb21wb3NlIGZ1bmN0aW9uIHRoYXQgaXMgbW9yZSBuYXR1cmFsIHRvIHJlYWQuIEVhY2ggZnVuY3Rpb24KICogY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgZnVuY3Rpb24uIEl0IGlzIHRoZSBlcXVpdmFsZW50IG9mCiAqIFtjb21wb3NlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuY29tcG9zZX0gd2l0aCB0aGUgYXJndW1lbnRzIHJldmVyc2VkLgogKgogKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi4KICoKICogQG5hbWUgc2VxCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmNvbXBvc2Vde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jb21wb3NlfQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7Li4uQXN5bmNGdW5jdGlvbn0gZnVuY3Rpb25zIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgdG8gY29tcG9zZQogKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBjb21wb3NlcyB0aGUgYGZ1bmN0aW9uc2AgaW4gb3JkZXIKICogQGV4YW1wbGUKICoKICogLy8gUmVxdWlyZXMgbG9kYXNoIChvciB1bmRlcnNjb3JlKSwgZXhwcmVzczMgYW5kIGRyZXNlbmRlJ3Mgb3JtMi4KICogLy8gUGFydCBvZiBhbiBhcHAsIHRoYXQgZmV0Y2hlcyBjYXRzIG9mIHRoZSBsb2dnZWQgdXNlci4KICogLy8gVGhpcyBleGFtcGxlIHVzZXMgYHNlcWAgZnVuY3Rpb24gdG8gYXZvaWQgb3Zlcm5lc3RpbmcgYW5kIGVycm9yCiAqIC8vIGhhbmRsaW5nIGNsdXR0ZXIuCiAqIGFwcC5nZXQoJy9jYXRzJywgZnVuY3Rpb24ocmVxdWVzdCwgcmVzcG9uc2UpIHsKICogICAgIHZhciBVc2VyID0gcmVxdWVzdC5tb2RlbHMuVXNlcjsKICogICAgIGFzeW5jLnNlcSgKICogICAgICAgICBfLmJpbmQoVXNlci5nZXQsIFVzZXIpLCAgLy8gJ1VzZXIuZ2V0JyBoYXMgc2lnbmF0dXJlIChpZCwgY2FsbGJhY2soZXJyLCBkYXRhKSkKICogICAgICAgICBmdW5jdGlvbih1c2VyLCBmbikgewogKiAgICAgICAgICAgICB1c2VyLmdldENhdHMoZm4pOyAgICAgIC8vICdnZXRDYXRzJyBoYXMgc2lnbmF0dXJlIChjYWxsYmFjayhlcnIsIGRhdGEpKQogKiAgICAgICAgIH0KICogICAgICkocmVxLnNlc3Npb24udXNlcl9pZCwgZnVuY3Rpb24gKGVyciwgY2F0cykgewogKiAgICAgICAgIGlmIChlcnIpIHsKICogICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpOwogKiAgICAgICAgICAgICByZXNwb25zZS5qc29uKHsgc3RhdHVzOiAnZXJyb3InLCBtZXNzYWdlOiBlcnIubWVzc2FnZSB9KTsKICogICAgICAgICB9IGVsc2UgewogKiAgICAgICAgICAgICByZXNwb25zZS5qc29uKHsgc3RhdHVzOiAnb2snLCBtZXNzYWdlOiAnQ2F0cyBmb3VuZCcsIGRhdGE6IGNhdHMgfSk7CiAqICAgICAgICAgfQogKiAgICAgfSk7CiAqIH0pOwogKi8KZnVuY3Rpb24gc2VxKC8qLi4uZnVuY3Rpb25zKi8pIHsKICAgIHZhciBfZnVuY3Rpb25zID0gYXJyYXlNYXAoYXJndW1lbnRzLCB3cmFwQXN5bmMpOwogICAgcmV0dXJuIGZ1bmN0aW9uKC8qLi4uYXJncyovKSB7CiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMpOwogICAgICAgIHZhciB0aGF0ID0gdGhpczsKCiAgICAgICAgdmFyIGNiID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdOwogICAgICAgIGlmICh0eXBlb2YgY2IgPT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICBhcmdzLnBvcCgpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNiID0gbm9vcDsKICAgICAgICB9CgogICAgICAgIHJlZHVjZShfZnVuY3Rpb25zLCBhcmdzLCBmdW5jdGlvbihuZXdhcmdzLCBmbiwgY2IpIHsKICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgbmV3YXJncy5jb25jYXQoZnVuY3Rpb24oZXJyLyosIC4uLm5leHRhcmdzKi8pIHsKICAgICAgICAgICAgICAgIHZhciBuZXh0YXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgICAgICAgICBjYihlcnIsIG5leHRhcmdzKTsKICAgICAgICAgICAgfSkpOwogICAgICAgIH0sCiAgICAgICAgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAgICAgICAgICAgIGNiLmFwcGx5KHRoYXQsIFtlcnJdLmNvbmNhdChyZXN1bHRzKSk7CiAgICAgICAgfSk7CiAgICB9Owp9CgovKioKICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHdoaWNoIGlzIGEgY29tcG9zaXRpb24gb2YgdGhlIHBhc3NlZCBhc3luY2hyb25vdXMKICogZnVuY3Rpb25zLiBFYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQKICogZm9sbG93cy4gQ29tcG9zaW5nIGZ1bmN0aW9ucyBgZigpYCwgYGcoKWAsIGFuZCBgaCgpYCB3b3VsZCBwcm9kdWNlIHRoZSByZXN1bHQKICogb2YgYGYoZyhoKCkpKWAsIG9ubHkgdGhpcyB2ZXJzaW9uIHVzZXMgY2FsbGJhY2tzIHRvIG9idGFpbiB0aGUgcmV0dXJuIHZhbHVlcy4KICoKICogRWFjaCBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY29tcG9zZWQgZnVuY3Rpb24uCiAqCiAqIEBuYW1lIGNvbXBvc2UKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0gey4uLkFzeW5jRnVuY3Rpb259IGZ1bmN0aW9ucyAtIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb25zIHRvIGNvbXBvc2UKICogQHJldHVybnMge0Z1bmN0aW9ufSBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zZWQKICogYXN5bmNocm9ub3VzIGBmdW5jdGlvbnNgCiAqIEBleGFtcGxlCiAqCiAqIGZ1bmN0aW9uIGFkZDEobiwgY2FsbGJhY2spIHsKICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIG4gKyAxKTsKICogICAgIH0sIDEwKTsKICogfQogKgogKiBmdW5jdGlvbiBtdWwzKG4sIGNhbGxiYWNrKSB7CiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCBuICogMyk7CiAqICAgICB9LCAxMCk7CiAqIH0KICoKICogdmFyIGFkZDFtdWwzID0gYXN5bmMuY29tcG9zZShtdWwzLCBhZGQxKTsKICogYWRkMW11bDMoNCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAxNQogKiB9KTsKICovCnZhciBjb21wb3NlID0gZnVuY3Rpb24oLyouLi5hcmdzKi8pIHsKICAgIHJldHVybiBzZXEuYXBwbHkobnVsbCwgc2xpY2UoYXJndW1lbnRzKS5yZXZlcnNlKCkpOwp9OwoKdmFyIF9jb25jYXQgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0OwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgY29uY2F0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmNvbmNhdH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGNvbmNhdExpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmNvbmNhdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmNvbmNhdH0KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAsCiAqIHdoaWNoIHNob3VsZCB1c2UgYW4gYXJyYXkgYXMgaXRzIHJlc3VsdC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheQogKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdHMpLgogKi8KdmFyIGNvbmNhdExpbWl0ID0gZnVuY3Rpb24oY29sbCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wOwogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CiAgICBtYXBMaW1pdChjb2xsLCBsaW1pdCwgZnVuY3Rpb24odmFsLCBjYWxsYmFjaykgewogICAgICAgIF9pdGVyYXRlZSh2YWwsIGZ1bmN0aW9uKGVyciAvKiwgLi4uYXJncyovKSB7CiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgc2xpY2UoYXJndW1lbnRzLCAxKSk7CiAgICAgICAgfSk7CiAgICB9LCBmdW5jdGlvbihlcnIsIG1hcFJlc3VsdHMpIHsKICAgICAgICB2YXIgcmVzdWx0ID0gW107CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBSZXN1bHRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmIChtYXBSZXN1bHRzW2ldKSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29uY2F0LmFwcGx5KHJlc3VsdCwgbWFwUmVzdWx0c1tpXSk7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIHJlc3VsdCk7CiAgICB9KTsKfTsKCi8qKgogKiBBcHBsaWVzIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCwgY29uY2F0ZW5hdGluZyB0aGUgcmVzdWx0cy4gUmV0dXJucwogKiB0aGUgY29uY2F0ZW5hdGVkIGxpc3QuIFRoZSBgaXRlcmF0ZWVgcyBhcmUgY2FsbGVkIGluIHBhcmFsbGVsLCBhbmQgdGhlCiAqIHJlc3VsdHMgYXJlIGNvbmNhdGVuYXRlZCBhcyB0aGV5IHJldHVybi4gVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlCiAqIHJlc3VsdHMgYXJyYXkgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgb3JpZ2luYWwgb3JkZXIgb2YgYGNvbGxgIHBhc3NlZCB0byB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbi4KICoKICogQG5hbWUgY29uY2F0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCwKICogd2hpY2ggc2hvdWxkIHVzZSBhbiBhcnJheSBhcyBpdHMgcmVzdWx0LiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrKGVycildIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXkKICogY29udGFpbmluZyB0aGUgY29uY2F0ZW5hdGVkIHJlc3VsdHMgb2YgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIEludm9rZWQgd2l0aAogKiAoZXJyLCByZXN1bHRzKS4KICogQGV4YW1wbGUKICoKICogYXN5bmMuY29uY2F0KFsnZGlyMScsJ2RpcjInLCdkaXIzJ10sIGZzLnJlYWRkaXIsIGZ1bmN0aW9uKGVyciwgZmlsZXMpIHsKICogICAgIC8vIGZpbGVzIGlzIG5vdyBhIGxpc3Qgb2YgZmlsZW5hbWVzIHRoYXQgZXhpc3QgaW4gdGhlIDMgZGlyZWN0b3JpZXMKICogfSk7CiAqLwp2YXIgY29uY2F0ID0gZG9MaW1pdChjb25jYXRMaW1pdCwgSW5maW5pdHkpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgY29uY2F0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmNvbmNhdH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBjb25jYXRTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuY29uY2F0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhbiBhcnJheSBhbiBhcnJheSBvZiByZXN1bHRzLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrKGVycildIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgYW4gYXJyYXkKICogY29udGFpbmluZyB0aGUgY29uY2F0ZW5hdGVkIHJlc3VsdHMgb2YgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIEludm9rZWQgd2l0aAogKiAoZXJyLCByZXN1bHRzKS4KICovCnZhciBjb25jYXRTZXJpZXMgPSBkb0xpbWl0KGNvbmNhdExpbWl0LCAxKTsKCi8qKgogKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aGVuIGNhbGxlZCwgY2FsbHMtYmFjayB3aXRoIHRoZSB2YWx1ZXMgcHJvdmlkZWQuCiAqIFVzZWZ1bCBhcyB0aGUgZmlyc3QgZnVuY3Rpb24gaW4gYSBbYHdhdGVyZmFsbGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53YXRlcmZhbGx9LCBvciBmb3IgcGx1Z2dpbmcgdmFsdWVzIGluIHRvCiAqIFtgYXV0b2Bde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hdXRvfS4KICoKICogQG5hbWUgY29uc3RhbnQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IFV0aWwKICogQHBhcmFtIHsuLi4qfSBhcmd1bWVudHMuLi4gLSBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhdXRvbWF0aWNhbGx5IGludm9rZQogKiBjYWxsYmFjayB3aXRoLgogKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2hlbiBpbnZva2VkLCBhdXRvbWF0aWNhbGx5CiAqIGludm9rZXMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHByZXZpb3VzIGdpdmVuIGFyZ3VtZW50cy4KICogQGV4YW1wbGUKICoKICogYXN5bmMud2F0ZXJmYWxsKFsKICogICAgIGFzeW5jLmNvbnN0YW50KDQyKSwKICogICAgIGZ1bmN0aW9uICh2YWx1ZSwgbmV4dCkgewogKiAgICAgICAgIC8vIHZhbHVlID09PSA0MgogKiAgICAgfSwKICogICAgIC8vLi4uCiAqIF0sIGNhbGxiYWNrKTsKICoKICogYXN5bmMud2F0ZXJmYWxsKFsKICogICAgIGFzeW5jLmNvbnN0YW50KGZpbGVuYW1lLCAidXRmOCIpLAogKiAgICAgZnMucmVhZEZpbGUsCiAqICAgICBmdW5jdGlvbiAoZmlsZURhdGEsIG5leHQpIHsKICogICAgICAgICAvLy4uLgogKiAgICAgfQogKiAgICAgLy8uLi4KICogXSwgY2FsbGJhY2spOwogKgogKiBhc3luYy5hdXRvKHsKICogICAgIGhvc3RuYW1lOiBhc3luYy5jb25zdGFudCgiaHR0cHM6Ly9zZXJ2ZXIubmV0LyIpLAogKiAgICAgcG9ydDogZmluZEZyZWVQb3J0LAogKiAgICAgbGF1bmNoU2VydmVyOiBbImhvc3RuYW1lIiwgInBvcnQiLCBmdW5jdGlvbiAob3B0aW9ucywgY2IpIHsKICogICAgICAgICBzdGFydFNlcnZlcihvcHRpb25zLCBjYik7CiAqICAgICB9XSwKICogICAgIC8vLi4uCiAqIH0sIGNhbGxiYWNrKTsKICovCnZhciBjb25zdGFudCA9IGZ1bmN0aW9uKC8qLi4udmFsdWVzKi8pIHsKICAgIHZhciB2YWx1ZXMgPSBzbGljZShhcmd1bWVudHMpOwogICAgdmFyIGFyZ3MgPSBbbnVsbF0uY29uY2F0KHZhbHVlcyk7CiAgICByZXR1cm4gZnVuY3Rpb24gKC8qLi4uaWdub3JlZEFyZ3MsIGNhbGxiYWNrKi8pIHsKICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdOwogICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTsKICAgIH07Cn07CgovKioKICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuCiAqCiAqIEBzdGF0aWMKICogQHNpbmNlIDAuMS4wCiAqIEBtZW1iZXJPZiBfCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLgogKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLgogKiBAZXhhbXBsZQogKgogKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTsKICoKICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpOwogKiAvLyA9PiB0cnVlCiAqLwpmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkgewogIHJldHVybiB2YWx1ZTsKfQoKZnVuY3Rpb24gX2NyZWF0ZVRlc3RlcihjaGVjaywgZ2V0UmVzdWx0KSB7CiAgICByZXR1cm4gZnVuY3Rpb24oZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYikgewogICAgICAgIGNiID0gY2IgfHwgbm9vcDsKICAgICAgICB2YXIgdGVzdFBhc3NlZCA9IGZhbHNlOwogICAgICAgIHZhciB0ZXN0UmVzdWx0OwogICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uKHZhbHVlLCBfLCBjYWxsYmFjaykgewogICAgICAgICAgICBpdGVyYXRlZSh2YWx1ZSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICAgICAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGVjayhyZXN1bHQpICYmICF0ZXN0UmVzdWx0KSB7CiAgICAgICAgICAgICAgICAgICAgdGVzdFBhc3NlZCA9IHRydWU7CiAgICAgICAgICAgICAgICAgICAgdGVzdFJlc3VsdCA9IGdldFJlc3VsdCh0cnVlLCB2YWx1ZSk7CiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYnJlYWtMb29wKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgIGNiKGVycik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjYihudWxsLCB0ZXN0UGFzc2VkID8gdGVzdFJlc3VsdCA6IGdldFJlc3VsdChmYWxzZSkpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICB9Owp9CgpmdW5jdGlvbiBfZmluZEdldFJlc3VsdCh2LCB4KSB7CiAgICByZXR1cm4geDsKfQoKLyoqCiAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIGBjb2xsYCB0aGF0IHBhc3NlcyBhbiBhc3luYyB0cnV0aCB0ZXN0LiBUaGUKICogYGl0ZXJhdGVlYCBpcyBhcHBsaWVkIGluIHBhcmFsbGVsLCBtZWFuaW5nIHRoZSBmaXJzdCBpdGVyYXRlZSB0byByZXR1cm4KICogYHRydWVgIHdpbGwgZmlyZSB0aGUgZGV0ZWN0IGBjYWxsYmFja2Agd2l0aCB0aGF0IHJlc3VsdC4gVGhhdCBtZWFucyB0aGUKICogcmVzdWx0IG1pZ2h0IG5vdCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgb3JpZ2luYWwgYGNvbGxgIChpbiB0ZXJtcyBvZiBvcmRlcikKICogdGhhdCBwYXNzZXMgdGhlIHRlc3QuCgogKiBJZiBvcmRlciB3aXRoaW4gdGhlIG9yaWdpbmFsIGBjb2xsYCBpcyBpbXBvcnRhbnQsIHRoZW4gbG9vayBhdAogKiBbYGRldGVjdFNlcmllc2Bde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3RTZXJpZXN9LgogKgogKiBAbmFtZSBkZXRlY3QKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGFsaWFzIGZpbmQKICogQGNhdGVnb3J5IENvbGxlY3Rpb25zCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgcmVzdWx0LgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55CiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuCiAqIFJlc3VsdCB3aWxsIGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheSB0aGF0IHBhc3NlcyB0aGUgdHJ1dGggdGVzdAogKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdCkuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmRldGVjdChbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHsKICogICAgIGZzLmFjY2VzcyhmaWxlUGF0aCwgZnVuY3Rpb24oZXJyKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycikKICogICAgIH0pOwogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gcmVzdWx0IG5vdyBlcXVhbHMgdGhlIGZpcnN0IGZpbGUgaW4gdGhlIGxpc3QgdGhhdCBleGlzdHMKICogfSk7CiAqLwp2YXIgZGV0ZWN0ID0gZG9QYXJhbGxlbChfY3JlYXRlVGVzdGVyKGlkZW50aXR5LCBfZmluZEdldFJlc3VsdCkpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZGV0ZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhCiAqIHRpbWUuCiAqCiAqIEBuYW1lIGRldGVjdExpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH0KICogQGFsaWFzIGZpbmRMaW1pdAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnMKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIHJlc3VsdC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueQogKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLgogKiBSZXN1bHQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgdGhlIHRydXRoIHRlc3QKICogKGl0ZXJhdGVlKSBvciB0aGUgdmFsdWUgYHVuZGVmaW5lZGAgaWYgbm9uZSBwYXNzZWQuIEludm9rZWQgd2l0aAogKiAoZXJyLCByZXN1bHQpLgogKi8KdmFyIGRldGVjdExpbWl0ID0gZG9QYXJhbGxlbExpbWl0KF9jcmVhdGVUZXN0ZXIoaWRlbnRpdHksIF9maW5kR2V0UmVzdWx0KSk7CgovKioKICogVGhlIHNhbWUgYXMgW2BkZXRlY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGRldGVjdFNlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5kZXRlY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9CiAqIEBhbGlhcyBmaW5kU2VyaWVzCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9ucwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIHJlc3VsdC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueQogKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLgogKiBSZXN1bHQgd2lsbCBiZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkgdGhhdCBwYXNzZXMgdGhlIHRydXRoIHRlc3QKICogKGl0ZXJhdGVlKSBvciB0aGUgdmFsdWUgYHVuZGVmaW5lZGAgaWYgbm9uZSBwYXNzZWQuIEludm9rZWQgd2l0aAogKiAoZXJyLCByZXN1bHQpLgogKi8KdmFyIGRldGVjdFNlcmllcyA9IGRvTGltaXQoZGV0ZWN0TGltaXQsIDEpOwoKZnVuY3Rpb24gY29uc29sZUZ1bmMobmFtZSkgewogICAgcmV0dXJuIGZ1bmN0aW9uIChmbi8qLCAuLi5hcmdzKi8pIHsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIvKiwgLi4uYXJncyovKSB7CiAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JykgewogICAgICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbmFtZV0pIHsKICAgICAgICAgICAgICAgICAgICBhcnJheUVhY2goYXJncywgZnVuY3Rpb24gKHgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZVtuYW1lXSh4KTsKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIHdyYXBBc3luYyhmbikuYXBwbHkobnVsbCwgYXJncyk7CiAgICB9Owp9CgovKioKICogTG9ncyB0aGUgcmVzdWx0IG9mIGFuIFtgYXN5bmNgIGZ1bmN0aW9uXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byB0aGUKICogYGNvbnNvbGVgIHVzaW5nIGBjb25zb2xlLmRpcmAgdG8gZGlzcGxheSB0aGUgcHJvcGVydGllcyBvZiB0aGUgcmVzdWx0aW5nIG9iamVjdC4KICogT25seSB3b3JrcyBpbiBOb2RlLmpzIG9yIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBgY29uc29sZS5kaXJgIGFuZAogKiBgY29uc29sZS5lcnJvcmAgKHN1Y2ggYXMgRkYgYW5kIENocm9tZSkuCiAqIElmIG11bHRpcGxlIGFyZ3VtZW50cyBhcmUgcmV0dXJuZWQgZnJvbSB0aGUgYXN5bmMgZnVuY3Rpb24sCiAqIGBjb25zb2xlLmRpcmAgaXMgY2FsbGVkIG9uIGVhY2ggYXJndW1lbnQgaW4gb3JkZXIuCiAqCiAqIEBuYW1lIGRpcgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZ1bmN0aW9uIC0gVGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGV2ZW50dWFsbHkgYXBwbHkKICogYWxsIGFyZ3VtZW50cyB0by4KICogQHBhcmFtIHsuLi4qfSBhcmd1bWVudHMuLi4gLSBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgZnVuY3Rpb24uCiAqIEBleGFtcGxlCiAqCiAqIC8vIGluIGEgbW9kdWxlCiAqIHZhciBoZWxsbyA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7CiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHtoZWxsbzogbmFtZX0pOwogKiAgICAgfSwgMTAwMCk7CiAqIH07CiAqCiAqIC8vIGluIHRoZSBub2RlIHJlcGwKICogbm9kZT4gYXN5bmMuZGlyKGhlbGxvLCAnd29ybGQnKTsKICoge2hlbGxvOiAnd29ybGQnfQogKi8KdmFyIGRpciA9IGNvbnNvbGVGdW5jKCdkaXInKTsKCi8qKgogKiBUaGUgcG9zdC1jaGVjayB2ZXJzaW9uIG9mIFtgZHVyaW5nYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmR1cmluZ30uIFRvIHJlZmxlY3QgdGhlIGRpZmZlcmVuY2UgaW4KICogdGhlIG9yZGVyIG9mIG9wZXJhdGlvbnMsIHRoZSBhcmd1bWVudHMgYHRlc3RgIGFuZCBgZm5gIGFyZSBzd2l0Y2hlZC4KICoKICogQWxzbyBhIHZlcnNpb24gb2YgW2Bkb1doaWxzdGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5kb1doaWxzdH0gd2l0aCBhc3luY2hyb25vdXMgYHRlc3RgIGZ1bmN0aW9uLgogKiBAbmFtZSBkb0R1cmluZwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5kdXJpbmdde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5kdXJpbmd9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWUKICogYHRlc3RgIHBhc3Nlcy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGVzdCAtIGFzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYmVmb3JlIGVhY2gKICogZXhlY3V0aW9uIG9mIGBmbmAuIEludm9rZWQgd2l0aCAoLi4uYXJncywgY2FsbGJhY2spLCB3aGVyZSBgLi4uYXJnc2AgYXJlIHRoZQogKiBub24tZXJyb3IgYXJncyBmcm9tIHRoZSBwcmV2aW91cyBjYWxsYmFjayBvZiBgZm5gLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3QKICogZnVuY3Rpb24gaGFzIGZhaWxlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBmbmAgaGFzIHN0b3BwZWQuIGBjYWxsYmFja2AKICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgaWYgb25lIG9jY3VycmVkLCBvdGhlcndpc2UgYG51bGxgLgogKi8KZnVuY3Rpb24gZG9EdXJpbmcoZm4sIHRlc3QsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIF9mbiA9IHdyYXBBc3luYyhmbik7CiAgICB2YXIgX3Rlc3QgPSB3cmFwQXN5bmModGVzdCk7CgogICAgZnVuY3Rpb24gbmV4dChlcnIvKiwgLi4uYXJncyovKSB7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgICAgIGFyZ3MucHVzaChjaGVjayk7CiAgICAgICAgX3Rlc3QuYXBwbHkodGhpcywgYXJncyk7CiAgICB9CgogICAgZnVuY3Rpb24gY2hlY2soZXJyLCB0cnV0aCkgewogICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgIGlmICghdHJ1dGgpIHJldHVybiBjYWxsYmFjayhudWxsKTsKICAgICAgICBfZm4obmV4dCk7CiAgICB9CgogICAgY2hlY2sobnVsbCwgdHJ1ZSk7Cgp9CgovKioKICogVGhlIHBvc3QtY2hlY2sgdmVyc2lvbiBvZiBbYHdoaWxzdGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9LiBUbyByZWZsZWN0IHRoZSBkaWZmZXJlbmNlIGluCiAqIHRoZSBvcmRlciBvZiBvcGVyYXRpb25zLCB0aGUgYXJndW1lbnRzIGB0ZXN0YCBhbmQgYGl0ZXJhdGVlYCBhcmUgc3dpdGNoZWQuCiAqCiAqIGBkb1doaWxzdGAgaXMgdG8gYHdoaWxzdGAgYXMgYGRvIHdoaWxlYCBpcyB0byBgd2hpbGVgIGluIHBsYWluIEphdmFTY3JpcHQuCiAqCiAqIEBuYW1lIGRvV2hpbHN0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLndoaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lIGB0ZXN0YAogKiBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0IC0gc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGFmdGVyIGVhY2gKICogZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAuIEludm9rZWQgd2l0aCBhbnkgbm9uLWVycm9yIGNhbGxiYWNrIHJlc3VsdHMgb2YKICogYGl0ZXJhdGVlYC4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0CiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLgogKiBgY2FsbGJhY2tgIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwKICogYGl0ZXJhdGVlYCdzIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTsKICovCmZ1bmN0aW9uIGRvV2hpbHN0KGl0ZXJhdGVlLCB0ZXN0LCBjYWxsYmFjaykgewogICAgY2FsbGJhY2sgPSBvbmx5T25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwogICAgdmFyIG5leHQgPSBmdW5jdGlvbihlcnIvKiwgLi4uYXJncyovKSB7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgICAgIGlmICh0ZXN0LmFwcGx5KHRoaXMsIGFyZ3MpKSByZXR1cm4gX2l0ZXJhdGVlKG5leHQpOwogICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIFtudWxsXS5jb25jYXQoYXJncykpOwogICAgfTsKICAgIF9pdGVyYXRlZShuZXh0KTsKfQoKLyoqCiAqIExpa2UgWydkb1doaWxzdCdde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5kb1doaWxzdH0sIGV4Y2VwdCB0aGUgYHRlc3RgIGlzIGludmVydGVkLiBOb3RlIHRoZQogKiBhcmd1bWVudCBvcmRlcmluZyBkaWZmZXJzIGZyb20gYHVudGlsYC4KICoKICogQG5hbWUgZG9VbnRpbAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5kb1doaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lCiAqIGB0ZXN0YCBmYWlscy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgLSBzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYWZ0ZXIgZWFjaAogKiBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYC4gSW52b2tlZCB3aXRoIGFueSBub24tZXJyb3IgY2FsbGJhY2sgcmVzdWx0cyBvZgogKiBgaXRlcmF0ZWVgLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3QKICogZnVuY3Rpb24gaGFzIHBhc3NlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAgaGFzIHN0b3BwZWQuIGBjYWxsYmFja2AKICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3MKICogY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pOwogKi8KZnVuY3Rpb24gZG9VbnRpbChpdGVyYXRlZSwgdGVzdCwgY2FsbGJhY2spIHsKICAgIGRvV2hpbHN0KGl0ZXJhdGVlLCBmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gIXRlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgIH0sIGNhbGxiYWNrKTsKfQoKLyoqCiAqIExpa2UgW2B3aGlsc3RgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fSwgZXhjZXB0IHRoZSBgdGVzdGAgaXMgYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQKICogaXMgcGFzc2VkIGEgY2FsbGJhY2sgaW4gdGhlIGZvcm0gb2YgYGZ1bmN0aW9uIChlcnIsIHRydXRoKWAuIElmIGVycm9yIGlzCiAqIHBhc3NlZCB0byBgdGVzdGAgb3IgYGZuYCwgdGhlIG1haW4gY2FsbGJhY2sgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlCiAqIHZhbHVlIG9mIHRoZSBlcnJvci4KICoKICogQG5hbWUgZHVyaW5nCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLndoaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHRlc3QgLSBhc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoCiAqIGV4ZWN1dGlvbiBvZiBgZm5gLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWUKICogYHRlc3RgIHBhc3Nlcy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdAogKiBmdW5jdGlvbiBoYXMgZmFpbGVkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGZuYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYAogKiB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciwgaWYgb25lIG9jY3VycmVkLCBvdGhlcndpc2UgYG51bGxgLgogKiBAZXhhbXBsZQogKgogKiB2YXIgY291bnQgPSAwOwogKgogKiBhc3luYy5kdXJpbmcoCiAqICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHsKICogICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY291bnQgPCA1KTsKICogICAgIH0sCiAqICAgICBmdW5jdGlvbiAoY2FsbGJhY2spIHsKICogICAgICAgICBjb3VudCsrOwogKiAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDApOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uIChlcnIpIHsKICogICAgICAgICAvLyA1IHNlY29uZHMgaGF2ZSBwYXNzZWQKICogICAgIH0KICogKTsKICovCmZ1bmN0aW9uIGR1cmluZyh0ZXN0LCBmbiwgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25seU9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7CiAgICB2YXIgX2ZuID0gd3JhcEFzeW5jKGZuKTsKICAgIHZhciBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTsKCiAgICBmdW5jdGlvbiBuZXh0KGVycikgewogICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgIF90ZXN0KGNoZWNrKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGVjayhlcnIsIHRydXRoKSB7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgaWYgKCF0cnV0aCkgcmV0dXJuIGNhbGxiYWNrKG51bGwpOwogICAgICAgIF9mbihuZXh0KTsKICAgIH0KCiAgICBfdGVzdChjaGVjayk7Cn0KCmZ1bmN0aW9uIF93aXRob3V0SW5kZXgoaXRlcmF0ZWUpIHsKICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBjYWxsYmFjaykgewogICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSwgY2FsbGJhY2spOwogICAgfTsKfQoKLyoqCiAqIEFwcGxpZXMgdGhlIGZ1bmN0aW9uIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCwgaW4gcGFyYWxsZWwuCiAqIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGFuIGl0ZW0gZnJvbSB0aGUgbGlzdCwgYW5kIGEgY2FsbGJhY2sgZm9yIHdoZW4KICogaXQgaGFzIGZpbmlzaGVkLiBJZiB0aGUgYGl0ZXJhdGVlYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGBjYWxsYmFja2AsIHRoZQogKiBtYWluIGBjYWxsYmFja2AgKGZvciB0aGUgYGVhY2hgIGZ1bmN0aW9uKSBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUKICogZXJyb3IuCiAqCiAqIE5vdGUsIHRoYXQgc2luY2UgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIHBhcmFsbGVsLAogKiB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIHdpbGwgY29tcGxldGUgaW4gb3JkZXIuCiAqCiAqIEBuYW1lIGVhY2gKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGFsaWFzIGZvckVhY2gKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8KICogZWFjaCBpdGVtIGluIGBjb2xsYC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS4KICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZmAuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbAogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS4KICogQGV4YW1wbGUKICoKICogLy8gYXNzdW1pbmcgb3BlbkZpbGVzIGlzIGFuIGFycmF5IG9mIGZpbGUgbmFtZXMgYW5kIHNhdmVGaWxlIGlzIGEgZnVuY3Rpb24KICogLy8gdG8gc2F2ZSB0aGUgbW9kaWZpZWQgY29udGVudHMgb2YgdGhhdCBmaWxlOgogKgogKiBhc3luYy5lYWNoKG9wZW5GaWxlcywgc2F2ZUZpbGUsIGZ1bmN0aW9uKGVycil7CiAqICAgLy8gaWYgYW55IG9mIHRoZSBzYXZlcyBwcm9kdWNlZCBhbiBlcnJvciwgZXJyIHdvdWxkIGVxdWFsIHRoYXQgZXJyb3IKICogfSk7CiAqCiAqIC8vIGFzc3VtaW5nIG9wZW5GaWxlcyBpcyBhbiBhcnJheSBvZiBmaWxlIG5hbWVzCiAqIGFzeW5jLmVhY2gob3BlbkZpbGVzLCBmdW5jdGlvbihmaWxlLCBjYWxsYmFjaykgewogKgogKiAgICAgLy8gUGVyZm9ybSBvcGVyYXRpb24gb24gZmlsZSBoZXJlLgogKiAgICAgY29uc29sZS5sb2coJ1Byb2Nlc3NpbmcgZmlsZSAnICsgZmlsZSk7CiAqCiAqICAgICBpZiggZmlsZS5sZW5ndGggPiAzMiApIHsKICogICAgICAgY29uc29sZS5sb2coJ1RoaXMgZmlsZSBuYW1lIGlzIHRvbyBsb25nJyk7CiAqICAgICAgIGNhbGxiYWNrKCdGaWxlIG5hbWUgdG9vIGxvbmcnKTsKICogICAgIH0gZWxzZSB7CiAqICAgICAgIC8vIERvIHdvcmsgdG8gcHJvY2VzcyBmaWxlIGhlcmUKICogICAgICAgY29uc29sZS5sb2coJ0ZpbGUgcHJvY2Vzc2VkJyk7CiAqICAgICAgIGNhbGxiYWNrKCk7CiAqICAgICB9CiAqIH0sIGZ1bmN0aW9uKGVycikgewogKiAgICAgLy8gaWYgYW55IG9mIHRoZSBmaWxlIHByb2Nlc3NpbmcgcHJvZHVjZWQgYW4gZXJyb3IsIGVyciB3b3VsZCBlcXVhbCB0aGF0IGVycm9yCiAqICAgICBpZiggZXJyICkgewogKiAgICAgICAvLyBPbmUgb2YgdGhlIGl0ZXJhdGlvbnMgcHJvZHVjZWQgYW4gZXJyb3IuCiAqICAgICAgIC8vIEFsbCBwcm9jZXNzaW5nIHdpbGwgbm93IHN0b3AuCiAqICAgICAgIGNvbnNvbGUubG9nKCdBIGZpbGUgZmFpbGVkIHRvIHByb2Nlc3MnKTsKICogICAgIH0gZWxzZSB7CiAqICAgICAgIGNvbnNvbGUubG9nKCdBbGwgZmlsZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBzdWNjZXNzZnVsbHknKTsKICogICAgIH0KICogfSk7CiAqLwpmdW5jdGlvbiBlYWNoTGltaXQoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBlYWNoT2YoY29sbCwgX3dpdGhvdXRJbmRleCh3cmFwQXN5bmMoaXRlcmF0ZWUpKSwgY2FsbGJhY2spOwp9CgovKioKICogVGhlIHNhbWUgYXMgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKgogKiBAbmFtZSBlYWNoTGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZWFjaF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9CiAqIEBhbGlhcyBmb3JFYWNoTGltaXQKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBUaGUgYXJyYXkgaW5kZXggaXMgbm90IHBhc3NlZCB0byB0aGUgaXRlcmF0ZWUuCiAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZMaW1pdGAuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuCiAqLwpmdW5jdGlvbiBlYWNoTGltaXQkMShjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBfZWFjaE9mTGltaXQobGltaXQpKGNvbGwsIF93aXRob3V0SW5kZXgod3JhcEFzeW5jKGl0ZXJhdGVlKSksIGNhbGxiYWNrKTsKfQoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGVhY2hTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZWFjaF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9CiAqIEBhbGlhcyBmb3JFYWNoU2VyaWVzCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2gKICogaXRlbSBpbiBgY29sbGAuCiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS4KICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZlNlcmllc2AuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuCiAqLwp2YXIgZWFjaFNlcmllcyA9IGRvTGltaXQoZWFjaExpbWl0JDEsIDEpOwoKLyoqCiAqIFdyYXAgYW4gYXN5bmMgZnVuY3Rpb24gYW5kIGVuc3VyZSBpdCBjYWxscyBpdHMgY2FsbGJhY2sgb24gYSBsYXRlciB0aWNrIG9mCiAqIHRoZSBldmVudCBsb29wLiAgSWYgdGhlIGZ1bmN0aW9uIGFscmVhZHkgY2FsbHMgaXRzIGNhbGxiYWNrIG9uIGEgbmV4dCB0aWNrLAogKiBubyBleHRyYSBkZWZlcnJhbCBpcyBhZGRlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIHByZXZlbnRpbmcgc3RhY2sgb3ZlcmZsb3dzCiAqIChgUmFuZ2VFcnJvcjogTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRgKSBhbmQgZ2VuZXJhbGx5IGtlZXBpbmcKICogW1phbGdvXShodHRwOi8vYmxvZy5penMubWUvcG9zdC81OTE0Mjc0MjE0My9kZXNpZ25pbmctYXBpcy1mb3ItYXN5bmNocm9ueSkKICogY29udGFpbmVkLiBFUzIwMTcgYGFzeW5jYCBmdW5jdGlvbnMgYXJlIHJldHVybmVkIGFzLWlzIC0tIHRoZXkgYXJlIGltbXVuZQogKiB0byBaYWxnbydzIGNvcnJ1cHRpbmcgaW5mbHVlbmNlcywgYXMgdGhleSBhbHdheXMgcmVzb2x2ZSBvbiBhIGxhdGVyIHRpY2suCiAqCiAqIEBuYW1lIGVuc3VyZUFzeW5jCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBhbiBhc3luYyBmdW5jdGlvbiwgb25lIHRoYXQgZXhwZWN0cyBhIG5vZGUtc3R5bGUKICogY2FsbGJhY2sgYXMgaXRzIGxhc3QgYXJndW1lbnQuCiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBSZXR1cm5zIGEgd3JhcHBlZCBmdW5jdGlvbiB3aXRoIHRoZSBleGFjdCBzYW1lIGNhbGwKICogc2lnbmF0dXJlIGFzIHRoZSBmdW5jdGlvbiBwYXNzZWQgaW4uCiAqIEBleGFtcGxlCiAqCiAqIGZ1bmN0aW9uIHNvbWV0aW1lc0FzeW5jKGFyZywgY2FsbGJhY2spIHsKICogICAgIGlmIChjYWNoZVthcmddKSB7CiAqICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNhY2hlW2FyZ10pOyAvLyB0aGlzIHdvdWxkIGJlIHN5bmNocm9ub3VzISEKICogICAgIH0gZWxzZSB7CiAqICAgICAgICAgZG9Tb21lSU8oYXJnLCBjYWxsYmFjayk7IC8vIHRoaXMgSU8gd291bGQgYmUgYXN5bmNocm9ub3VzCiAqICAgICB9CiAqIH0KICoKICogLy8gdGhpcyBoYXMgYSByaXNrIG9mIHN0YWNrIG92ZXJmbG93cyBpZiBtYW55IHJlc3VsdHMgYXJlIGNhY2hlZCBpbiBhIHJvdwogKiBhc3luYy5tYXBTZXJpZXMoYXJncywgc29tZXRpbWVzQXN5bmMsIGRvbmUpOwogKgogKiAvLyB0aGlzIHdpbGwgZGVmZXIgc29tZXRpbWVzQXN5bmMncyBjYWxsYmFjayBpZiBuZWNlc3NhcnksCiAqIC8vIHByZXZlbnRpbmcgc3RhY2sgb3ZlcmZsb3dzCiAqIGFzeW5jLm1hcFNlcmllcyhhcmdzLCBhc3luYy5lbnN1cmVBc3luYyhzb21ldGltZXNBc3luYyksIGRvbmUpOwogKi8KZnVuY3Rpb24gZW5zdXJlQXN5bmMoZm4pIHsKICAgIGlmIChpc0FzeW5jKGZuKSkgcmV0dXJuIGZuOwogICAgcmV0dXJuIGluaXRpYWxQYXJhbXMoZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7CiAgICAgICAgdmFyIHN5bmMgPSB0cnVlOwogICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHZhciBpbm5lckFyZ3MgPSBhcmd1bWVudHM7CiAgICAgICAgICAgIGlmIChzeW5jKSB7CiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUkMShmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgaW5uZXJBcmdzKTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgaW5uZXJBcmdzKTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgICAgIHN5bmMgPSBmYWxzZTsKICAgIH0pOwp9CgpmdW5jdGlvbiBub3RJZCh2KSB7CiAgICByZXR1cm4gIXY7Cn0KCi8qKgogKiBSZXR1cm5zIGB0cnVlYCBpZiBldmVyeSBlbGVtZW50IGluIGBjb2xsYCBzYXRpc2ZpZXMgYW4gYXN5bmMgdGVzdC4gSWYgYW55CiAqIGl0ZXJhdGVlIGNhbGwgcmV0dXJucyBgZmFsc2VgLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZC4KICoKICogQG5hbWUgZXZlcnkKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGFsaWFzIGFsbAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbQogKiBpbiB0aGUgY29sbGVjdGlvbiBpbiBwYXJhbGxlbC4KICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gcmVzdWx0IHZhbHVlLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgCiAqIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luYyB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmV2ZXJ5KFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGVQYXRoLCBjYWxsYmFjaykgewogKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKQogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyBpZiByZXN1bHQgaXMgdHJ1ZSB0aGVuIGV2ZXJ5IGZpbGUgZXhpc3RzCiAqIH0pOwogKi8KdmFyIGV2ZXJ5ID0gZG9QYXJhbGxlbChfY3JlYXRlVGVzdGVyKG5vdElkLCBub3RJZCkpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZXZlcnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKgogKiBAbmFtZSBldmVyeUxpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmV2ZXJ5XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9CiAqIEBhbGlhcyBhbGxMaW1pdAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtCiAqIGluIHRoZSBjb2xsZWN0aW9uIGluIHBhcmFsbGVsLgogKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiByZXN1bHQgdmFsdWUuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAKICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICovCnZhciBldmVyeUxpbWl0ID0gZG9QYXJhbGxlbExpbWl0KF9jcmVhdGVUZXN0ZXIobm90SWQsIG5vdElkKSk7CgovKioKICogVGhlIHNhbWUgYXMgW2BldmVyeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBldmVyeVNlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5ldmVyeV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fQogKiBAYWxpYXMgYWxsU2VyaWVzCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtCiAqIGluIHRoZSBjb2xsZWN0aW9uIGluIHNlcmllcy4KICogVGhlIGl0ZXJhdGVlIG11c3QgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gcmVzdWx0IHZhbHVlLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgCiAqIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luYyB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuCiAqLwp2YXIgZXZlcnlTZXJpZXMgPSBkb0xpbWl0KGV2ZXJ5TGltaXQsIDEpOwoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LgogKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi4KICovCmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHsKICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7CiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTsKICB9Owp9CgpmdW5jdGlvbiBmaWx0ZXJBcnJheShlYWNoZm4sIGFyciwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICB2YXIgdHJ1dGhWYWx1ZXMgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7CiAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgaW5kZXgsIGNhbGxiYWNrKSB7CiAgICAgICAgaXRlcmF0ZWUoeCwgZnVuY3Rpb24gKGVyciwgdikgewogICAgICAgICAgICB0cnV0aFZhbHVlc1tpbmRleF0gPSAhIXY7CiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7CiAgICAgICAgfSk7CiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgewogICAgICAgICAgICBpZiAodHJ1dGhWYWx1ZXNbaV0pIHJlc3VsdHMucHVzaChhcnJbaV0pOwogICAgICAgIH0KICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHRzKTsKICAgIH0pOwp9CgpmdW5jdGlvbiBmaWx0ZXJHZW5lcmljKGVhY2hmbiwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICB2YXIgcmVzdWx0cyA9IFtdOwogICAgZWFjaGZuKGNvbGwsIGZ1bmN0aW9uICh4LCBpbmRleCwgY2FsbGJhY2spIHsKICAgICAgICBpdGVyYXRlZSh4LCBmdW5jdGlvbiAoZXJyLCB2KSB7CiAgICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBpZiAodikgewogICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7aW5kZXg6IGluZGV4LCB2YWx1ZTogeH0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY2FsbGJhY2soKTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwogICAgfSwgZnVuY3Rpb24gKGVycikgewogICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjYWxsYmFjayhudWxsLCBhcnJheU1hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDsKICAgICAgICAgICAgfSksIGJhc2VQcm9wZXJ0eSgndmFsdWUnKSkpOwogICAgICAgIH0KICAgIH0pOwp9CgpmdW5jdGlvbiBfZmlsdGVyKGVhY2hmbiwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICB2YXIgZmlsdGVyID0gaXNBcnJheUxpa2UoY29sbCkgPyBmaWx0ZXJBcnJheSA6IGZpbHRlckdlbmVyaWM7CiAgICBmaWx0ZXIoZWFjaGZuLCBjb2xsLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayB8fCBub29wKTsKfQoKLyoqCiAqIFJldHVybnMgYSBuZXcgYXJyYXkgb2YgYWxsIHRoZSB2YWx1ZXMgaW4gYGNvbGxgIHdoaWNoIHBhc3MgYW4gYXN5bmMgdHJ1dGgKICogdGVzdC4gVGhpcyBvcGVyYXRpb24gaXMgcGVyZm9ybWVkIGluIHBhcmFsbGVsLCBidXQgdGhlIHJlc3VsdHMgYXJyYXkgd2lsbCBiZQogKiBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgb3JpZ2luYWwuCiAqCiAqIEBuYW1lIGZpbHRlcgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAYWxpYXMgc2VsZWN0CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC4KICogVGhlIGBpdGVyYXRlZWAgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJ1dGhWYWx1ZSlgLCB3aGljaCBtdXN0IGJlIGNhbGxlZAogKiB3aXRoIGEgYm9vbGVhbiBhcmd1bWVudCBvbmNlIGl0IGhhcyBjb21wbGV0ZWQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmZpbHRlcihbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHsKICogICAgIGZzLmFjY2VzcyhmaWxlUGF0aCwgZnVuY3Rpb24oZXJyKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycikKICogICAgIH0pOwogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIC8vIHJlc3VsdHMgbm93IGVxdWFscyBhbiBhcnJheSBvZiB0aGUgZXhpc3RpbmcgZmlsZXMKICogfSk7CiAqLwp2YXIgZmlsdGVyID0gZG9QYXJhbGxlbChfZmlsdGVyKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYQogKiB0aW1lLgogKgogKiBAbmFtZSBmaWx0ZXJMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5maWx0ZXJde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9CiAqIEBhbGlhcyBzZWxlY3RMaW1pdAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC4KICogVGhlIGBpdGVyYXRlZWAgaXMgcGFzc2VkIGEgYGNhbGxiYWNrKGVyciwgdHJ1dGhWYWx1ZSlgLCB3aGljaCBtdXN0IGJlIGNhbGxlZAogKiB3aXRoIGEgYm9vbGVhbiBhcmd1bWVudCBvbmNlIGl0IGhhcyBjb21wbGV0ZWQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqLwp2YXIgZmlsdGVyTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2ZpbHRlcik7CgovKioKICogVGhlIHNhbWUgYXMgW2BmaWx0ZXJgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGZpbHRlclNlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5maWx0ZXJde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9CiAqIEBhbGlhcyBzZWxlY3RTZXJpZXMKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLgogKiBUaGUgYGl0ZXJhdGVlYCBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAsIHdoaWNoIG11c3QgYmUgY2FsbGVkCiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKQogKi8KdmFyIGZpbHRlclNlcmllcyA9IGRvTGltaXQoZmlsdGVyTGltaXQsIDEpOwoKLyoqCiAqIENhbGxzIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb24gYGZuYCB3aXRoIGEgY2FsbGJhY2sgcGFyYW1ldGVyIHRoYXQgYWxsb3dzIGl0CiAqIHRvIGNhbGwgaXRzZWxmIGFnYWluLCBpbiBzZXJpZXMsIGluZGVmaW5pdGVseS4KCiAqIElmIGFuIGVycm9yIGlzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgdGhlbiBgZXJyYmFja2AgaXMgY2FsbGVkIHdpdGggdGhlCiAqIGVycm9yLCBhbmQgZXhlY3V0aW9uIHN0b3BzLCBvdGhlcndpc2UgaXQgd2lsbCBuZXZlciBiZSBjYWxsZWQuCiAqCiAqIEBuYW1lIGZvcmV2ZXIKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gYW4gYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCByZXBlYXRlZGx5LgogKiBJbnZva2VkIHdpdGggKG5leHQpLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXJyYmFja10gLSB3aGVuIGBmbmAgcGFzc2VzIGFuIGVycm9yIHRvIGl0J3MgY2FsbGJhY2ssCiAqIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQsIGFuZCBleGVjdXRpb24gc3RvcHMuIEludm9rZWQgd2l0aCAoZXJyKS4KICogQGV4YW1wbGUKICoKICogYXN5bmMuZm9yZXZlcigKICogICAgIGZ1bmN0aW9uKG5leHQpIHsKICogICAgICAgICAvLyBuZXh0IGlzIHN1aXRhYmxlIGZvciBwYXNzaW5nIHRvIHRoaW5ncyB0aGF0IG5lZWQgYSBjYWxsYmFjayhlcnIgWywgd2hhdGV2ZXJdKTsKICogICAgICAgICAvLyBpdCB3aWxsIHJlc3VsdCBpbiB0aGlzIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCBhZ2Fpbi4KICogICAgIH0sCiAqICAgICBmdW5jdGlvbihlcnIpIHsKICogICAgICAgICAvLyBpZiBuZXh0IGlzIGNhbGxlZCB3aXRoIGEgdmFsdWUgaW4gaXRzIGZpcnN0IHBhcmFtZXRlciwgaXQgd2lsbCBhcHBlYXIKICogICAgICAgICAvLyBpbiBoZXJlIGFzICdlcnInLCBhbmQgZXhlY3V0aW9uIHdpbGwgc3RvcC4KICogICAgIH0KICogKTsKICovCmZ1bmN0aW9uIGZvcmV2ZXIoZm4sIGVycmJhY2spIHsKICAgIHZhciBkb25lID0gb25seU9uY2UoZXJyYmFjayB8fCBub29wKTsKICAgIHZhciB0YXNrID0gd3JhcEFzeW5jKGVuc3VyZUFzeW5jKGZuKSk7CgogICAgZnVuY3Rpb24gbmV4dChlcnIpIHsKICAgICAgICBpZiAoZXJyKSByZXR1cm4gZG9uZShlcnIpOwogICAgICAgIHRhc2sobmV4dCk7CiAgICB9CiAgICBuZXh0KCk7Cn0KCi8qKgogKiBUaGUgc2FtZSBhcyBbYGdyb3VwQnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZ3JvdXBCeX0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGdyb3VwQnlMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5ncm91cEJ5XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZ3JvdXBCeX0KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBga2V5YCB0byBncm91cCB0aGUgdmFsdWUgdW5kZXIuCiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0IGlzIGFuIGBPYmplY3RgIHdob3NlcwogKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS4KICovCnZhciBncm91cEJ5TGltaXQgPSBmdW5jdGlvbihjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7CiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTsKICAgIG1hcExpbWl0KGNvbGwsIGxpbWl0LCBmdW5jdGlvbih2YWwsIGNhbGxiYWNrKSB7CiAgICAgICAgX2l0ZXJhdGVlKHZhbCwgZnVuY3Rpb24oZXJyLCBrZXkpIHsKICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7a2V5OiBrZXksIHZhbDogdmFsfSk7CiAgICAgICAgfSk7CiAgICB9LCBmdW5jdGlvbihlcnIsIG1hcFJlc3VsdHMpIHsKICAgICAgICB2YXIgcmVzdWx0ID0ge307CiAgICAgICAgLy8gZnJvbSBNRE4sIGhhbmRsZSBvYmplY3QgaGF2aW5nIGFuIGBoYXNPd25Qcm9wZXJ0eWAgcHJvcAogICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7CgogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwUmVzdWx0cy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICBpZiAobWFwUmVzdWx0c1tpXSkgewogICAgICAgICAgICAgICAgdmFyIGtleSA9IG1hcFJlc3VsdHNbaV0ua2V5OwogICAgICAgICAgICAgICAgdmFyIHZhbCA9IG1hcFJlc3VsdHNbaV0udmFsOwoKICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkgewogICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBbdmFsXTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzdWx0KTsKICAgIH0pOwp9OwoKLyoqCiAqIFJldHVybnMgYSBuZXcgb2JqZWN0LCB3aGVyZSBlYWNoIHZhbHVlIGNvcnJlc3BvbmRzIHRvIGFuIGFycmF5IG9mIGl0ZW1zLCBmcm9tCiAqIGBjb2xsYCwgdGhhdCByZXR1cm5lZCB0aGUgY29ycmVzcG9uZGluZyBrZXkuIFRoYXQgaXMsIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QKICogY29ycmVzcG9uZCB0byB0aGUgdmFsdWVzIHBhc3NlZCB0byB0aGUgYGl0ZXJhdGVlYCBjYWxsYmFjay4KICoKICogTm90ZTogU2luY2UgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIHRoZSBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbiBwYXJhbGxlbCwKICogdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIHdpbGwgY29tcGxldGUgaW4gb3JkZXIuCiAqIEhvd2V2ZXIsIHRoZSB2YWx1ZXMgZm9yIGVhY2gga2V5IGluIHRoZSBgcmVzdWx0YCB3aWxsIGJlIGluIHRoZSBzYW1lIG9yZGVyIGFzCiAqIHRoZSBvcmlnaW5hbCBgY29sbGAuIEZvciBPYmplY3RzLCB0aGUgdmFsdWVzIHdpbGwgcm91Z2hseSBiZSBpbiB0aGUgb3JkZXIgb2YKICogdGhlIG9yaWdpbmFsIE9iamVjdHMnIGtleXMgKGJ1dCB0aGlzIGNhbiB2YXJ5IGFjcm9zcyBKYXZhU2NyaXB0IGVuZ2luZXMpLgogKgogKiBAbmFtZSBncm91cEJ5CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci4KICogSW52b2tlZCB3aXRoICh2YWx1ZSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzCiAqIHByb3BlcnRpZXMgYXJlIGFycmF5cyBvZiB2YWx1ZXMgd2hpY2ggcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5ncm91cEJ5KFsndXNlcklkMScsICd1c2VySWQyJywgJ3VzZXJJZDMnXSwgZnVuY3Rpb24odXNlcklkLCBjYWxsYmFjaykgewogKiAgICAgZGIuZmluZEJ5SWQodXNlcklkLCBmdW5jdGlvbihlcnIsIHVzZXIpIHsKICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICogICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdXNlci5hZ2UpOwogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgaXMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHVzZXJJZHMgZ3JvdXBlZCBieSBhZ2UKICogICAgIC8vIGUuZy4geyAzMDogWyd1c2VySWQxJywgJ3VzZXJJZDMnXSwgNDI6IFsndXNlcklkMiddfTsKICogfSk7CiAqLwp2YXIgZ3JvdXBCeSA9IGRvTGltaXQoZ3JvdXBCeUxpbWl0LCBJbmZpbml0eSk7CgovKioKICogVGhlIHNhbWUgYXMgW2Bncm91cEJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmdyb3VwQnl9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgZ3JvdXBCeVNlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5ncm91cEJ5XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZ3JvdXBCeX0KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBga2V5YCB0byBncm91cCB0aGUgdmFsdWUgdW5kZXIuCiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0IGlzIGFuIGBPYmplY3RgIHdob3NlcwogKiBwcm9wZXJ0aWVzIGFyZSBhcnJheXMgb2YgdmFsdWVzIHdoaWNoIHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS4KICovCnZhciBncm91cEJ5U2VyaWVzID0gZG9MaW1pdChncm91cEJ5TGltaXQsIDEpOwoKLyoqCiAqIExvZ3MgdGhlIHJlc3VsdCBvZiBhbiBgYXN5bmNgIGZ1bmN0aW9uIHRvIHRoZSBgY29uc29sZWAuIE9ubHkgd29ya3MgaW4KICogTm9kZS5qcyBvciBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgYGNvbnNvbGUubG9nYCBhbmQgYGNvbnNvbGUuZXJyb3JgIChzdWNoCiAqIGFzIEZGIGFuZCBDaHJvbWUpLiBJZiBtdWx0aXBsZSBhcmd1bWVudHMgYXJlIHJldHVybmVkIGZyb20gdGhlIGFzeW5jCiAqIGZ1bmN0aW9uLCBgY29uc29sZS5sb2dgIGlzIGNhbGxlZCBvbiBlYWNoIGFyZ3VtZW50IGluIG9yZGVyLgogKgogKiBAbmFtZSBsb2cKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IFV0aWwKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmdW5jdGlvbiAtIFRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBldmVudHVhbGx5IGFwcGx5CiAqIGFsbCBhcmd1bWVudHMgdG8uCiAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGZ1bmN0aW9uLgogKiBAZXhhbXBsZQogKgogKiAvLyBpbiBhIG1vZHVsZQogKiB2YXIgaGVsbG8gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykgewogKiAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCAnaGVsbG8gJyArIG5hbWUpOwogKiAgICAgfSwgMTAwMCk7CiAqIH07CiAqCiAqIC8vIGluIHRoZSBub2RlIHJlcGwKICogbm9kZT4gYXN5bmMubG9nKGhlbGxvLCAnd29ybGQnKTsKICogJ2hlbGxvIHdvcmxkJwogKi8KdmFyIGxvZyA9IGNvbnNvbGVGdW5jKCdsb2cnKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYG1hcFZhbHVlc2Bde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXBWYWx1ZXN9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYQogKiB0aW1lLgogKgogKiBAbmFtZSBtYXBWYWx1ZXNMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5tYXBWYWx1ZXNde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXBWYWx1ZXN9CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdmFsdWUgYW5kIGtleQogKiBpbiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgYXMgaXRzIHJlc3VsdC4KICogSW52b2tlZCB3aXRoICh2YWx1ZSwga2V5LCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIGByZXN1bHRgIGlzIGEgbmV3IG9iamVjdCBjb25zaXN0aW5nCiAqIG9mIGVhY2gga2V5IGZyb20gYG9iamAsIHdpdGggZWFjaCB0cmFuc2Zvcm1lZCB2YWx1ZSBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlLgogKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICovCmZ1bmN0aW9uIG1hcFZhbHVlc0xpbWl0KG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIG5ld09iaiA9IHt9OwogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CiAgICBlYWNoT2ZMaW1pdChvYmosIGxpbWl0LCBmdW5jdGlvbih2YWwsIGtleSwgbmV4dCkgewogICAgICAgIF9pdGVyYXRlZSh2YWwsIGtleSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7CiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBuZXh0KGVycik7CiAgICAgICAgICAgIG5ld09ialtrZXldID0gcmVzdWx0OwogICAgICAgICAgICBuZXh0KCk7CiAgICAgICAgfSk7CiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7CiAgICAgICAgY2FsbGJhY2soZXJyLCBuZXdPYmopOwogICAgfSk7Cn0KCi8qKgogKiBBIHJlbGF0aXZlIG9mIFtgbWFwYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0sIGRlc2lnbmVkIGZvciB1c2Ugd2l0aCBvYmplY3RzLgogKgogKiBQcm9kdWNlcyBhIG5ldyBPYmplY3QgYnkgbWFwcGluZyBlYWNoIHZhbHVlIG9mIGBvYmpgIHRocm91Z2ggdGhlIGBpdGVyYXRlZWAKICogZnVuY3Rpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCBlYWNoIGB2YWx1ZWAgYW5kIGBrZXlgIGZyb20gYG9iamAgYW5kIGEKICogY2FsbGJhY2sgZm9yIHdoZW4gaXQgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcuIEVhY2ggb2YgdGhlc2UgY2FsbGJhY2tzIHRha2VzCiAqIHR3byBhcmd1bWVudHM6IGFuIGBlcnJvcmAsIGFuZCB0aGUgdHJhbnNmb3JtZWQgaXRlbSBmcm9tIGBvYmpgLiBJZiBgaXRlcmF0ZWVgCiAqIHBhc3NlcyBhbiBlcnJvciB0byBpdHMgY2FsbGJhY2ssIHRoZSBtYWluIGBjYWxsYmFja2AgKGZvciB0aGUgYG1hcFZhbHVlc2AKICogZnVuY3Rpb24pIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci4KICoKICogTm90ZSwgdGhlIG9yZGVyIG9mIHRoZSBrZXlzIGluIHRoZSByZXN1bHQgaXMgbm90IGd1YXJhbnRlZWQuICBUaGUga2V5cyB3aWxsCiAqIGJlIHJvdWdobHkgaW4gdGhlIG9yZGVyIHRoZXkgY29tcGxldGUsIChidXQgdGhpcyBpcyB2ZXJ5IGVuZ2luZS1zcGVjaWZpYykKICoKICogQG5hbWUgbWFwVmFsdWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHZhbHVlIGFuZCBrZXkKICogaW4gYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIHZhbHVlIGFzIGl0cyByZXN1bHQuCiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGtleSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZwogKiBvZiBlYWNoIGtleSBmcm9tIGBvYmpgLCB3aXRoIGVhY2ggdHJhbnNmb3JtZWQgdmFsdWUgb24gdGhlIHJpZ2h0LWhhbmQgc2lkZS4KICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLm1hcFZhbHVlcyh7CiAqICAgICBmMTogJ2ZpbGUxJywKICogICAgIGYyOiAnZmlsZTInLAogKiAgICAgZjM6ICdmaWxlMycKICogfSwgZnVuY3Rpb24gKGZpbGUsIGtleSwgY2FsbGJhY2spIHsKICogICBmcy5zdGF0KGZpbGUsIGNhbGxiYWNrKTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBpcyBub3cgYSBtYXAgb2Ygc3RhdHMgZm9yIGVhY2ggZmlsZSwgZS5nLgogKiAgICAgLy8gewogKiAgICAgLy8gICAgIGYxOiBbc3RhdHMgZm9yIGZpbGUxXSwKICogICAgIC8vICAgICBmMjogW3N0YXRzIGZvciBmaWxlMl0sCiAqICAgICAvLyAgICAgZjM6IFtzdGF0cyBmb3IgZmlsZTNdCiAqICAgICAvLyB9CiAqIH0pOwogKi8KCnZhciBtYXBWYWx1ZXMgPSBkb0xpbWl0KG1hcFZhbHVlc0xpbWl0LCBJbmZpbml0eSk7CgovKioKICogVGhlIHNhbWUgYXMgW2BtYXBWYWx1ZXNgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwVmFsdWVzfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIG1hcFZhbHVlc1NlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5tYXBWYWx1ZXNde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXBWYWx1ZXN9CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIHZhbHVlIGFuZCBrZXkKICogaW4gYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIHZhbHVlIGFzIGl0cyByZXN1bHQuCiAqIEludm9rZWQgd2l0aCAodmFsdWUsIGtleSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgcmVzdWx0YCBpcyBhIG5ldyBvYmplY3QgY29uc2lzdGluZwogKiBvZiBlYWNoIGtleSBmcm9tIGBvYmpgLCB3aXRoIGVhY2ggdHJhbnNmb3JtZWQgdmFsdWUgb24gdGhlIHJpZ2h0LWhhbmQgc2lkZS4KICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuCiAqLwp2YXIgbWFwVmFsdWVzU2VyaWVzID0gZG9MaW1pdChtYXBWYWx1ZXNMaW1pdCwgMSk7CgpmdW5jdGlvbiBoYXMob2JqLCBrZXkpIHsKICAgIHJldHVybiBrZXkgaW4gb2JqOwp9CgovKioKICogQ2FjaGVzIHRoZSByZXN1bHRzIG9mIGFuIGFzeW5jIGZ1bmN0aW9uLiBXaGVuIGNyZWF0aW5nIGEgaGFzaCB0byBzdG9yZQogKiBmdW5jdGlvbiByZXN1bHRzIGFnYWluc3QsIHRoZSBjYWxsYmFjayBpcyBvbWl0dGVkIGZyb20gdGhlIGhhc2ggYW5kIGFuCiAqIG9wdGlvbmFsIGhhc2ggZnVuY3Rpb24gY2FuIGJlIHVzZWQuCiAqCiAqIElmIG5vIGhhc2ggZnVuY3Rpb24gaXMgc3BlY2lmaWVkLCB0aGUgZmlyc3QgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhhc2gga2V5LAogKiB3aGljaCBtYXkgd29yayByZWFzb25hYmx5IGlmIGl0IGlzIGEgc3RyaW5nIG9yIGEgZGF0YSB0eXBlIHRoYXQgY29udmVydHMgdG8gYQogKiBkaXN0aW5jdCBzdHJpbmcuIE5vdGUgdGhhdCBvYmplY3RzIGFuZCBhcnJheXMgd2lsbCBub3QgYmVoYXZlIHJlYXNvbmFibHkuCiAqIE5laXRoZXIgd2lsbCBjYXNlcyB3aGVyZSB0aGUgb3RoZXIgYXJndW1lbnRzIGFyZSBzaWduaWZpY2FudC4gSW4gc3VjaCBjYXNlcywKICogc3BlY2lmeSB5b3VyIG93biBoYXNoIGZ1bmN0aW9uLgogKgogKiBUaGUgY2FjaGUgb2YgcmVzdWx0cyBpcyBleHBvc2VkIGFzIHRoZSBgbWVtb2AgcHJvcGVydHkgb2YgdGhlIGZ1bmN0aW9uCiAqIHJldHVybmVkIGJ5IGBtZW1vaXplYC4KICoKICogQG5hbWUgbWVtb2l6ZQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIHByb3h5IGFuZCBjYWNoZSByZXN1bHRzIGZyb20uCiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc2hlciAtIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGEgY3VzdG9tIGhhc2gKICogZm9yIHN0b3JpbmcgcmVzdWx0cy4gSXQgaGFzIGFsbCB0aGUgYXJndW1lbnRzIGFwcGxpZWQgdG8gaXQgYXBhcnQgZnJvbSB0aGUKICogY2FsbGJhY2ssIGFuZCBtdXN0IGJlIHN5bmNocm9ub3VzLgogKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gYSBtZW1vaXplZCB2ZXJzaW9uIG9mIGBmbmAKICogQGV4YW1wbGUKICoKICogdmFyIHNsb3dfZm4gPSBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaykgewogKiAgICAgLy8gZG8gc29tZXRoaW5nCiAqICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpOwogKiB9OwogKiB2YXIgZm4gPSBhc3luYy5tZW1vaXplKHNsb3dfZm4pOwogKgogKiAvLyBmbiBjYW4gbm93IGJlIHVzZWQgYXMgaWYgaXQgd2VyZSBzbG93X2ZuCiAqIGZuKCdzb21lIG5hbWUnLCBmdW5jdGlvbigpIHsKICogICAgIC8vIGNhbGxiYWNrCiAqIH0pOwogKi8KZnVuY3Rpb24gbWVtb2l6ZShmbiwgaGFzaGVyKSB7CiAgICB2YXIgbWVtbyA9IE9iamVjdC5jcmVhdGUobnVsbCk7CiAgICB2YXIgcXVldWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKICAgIGhhc2hlciA9IGhhc2hlciB8fCBpZGVudGl0eTsKICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pOwogICAgdmFyIG1lbW9pemVkID0gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiBtZW1vaXplZChhcmdzLCBjYWxsYmFjaykgewogICAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkobnVsbCwgYXJncyk7CiAgICAgICAgaWYgKGhhcyhtZW1vLCBrZXkpKSB7CiAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgbWVtb1trZXldKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIGlmIChoYXMocXVldWVzLCBrZXkpKSB7CiAgICAgICAgICAgIHF1ZXVlc1trZXldLnB1c2goY2FsbGJhY2spOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHF1ZXVlc1trZXldID0gW2NhbGxiYWNrXTsKICAgICAgICAgICAgX2ZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KGZ1bmN0aW9uKC8qYXJncyovKSB7CiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cyk7CiAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBhcmdzOwogICAgICAgICAgICAgICAgdmFyIHEgPSBxdWV1ZXNba2V5XTsKICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWV1ZXNba2V5XTsKICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcS5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBxW2ldLmFwcGx5KG51bGwsIGFyZ3MpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KSk7CiAgICAgICAgfQogICAgfSk7CiAgICBtZW1vaXplZC5tZW1vID0gbWVtbzsKICAgIG1lbW9pemVkLnVubWVtb2l6ZWQgPSBmbjsKICAgIHJldHVybiBtZW1vaXplZDsKfQoKLyoqCiAqIENhbGxzIGBjYWxsYmFja2Agb24gYSBsYXRlciBsb29wIGFyb3VuZCB0aGUgZXZlbnQgbG9vcC4gSW4gTm9kZS5qcyB0aGlzIGp1c3QKICogY2FsbHMgYHByb2Nlc3MubmV4dFRpY2xgLiAgSW4gdGhlIGJyb3dzZXIgaXQgd2lsbCB1c2UgYHNldEltbWVkaWF0ZWAgaWYKICogYXZhaWxhYmxlLCBvdGhlcndpc2UgYHNldFRpbWVvdXQoY2FsbGJhY2ssIDApYCwgd2hpY2ggbWVhbnMgb3RoZXIgaGlnaGVyCiAqIHByaW9yaXR5IGV2ZW50cyBtYXkgcHJlY2VkZSB0aGUgZXhlY3V0aW9uIG9mIGBjYWxsYmFja2AuCiAqCiAqIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IGZvciBicm93c2VyLWNvbXBhdGliaWxpdHkgcHVycG9zZXMuCiAqCiAqIEBuYW1lIG5leHRUaWNrCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnNldEltbWVkaWF0ZV17QGxpbmsgbW9kdWxlOlV0aWxzLnNldEltbWVkaWF0ZX0KICogQGNhdGVnb3J5IFV0aWwKICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBvbiBhIGxhdGVyIGxvb3AgYXJvdW5kCiAqIHRoZSBldmVudCBsb29wLiBJbnZva2VkIHdpdGggKGFyZ3MuLi4pLgogKiBAcGFyYW0gey4uLip9IGFyZ3MuLi4gLSBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlCiAqIGNhbGxiYWNrIG9uIHRoZSBuZXh0IHRpY2suCiAqIEBleGFtcGxlCiAqCiAqIHZhciBjYWxsX29yZGVyID0gW107CiAqIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uKCkgewogKiAgICAgY2FsbF9vcmRlci5wdXNoKCd0d28nKTsKICogICAgIC8vIGNhbGxfb3JkZXIgbm93IGVxdWFscyBbJ29uZScsJ3R3byddCiAqIH0pOwogKiBjYWxsX29yZGVyLnB1c2goJ29uZScpOwogKgogKiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKGEsIGIsIGMpIHsKICogICAgIC8vIGEsIGIsIGFuZCBjIGVxdWFsIDEsIDIsIGFuZCAzCiAqIH0sIDEsIDIsIDMpOwogKi8KdmFyIF9kZWZlciQxOwoKaWYgKGhhc05leHRUaWNrKSB7CiAgICBfZGVmZXIkMSA9IHByb2Nlc3MubmV4dFRpY2s7Cn0gZWxzZSBpZiAoaGFzU2V0SW1tZWRpYXRlKSB7CiAgICBfZGVmZXIkMSA9IHNldEltbWVkaWF0ZTsKfSBlbHNlIHsKICAgIF9kZWZlciQxID0gZmFsbGJhY2s7Cn0KCnZhciBuZXh0VGljayA9IHdyYXAoX2RlZmVyJDEpOwoKZnVuY3Rpb24gX3BhcmFsbGVsKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7CiAgICB2YXIgcmVzdWx0cyA9IGlzQXJyYXlMaWtlKHRhc2tzKSA/IFtdIDoge307CgogICAgZWFjaGZuKHRhc2tzLCBmdW5jdGlvbiAodGFzaywga2V5LCBjYWxsYmFjaykgewogICAgICAgIHdyYXBBc3luYyh0YXNrKShmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlc3VsdDsKICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpOwogICAgfSk7Cn0KCi8qKgogKiBSdW4gdGhlIGB0YXNrc2AgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgaW4gcGFyYWxsZWwsIHdpdGhvdXQgd2FpdGluZyB1bnRpbAogKiB0aGUgcHJldmlvdXMgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZC4gSWYgYW55IG9mIHRoZSBmdW5jdGlvbnMgcGFzcyBhbiBlcnJvciB0bwogKiBpdHMgY2FsbGJhY2ssIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIHZhbHVlIG9mIHRoZQogKiBlcnJvci4gT25jZSB0aGUgYHRhc2tzYCBoYXZlIGNvbXBsZXRlZCwgdGhlIHJlc3VsdHMgYXJlIHBhc3NlZCB0byB0aGUgZmluYWwKICogYGNhbGxiYWNrYCBhcyBhbiBhcnJheS4KICoKICogKipOb3RlOioqIGBwYXJhbGxlbGAgaXMgYWJvdXQga2lja2luZy1vZmYgSS9PIHRhc2tzIGluIHBhcmFsbGVsLCBub3QgYWJvdXQKICogcGFyYWxsZWwgZXhlY3V0aW9uIG9mIGNvZGUuICBJZiB5b3VyIHRhc2tzIGRvIG5vdCB1c2UgYW55IHRpbWVycyBvciBwZXJmb3JtCiAqIGFueSBJL08sIHRoZXkgd2lsbCBhY3R1YWxseSBiZSBleGVjdXRlZCBpbiBzZXJpZXMuICBBbnkgc3luY2hyb25vdXMgc2V0dXAKICogc2VjdGlvbnMgZm9yIGVhY2ggdGFzayB3aWxsIGhhcHBlbiBvbmUgYWZ0ZXIgdGhlIG90aGVyLiAgSmF2YVNjcmlwdCByZW1haW5zCiAqIHNpbmdsZS10aHJlYWRlZC4KICoKICogKipIaW50OioqIFVzZSBbYHJlZmxlY3RgXXtAbGluayBtb2R1bGU6VXRpbHMucmVmbGVjdH0gdG8gY29udGludWUgdGhlCiAqIGV4ZWN1dGlvbiBvZiBvdGhlciB0YXNrcyB3aGVuIGEgdGFzayBmYWlscy4KICoKICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byB1c2UgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIEVhY2ggcHJvcGVydHkgd2lsbAogKiBiZSBydW4gYXMgYSBmdW5jdGlvbiBhbmQgdGhlIHJlc3VsdHMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZpbmFsIGBjYWxsYmFja2AKICogYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIFRoaXMgY2FuIGJlIGEgbW9yZSByZWFkYWJsZSB3YXkgb2YgaGFuZGxpbmcKICogcmVzdWx0cyBmcm9tIHtAbGluayBhc3luYy5wYXJhbGxlbH0uCiAqCiAqIEBuYW1lIHBhcmFsbGVsCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIG9mCiAqIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHJ1bi4KICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGUKICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS4gVGhpcyBmdW5jdGlvbiBnZXRzIGEgcmVzdWx0cyBhcnJheQogKiAob3Igb2JqZWN0KSBjb250YWluaW5nIGFsbCB0aGUgcmVzdWx0IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHRhc2sgY2FsbGJhY2tzLgogKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqCiAqIEBleGFtcGxlCiAqIGFzeW5jLnBhcmFsbGVsKFsKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpOwogKiAgICAgICAgIH0sIDIwMCk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7CiAqICAgICAgICAgfSwgMTAwKTsKICogICAgIH0KICogXSwKICogLy8gb3B0aW9uYWwgY2FsbGJhY2sKICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGVxdWFsIFsnb25lJywndHdvJ10gZXZlbiB0aG91Z2gKICogICAgIC8vIHRoZSBzZWNvbmQgZnVuY3Rpb24gaGFkIGEgc2hvcnRlciB0aW1lb3V0LgogKiB9KTsKICoKICogLy8gYW4gZXhhbXBsZSB1c2luZyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheQogKiBhc3luYy5wYXJhbGxlbCh7CiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMSk7CiAqICAgICAgICAgfSwgMjAwKTsKICogICAgIH0sCiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7CiAqICAgICAgICAgfSwgMTAwKTsKICogICAgIH0KICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBlcXVhbHMgdG86IHtvbmU6IDEsIHR3bzogMn0KICogfSk7CiAqLwpmdW5jdGlvbiBwYXJhbGxlbExpbWl0KHRhc2tzLCBjYWxsYmFjaykgewogICAgX3BhcmFsbGVsKGVhY2hPZiwgdGFza3MsIGNhbGxiYWNrKTsKfQoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgcGFyYWxsZWxgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucGFyYWxsZWx9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYQogKiB0aW1lLgogKgogKiBAbmFtZSBwYXJhbGxlbExpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnBhcmFsbGVsXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucGFyYWxsZWx9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIG9mCiAqIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHJ1bi4KICogRWFjaCBhc3luYyBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZQogKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5CiAqIChvciBvYmplY3QpIGNvbnRhaW5pbmcgYWxsIHRoZSByZXN1bHQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgdGFzayBjYWxsYmFja3MuCiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICovCmZ1bmN0aW9uIHBhcmFsbGVsTGltaXQkMSh0YXNrcywgbGltaXQsIGNhbGxiYWNrKSB7CiAgICBfcGFyYWxsZWwoX2VhY2hPZkxpbWl0KGxpbWl0KSwgdGFza3MsIGNhbGxiYWNrKTsKfQoKLyoqCiAqIEEgcXVldWUgb2YgdGFza3MgZm9yIHRoZSB3b3JrZXIgZnVuY3Rpb24gdG8gY29tcGxldGUuCiAqIEB0eXBlZGVmIHtPYmplY3R9IFF1ZXVlT2JqZWN0CiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGVuZ3RoIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIG51bWJlciBvZiBpdGVtcwogKiB3YWl0aW5nIHRvIGJlIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLmxlbmd0aCgpYC4KICogQHByb3BlcnR5IHtib29sZWFufSBzdGFydGVkIC0gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgYW55CiAqIGl0ZW1zIGhhdmUgYmVlbiBwdXNoZWQgYW5kIHByb2Nlc3NlZCBieSB0aGUgcXVldWUuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJ1bm5pbmcgLSBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIGl0ZW1zCiAqIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5ydW5uaW5nKClgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB3b3JrZXJzTGlzdCAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBhcnJheSBvZiBpdGVtcwogKiBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkLiBJbnZva2Ugd2l0aCBgcXVldWUud29ya2Vyc0xpc3QoKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGlkbGUgLSBhIGZ1bmN0aW9uIHJldHVybmluZyBmYWxzZSBpZiB0aGVyZSBhcmUgaXRlbXMKICogd2FpdGluZyBvciBiZWluZyBwcm9jZXNzZWQsIG9yIHRydWUgaWYgbm90LiBJbnZva2Ugd2l0aCBgcXVldWUuaWRsZSgpYC4KICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbmN1cnJlbmN5IC0gYW4gaW50ZWdlciBmb3IgZGV0ZXJtaW5pbmcgaG93IG1hbnkgYHdvcmtlcmAKICogZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuIFRoaXMgcHJvcGVydHkgY2FuIGJlIGNoYW5nZWQgYWZ0ZXIgYQogKiBgcXVldWVgIGlzIGNyZWF0ZWQgdG8gYWx0ZXIgdGhlIGNvbmN1cnJlbmN5IG9uLXRoZS1mbHkuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHB1c2ggLSBhZGQgYSBuZXcgdGFzayB0byB0aGUgYHF1ZXVlYC4gQ2FsbHMgYGNhbGxiYWNrYAogKiBvbmNlIHRoZSBgd29ya2VyYCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZyB0aGUgdGFzay4gSW5zdGVhZCBvZiBhIHNpbmdsZSB0YXNrLAogKiBhIGB0YXNrc2AgYXJyYXkgY2FuIGJlIHN1Ym1pdHRlZC4gVGhlIHJlc3BlY3RpdmUgY2FsbGJhY2sgaXMgdXNlZCBmb3IgZXZlcnkKICogdGFzayBpbiB0aGUgbGlzdC4gSW52b2tlIHdpdGggYHF1ZXVlLnB1c2godGFzaywgW2NhbGxiYWNrXSlgLAogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1bnNoaWZ0IC0gYWRkIGEgbmV3IHRhc2sgdG8gdGhlIGZyb250IG9mIHRoZSBgcXVldWVgLgogKiBJbnZva2Ugd2l0aCBgcXVldWUudW5zaGlmdCh0YXNrLCBbY2FsbGJhY2tdKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJlbW92ZSAtIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBxdWV1ZSB0aGF0IG1hdGNoIGEgdGVzdAogKiBmdW5jdGlvbi4gIFRoZSB0ZXN0IGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIGFuIG9iamVjdCB3aXRoIGEgYGRhdGFgIHByb3BlcnR5LAogKiBhbmQgYSBgcHJpb3JpdHlgIHByb3BlcnR5LCBpZiB0aGlzIGlzIGEKICogW3ByaW9yaXR5UXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wcmlvcml0eVF1ZXVlfSBvYmplY3QuCiAqIEludm9rZWQgd2l0aCBgcXVldWUucmVtb3ZlKHRlc3RGbilgLCB3aGVyZSBgdGVzdEZuYCBpcyBvZiB0aGUgZm9ybQogKiBgZnVuY3Rpb24gKHtkYXRhLCBwcmlvcml0eX0pIHt9YCBhbmQgcmV0dXJucyBhIEJvb2xlYW4uCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHNhdHVyYXRlZCAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbnVtYmVyIG9mCiAqIHJ1bm5pbmcgd29ya2VycyBoaXRzIHRoZSBgY29uY3VycmVuY3lgIGxpbWl0LCBhbmQgZnVydGhlciB0YXNrcyB3aWxsIGJlCiAqIHF1ZXVlZC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdW5zYXR1cmF0ZWQgLSBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIG51bWJlcgogKiBvZiBydW5uaW5nIHdvcmtlcnMgaXMgbGVzcyB0aGFuIHRoZSBgY29uY3VycmVuY3lgICYgYGJ1ZmZlcmAgbGltaXRzLCBhbmQKICogZnVydGhlciB0YXNrcyB3aWxsIG5vdCBiZSBxdWV1ZWQuCiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBidWZmZXIgLSBBIG1pbmltdW0gdGhyZXNob2xkIGJ1ZmZlciBpbiBvcmRlciB0byBzYXkgdGhhdAogKiB0aGUgYHF1ZXVlYCBpcyBgdW5zYXR1cmF0ZWRgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlbXB0eSAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtCiAqIGZyb20gdGhlIGBxdWV1ZWAgaXMgZ2l2ZW4gdG8gYSBgd29ya2VyYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZHJhaW4gLSBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGxhc3QgaXRlbQogKiBmcm9tIHRoZSBgcXVldWVgIGhhcyByZXR1cm5lZCBmcm9tIHRoZSBgd29ya2VyYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZXJyb3IgLSBhIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSB0YXNrIGVycm9ycy4KICogSGFzIHRoZSBzaWduYXR1cmUgYGZ1bmN0aW9uKGVycm9yLCB0YXNrKWAuCiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGF1c2VkIC0gYSBib29sZWFuIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBxdWV1ZSBpcwogKiBpbiBhIHBhdXNlZCBzdGF0ZS4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcGF1c2UgLSBhIGZ1bmN0aW9uIHRoYXQgcGF1c2VzIHRoZSBwcm9jZXNzaW5nIG9mIHRhc2tzCiAqIHVudGlsIGByZXN1bWUoKWAgaXMgY2FsbGVkLiBJbnZva2Ugd2l0aCBgcXVldWUucGF1c2UoKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHJlc3VtZSAtIGEgZnVuY3Rpb24gdGhhdCByZXN1bWVzIHRoZSBwcm9jZXNzaW5nIG9mCiAqIHF1ZXVlZCB0YXNrcyB3aGVuIHRoZSBxdWV1ZSBpcyBwYXVzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5yZXN1bWUoKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGtpbGwgLSBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgYGRyYWluYCBjYWxsYmFjayBhbmQKICogZW1wdGllcyByZW1haW5pbmcgdGFza3MgZnJvbSB0aGUgcXVldWUgZm9yY2luZyBpdCB0byBnbyBpZGxlLiBObyBtb3JlIHRhc2tzCiAqIHNob3VsZCBiZSBwdXNoZWQgdG8gdGhlIHF1ZXVlIGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi4gSW52b2tlIHdpdGggYHF1ZXVlLmtpbGwoKWAuCiAqLwoKLyoqCiAqIENyZWF0ZXMgYSBgcXVldWVgIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgYGNvbmN1cnJlbmN5YC4gVGFza3MgYWRkZWQgdG8gdGhlCiAqIGBxdWV1ZWAgYXJlIHByb2Nlc3NlZCBpbiBwYXJhbGxlbCAodXAgdG8gdGhlIGBjb25jdXJyZW5jeWAgbGltaXQpLiBJZiBhbGwKICogYHdvcmtlcmBzIGFyZSBpbiBwcm9ncmVzcywgdGhlIHRhc2sgaXMgcXVldWVkIHVudGlsIG9uZSBiZWNvbWVzIGF2YWlsYWJsZS4KICogT25jZSBhIGB3b3JrZXJgIGNvbXBsZXRlcyBhIGB0YXNrYCwgdGhhdCBgdGFza2AncyBjYWxsYmFjayBpcyBjYWxsZWQuCiAqCiAqIEBuYW1lIHF1ZXVlCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luYyBmdW5jdGlvbiBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlZCB0YXNrLgogKiBJZiB5b3Ugd2FudCB0byBoYW5kbGUgZXJyb3JzIGZyb20gYW4gaW5kaXZpZHVhbCB0YXNrLCBwYXNzIGEgY2FsbGJhY2sgdG8KICogYHEucHVzaCgpYC4gSW52b2tlZCB3aXRoICh0YXNrLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVuY3k9MV0gLSBBbiBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nIGhvdyBtYW55CiAqIGB3b3JrZXJgIGZ1bmN0aW9ucyBzaG91bGQgYmUgcnVuIGluIHBhcmFsbGVsLiAgSWYgb21pdHRlZCwgdGhlIGNvbmN1cnJlbmN5CiAqIGRlZmF1bHRzIHRvIGAxYC4gIElmIHRoZSBjb25jdXJyZW5jeSBpcyBgMGAsIGFuIGVycm9yIGlzIHRocm93bi4KICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5RdWV1ZU9iamVjdH0gQSBxdWV1ZSBvYmplY3QgdG8gbWFuYWdlIHRoZSB0YXNrcy4gQ2FsbGJhY2tzIGNhbgogKiBhdHRhY2hlZCBhcyBjZXJ0YWluIHByb3BlcnRpZXMgdG8gbGlzdGVuIGZvciBzcGVjaWZpYyBldmVudHMgZHVyaW5nIHRoZQogKiBsaWZlY3ljbGUgb2YgdGhlIHF1ZXVlLgogKiBAZXhhbXBsZQogKgogKiAvLyBjcmVhdGUgYSBxdWV1ZSBvYmplY3Qgd2l0aCBjb25jdXJyZW5jeSAyCiAqIHZhciBxID0gYXN5bmMucXVldWUoZnVuY3Rpb24odGFzaywgY2FsbGJhY2spIHsKICogICAgIGNvbnNvbGUubG9nKCdoZWxsbyAnICsgdGFzay5uYW1lKTsKICogICAgIGNhbGxiYWNrKCk7CiAqIH0sIDIpOwogKgogKiAvLyBhc3NpZ24gYSBjYWxsYmFjawogKiBxLmRyYWluID0gZnVuY3Rpb24oKSB7CiAqICAgICBjb25zb2xlLmxvZygnYWxsIGl0ZW1zIGhhdmUgYmVlbiBwcm9jZXNzZWQnKTsKICogfTsKICoKICogLy8gYWRkIHNvbWUgaXRlbXMgdG8gdGhlIHF1ZXVlCiAqIHEucHVzaCh7bmFtZTogJ2Zvbyd9LCBmdW5jdGlvbihlcnIpIHsKICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGZvbycpOwogKiB9KTsKICogcS5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uIChlcnIpIHsKICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpOwogKiB9KTsKICoKICogLy8gYWRkIHNvbWUgaXRlbXMgdG8gdGhlIHF1ZXVlIChiYXRjaC13aXNlKQogKiBxLnB1c2goW3tuYW1lOiAnYmF6J30se25hbWU6ICdiYXknfSx7bmFtZTogJ2JheCd9XSwgZnVuY3Rpb24oZXJyKSB7CiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBpdGVtJyk7CiAqIH0pOwogKgogKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlCiAqIHEudW5zaGlmdCh7bmFtZTogJ2Jhcid9LCBmdW5jdGlvbiAoZXJyKSB7CiAqICAgICBjb25zb2xlLmxvZygnZmluaXNoZWQgcHJvY2Vzc2luZyBiYXInKTsKICogfSk7CiAqLwp2YXIgcXVldWUkMSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7CiAgICB2YXIgX3dvcmtlciA9IHdyYXBBc3luYyh3b3JrZXIpOwogICAgcmV0dXJuIHF1ZXVlKGZ1bmN0aW9uIChpdGVtcywgY2IpIHsKICAgICAgICBfd29ya2VyKGl0ZW1zWzBdLCBjYik7CiAgICB9LCBjb25jdXJyZW5jeSwgMSk7Cn07CgovKioKICogVGhlIHNhbWUgYXMgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9IG9ubHkgdGFza3MgYXJlIGFzc2lnbmVkIGEgcHJpb3JpdHkgYW5kCiAqIGNvbXBsZXRlZCBpbiBhc2NlbmRpbmcgcHJpb3JpdHkgb3JkZXIuCiAqCiAqIEBuYW1lIHByaW9yaXR5UXVldWUKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMucXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIGEgcXVldWVkIHRhc2suCiAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSBlcnJvcnMgZnJvbSBhbiBpbmRpdmlkdWFsIHRhc2ssIHBhc3MgYSBjYWxsYmFjayB0bwogKiBgcS5wdXNoKClgLgogKiBJbnZva2VkIHdpdGggKHRhc2ssIGNhbGxiYWNrKS4KICogQHBhcmFtIHtudW1iZXJ9IGNvbmN1cnJlbmN5IC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueSBgd29ya2VyYAogKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gIElmIG9taXR0ZWQsIHRoZSBjb25jdXJyZW5jeSBkZWZhdWx0cyB0bwogKiBgMWAuICBJZiB0aGUgY29uY3VycmVuY3kgaXMgYDBgLCBhbiBlcnJvciBpcyB0aHJvd24uCiAqIEByZXR1cm5zIHttb2R1bGU6Q29udHJvbEZsb3cuUXVldWVPYmplY3R9IEEgcHJpb3JpdHlRdWV1ZSBvYmplY3QgdG8gbWFuYWdlIHRoZSB0YXNrcy4gVGhlcmUgYXJlIHR3bwogKiBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBxdWV1ZWAgYW5kIGBwcmlvcml0eVF1ZXVlYCBvYmplY3RzOgogKiAqIGBwdXNoKHRhc2ssIHByaW9yaXR5LCBbY2FsbGJhY2tdKWAgLSBgcHJpb3JpdHlgIHNob3VsZCBiZSBhIG51bWJlci4gSWYgYW4KICogICBhcnJheSBvZiBgdGFza3NgIGlzIGdpdmVuLCBhbGwgdGFza3Mgd2lsbCBiZSBhc3NpZ25lZCB0aGUgc2FtZSBwcmlvcml0eS4KICogKiBUaGUgYHVuc2hpZnRgIG1ldGhvZCB3YXMgcmVtb3ZlZC4KICovCnZhciBwcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24od29ya2VyLCBjb25jdXJyZW5jeSkgewogICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZQogICAgdmFyIHEgPSBxdWV1ZSQxKHdvcmtlciwgY29uY3VycmVuY3kpOwoKICAgIC8vIE92ZXJyaWRlIHB1c2ggdG8gYWNjZXB0IHNlY29uZCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHByaW9yaXR5CiAgICBxLnB1c2ggPSBmdW5jdGlvbihkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spIHsKICAgICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbCkgY2FsbGJhY2sgPSBub29wOwogICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXNrIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpOwogICAgICAgIH0KICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlOwogICAgICAgIGlmICghaXNBcnJheShkYXRhKSkgewogICAgICAgICAgICBkYXRhID0gW2RhdGFdOwogICAgICAgIH0KICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgLy8gY2FsbCBkcmFpbiBpbW1lZGlhdGVseSBpZiB0aGVyZSBhcmUgbm8gdGFza3MKICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcS5kcmFpbigpOwogICAgICAgICAgICB9KTsKICAgICAgICB9CgogICAgICAgIHByaW9yaXR5ID0gcHJpb3JpdHkgfHwgMDsKICAgICAgICB2YXIgbmV4dE5vZGUgPSBxLl90YXNrcy5oZWFkOwogICAgICAgIHdoaWxlIChuZXh0Tm9kZSAmJiBwcmlvcml0eSA+PSBuZXh0Tm9kZS5wcmlvcml0eSkgewogICAgICAgICAgICBuZXh0Tm9kZSA9IG5leHROb2RlLm5leHQ7CiAgICAgICAgfQoKICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgICAgIHZhciBpdGVtID0gewogICAgICAgICAgICAgICAgZGF0YTogZGF0YVtpXSwKICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSwKICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjawogICAgICAgICAgICB9OwoKICAgICAgICAgICAgaWYgKG5leHROb2RlKSB7CiAgICAgICAgICAgICAgICBxLl90YXNrcy5pbnNlcnRCZWZvcmUobmV4dE5vZGUsIGl0ZW0pOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcS5fdGFza3MucHVzaChpdGVtKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzZXRJbW1lZGlhdGUkMShxLnByb2Nlc3MpOwogICAgfTsKCiAgICAvLyBSZW1vdmUgdW5zaGlmdCBmdW5jdGlvbgogICAgZGVsZXRlIHEudW5zaGlmdDsKCiAgICByZXR1cm4gcTsKfTsKCi8qKgogKiBSdW5zIHRoZSBgdGFza3NgIGFycmF5IG9mIGZ1bmN0aW9ucyBpbiBwYXJhbGxlbCwgd2l0aG91dCB3YWl0aW5nIHVudGlsIHRoZQogKiBwcmV2aW91cyBmdW5jdGlvbiBoYXMgY29tcGxldGVkLiBPbmNlIGFueSBvZiB0aGUgYHRhc2tzYCBjb21wbGV0ZSBvciBwYXNzIGFuCiAqIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQuIEl0J3MKICogZXF1aXZhbGVudCB0byBgUHJvbWlzZS5yYWNlKClgLgogKgogKiBAbmFtZSByYWNlCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheX0gdGFza3MgLSBBbiBhcnJheSBjb250YWluaW5nIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259CiAqIHRvIHJ1bi4gRWFjaCBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbiBvcHRpb25hbCBgcmVzdWx0YCB2YWx1ZS4KICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFueSBvZiB0aGUgZnVuY3Rpb25zIGhhdmUKICogY29tcGxldGVkLiBUaGlzIGZ1bmN0aW9uIGdldHMgYW4gZXJyb3Igb3IgcmVzdWx0IGZyb20gdGhlIGZpcnN0IGZ1bmN0aW9uIHRoYXQKICogY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICogQHJldHVybnMgdW5kZWZpbmVkCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLnJhY2UoWwogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7CiAqICAgICAgICAgfSwgMjAwKTsKICogICAgIH0sCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTsKICogICAgICAgICB9LCAxMDApOwogKiAgICAgfQogKiBdLAogKiAvLyBtYWluIGNhbGxiYWNrCiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyB0aGUgcmVzdWx0IHdpbGwgYmUgZXF1YWwgdG8gJ3R3bycgYXMgaXQgZmluaXNoZXMgZWFybGllcgogKiB9KTsKICovCmZ1bmN0aW9uIHJhY2UodGFza3MsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7CiAgICBpZiAoIWlzQXJyYXkodGFza3MpKSByZXR1cm4gY2FsbGJhY2sobmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gcmFjZSBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpKTsKICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTsKICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGFza3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICAgICAgd3JhcEFzeW5jKHRhc2tzW2ldKShjYWxsYmFjayk7CiAgICB9Cn0KCi8qKgogKiBTYW1lIGFzIFtgcmVkdWNlYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlZHVjZX0sIG9ubHkgb3BlcmF0ZXMgb24gYGFycmF5YCBpbiByZXZlcnNlIG9yZGVyLgogKgogKiBAbmFtZSByZWR1Y2VSaWdodAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5yZWR1Y2Vde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWR1Y2V9CiAqIEBhbGlhcyBmb2xkcgogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7Kn0gbWVtbyAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIGFwcGxpZWQgdG8gZWFjaCBpdGVtIGluIHRoZQogKiBhcnJheSB0byBwcm9kdWNlIHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHJlZHVjdGlvbi4KICogVGhlIGBpdGVyYXRlZWAgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIG5leHQgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi4KICogSWYgdGhlIGl0ZXJhdGVlIGNvbXBsZXRlIHdpdGggYW4gZXJyb3IsIHRoZSByZWR1Y3Rpb24gaXMgc3RvcHBlZCBhbmQgdGhlCiAqIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuCiAqIEludm9rZWQgd2l0aCAobWVtbywgaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHJlZHVjZWQgdmFsdWUuIEludm9rZWQgd2l0aAogKiAoZXJyLCByZXN1bHQpLgogKi8KZnVuY3Rpb24gcmVkdWNlUmlnaHQgKGFycmF5LCBtZW1vLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIHZhciByZXZlcnNlZCA9IHNsaWNlKGFycmF5KS5yZXZlcnNlKCk7CiAgICByZWR1Y2UocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdGVlLCBjYWxsYmFjayk7Cn0KCi8qKgogKiBXcmFwcyB0aGUgYXN5bmMgZnVuY3Rpb24gaW4gYW5vdGhlciBmdW5jdGlvbiB0aGF0IGFsd2F5cyBjb21wbGV0ZXMgd2l0aCBhCiAqIHJlc3VsdCBvYmplY3QsIGV2ZW4gd2hlbiBpdCBlcnJvcnMuCiAqCiAqIFRoZSByZXN1bHQgb2JqZWN0IGhhcyBlaXRoZXIgdGhlIHByb3BlcnR5IGBlcnJvcmAgb3IgYHZhbHVlYC4KICoKICogQG5hbWUgcmVmbGVjdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHlvdSB3YW50IHRvIHdyYXAKICogQHJldHVybnMge0Z1bmN0aW9ufSAtIEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcGFzc2VzIG51bGwgdG8gaXQncyBjYWxsYmFjayBhcwogKiB0aGUgZXJyb3IuIFRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIGNhbGxiYWNrIHdpbGwgYmUgYW4gYG9iamVjdGAgd2l0aAogKiBlaXRoZXIgYW4gYGVycm9yYCBvciBhIGB2YWx1ZWAgcHJvcGVydHkuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLnBhcmFsbGVsKFsKICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICAvLyBkbyBzb21lIHN0dWZmIC4uLgogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTsKICogICAgIH0pLAogKiAgICAgYXN5bmMucmVmbGVjdChmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIC8vIGRvIHNvbWUgbW9yZSBzdHVmZiBidXQgZXJyb3IgLi4uCiAqICAgICAgICAgY2FsbGJhY2soJ2JhZCBzdHVmZiBoYXBwZW5lZCcpOwogKiAgICAgfSksCiAqICAgICBhc3luYy5yZWZsZWN0KGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIC4uLgogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTsKICogICAgIH0pCiAqIF0sCiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrCiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gdmFsdWVzCiAqICAgICAvLyByZXN1bHRzWzBdLnZhbHVlID0gJ29uZScKICogICAgIC8vIHJlc3VsdHNbMV0uZXJyb3IgPSAnYmFkIHN0dWZmIGhhcHBlbmVkJwogKiAgICAgLy8gcmVzdWx0c1syXS52YWx1ZSA9ICd0d28nCiAqIH0pOwogKi8KZnVuY3Rpb24gcmVmbGVjdChmbikgewogICAgdmFyIF9mbiA9IHdyYXBBc3luYyhmbik7CiAgICByZXR1cm4gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiByZWZsZWN0T24oYXJncywgcmVmbGVjdENhbGxiYWNrKSB7CiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uIGNhbGxiYWNrKGVycm9yLCBjYkFyZykgewogICAgICAgICAgICBpZiAoZXJyb3IpIHsKICAgICAgICAgICAgICAgIHJlZmxlY3RDYWxsYmFjayhudWxsLCB7IGVycm9yOiBlcnJvciB9KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHZhciB2YWx1ZTsKICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDIpIHsKICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNiQXJnOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZWZsZWN0Q2FsbGJhY2sobnVsbCwgeyB2YWx1ZTogdmFsdWUgfSk7CiAgICAgICAgICAgIH0KICAgICAgICB9KTsKCiAgICAgICAgcmV0dXJuIF9mbi5hcHBseSh0aGlzLCBhcmdzKTsKICAgIH0pOwp9CgovKioKICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCB3cmFwcyBhbiBhcnJheSBvciBhbiBvYmplY3Qgb2YgZnVuY3Rpb25zIHdpdGggYHJlZmxlY3RgLgogKgogKiBAbmFtZSByZWZsZWN0QWxsCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnJlZmxlY3Rde0BsaW5rIG1vZHVsZTpVdGlscy5yZWZsZWN0fQogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0FycmF5fE9iamVjdHxJdGVyYWJsZX0gdGFza3MgLSBUaGUgY29sbGVjdGlvbiBvZgogKiBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byB3cmFwIGluIGBhc3luYy5yZWZsZWN0YC4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGFzeW5jIGZ1bmN0aW9ucywgZWFjaCB3cmFwcGVkIGluCiAqIGBhc3luYy5yZWZsZWN0YAogKiBAZXhhbXBsZQogKgogKiBsZXQgdGFza3MgPSBbCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTsKICogICAgICAgICB9LCAyMDApOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIGJ1dCBlcnJvciAuLi4KICogICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ2JhZCBzdHVmZiBoYXBwZW5lZCcpKTsKICogICAgIH0sCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTsKICogICAgICAgICB9LCAxMDApOwogKiAgICAgfQogKiBdOwogKgogKiBhc3luYy5wYXJhbGxlbChhc3luYy5yZWZsZWN0QWxsKHRhc2tzKSwKICogLy8gb3B0aW9uYWwgY2FsbGJhY2sKICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyB2YWx1ZXMKICogICAgIC8vIHJlc3VsdHNbMF0udmFsdWUgPSAnb25lJwogKiAgICAgLy8gcmVzdWx0c1sxXS5lcnJvciA9IEVycm9yKCdiYWQgc3R1ZmYgaGFwcGVuZWQnKQogKiAgICAgLy8gcmVzdWx0c1syXS52YWx1ZSA9ICd0d28nCiAqIH0pOwogKgogKiAvLyBhbiBleGFtcGxlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5CiAqIGxldCB0YXNrcyA9IHsKICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7CiAqICAgICAgICAgfSwgMjAwKTsKICogICAgIH0sCiAqICAgICB0d286IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgY2FsbGJhY2soJ3R3bycpOwogKiAgICAgfSwKICogICAgIHRocmVlOiBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpOwogKiAgICAgICAgIH0sIDEwMCk7CiAqICAgICB9CiAqIH07CiAqCiAqIGFzeW5jLnBhcmFsbGVsKGFzeW5jLnJlZmxlY3RBbGwodGFza3MpLAogKiAvLyBvcHRpb25hbCBjYWxsYmFjawogKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIC8vIHZhbHVlcwogKiAgICAgLy8gcmVzdWx0cy5vbmUudmFsdWUgPSAnb25lJwogKiAgICAgLy8gcmVzdWx0cy50d28uZXJyb3IgPSAndHdvJwogKiAgICAgLy8gcmVzdWx0cy50aHJlZS52YWx1ZSA9ICd0aHJlZScKICogfSk7CiAqLwpmdW5jdGlvbiByZWZsZWN0QWxsKHRhc2tzKSB7CiAgICB2YXIgcmVzdWx0czsKICAgIGlmIChpc0FycmF5KHRhc2tzKSkgewogICAgICAgIHJlc3VsdHMgPSBhcnJheU1hcCh0YXNrcywgcmVmbGVjdCk7CiAgICB9IGVsc2UgewogICAgICAgIHJlc3VsdHMgPSB7fTsKICAgICAgICBiYXNlRm9yT3duKHRhc2tzLCBmdW5jdGlvbih0YXNrLCBrZXkpIHsKICAgICAgICAgICAgcmVzdWx0c1trZXldID0gcmVmbGVjdC5jYWxsKHRoaXMsIHRhc2spOwogICAgICAgIH0pOwogICAgfQogICAgcmV0dXJuIHJlc3VsdHM7Cn0KCmZ1bmN0aW9uIHJlamVjdCQxKGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIF9maWx0ZXIoZWFjaGZuLCBhcnIsIGZ1bmN0aW9uKHZhbHVlLCBjYikgewogICAgICAgIGl0ZXJhdGVlKHZhbHVlLCBmdW5jdGlvbihlcnIsIHYpIHsKICAgICAgICAgICAgY2IoZXJyLCAhdik7CiAgICAgICAgfSk7CiAgICB9LCBjYWxsYmFjayk7Cn0KCi8qKgogKiBUaGUgb3Bwb3NpdGUgb2YgW2BmaWx0ZXJgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfS4gUmVtb3ZlcyB2YWx1ZXMgdGhhdCBwYXNzIGFuIGBhc3luY2AgdHJ1dGggdGVzdC4KICoKICogQG5hbWUgcmVqZWN0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmZpbHRlcl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLnJlamVjdChbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHsKICogICAgIGZzLmFjY2VzcyhmaWxlUGF0aCwgZnVuY3Rpb24oZXJyKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycikKICogICAgIH0pOwogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIC8vIHJlc3VsdHMgbm93IGVxdWFscyBhbiBhcnJheSBvZiBtaXNzaW5nIGZpbGVzCiAqICAgICBjcmVhdGVGaWxlcyhyZXN1bHRzKTsKICogfSk7CiAqLwp2YXIgcmVqZWN0ID0gZG9QYXJhbGxlbChyZWplY3QkMSk7CgovKioKICogVGhlIHNhbWUgYXMgW2ByZWplY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEKICogdGltZS4KICoKICogQG5hbWUgcmVqZWN0TGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMucmVqZWN0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIFRoZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYXMgaXRzIGByZXN1bHRgLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLgogKi8KdmFyIHJlamVjdExpbWl0ID0gZG9QYXJhbGxlbExpbWl0KHJlamVjdCQxKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYHJlamVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgcmVqZWN0U2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnJlamVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH0KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqLwp2YXIgcmVqZWN0U2VyaWVzID0gZG9MaW1pdChyZWplY3RMaW1pdCwgMSk7CgovKioKICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAyLjQuMAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLgogKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi4KICogQGV4YW1wbGUKICoKICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpOwogKgogKiBjb25zb2xlLmxvZyhvYmplY3RzKTsKICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dCiAqCiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pOwogKiAvLyA9PiB0cnVlCiAqLwpmdW5jdGlvbiBjb25zdGFudCQxKHZhbHVlKSB7CiAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIHZhbHVlOwogIH07Cn0KCi8qKgogKiBBdHRlbXB0cyB0byBnZXQgYSBzdWNjZXNzZnVsIHJlc3BvbnNlIGZyb20gYHRhc2tgIG5vIG1vcmUgdGhhbiBgdGltZXNgIHRpbWVzCiAqIGJlZm9yZSByZXR1cm5pbmcgYW4gZXJyb3IuIElmIHRoZSB0YXNrIGlzIHN1Y2Nlc3NmdWwsIHRoZSBgY2FsbGJhY2tgIHdpbGwgYmUKICogcGFzc2VkIHRoZSByZXN1bHQgb2YgdGhlIHN1Y2Nlc3NmdWwgdGFzay4gSWYgYWxsIGF0dGVtcHRzIGZhaWwsIHRoZSBjYWxsYmFjawogKiB3aWxsIGJlIHBhc3NlZCB0aGUgZXJyb3IgYW5kIHJlc3VsdCAoaWYgYW55KSBvZiB0aGUgZmluYWwgYXR0ZW1wdC4KICoKICogQG5hbWUgcmV0cnkKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAc2VlIFthc3luYy5yZXRyeWFibGVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5yZXRyeWFibGV9CiAqIEBwYXJhbSB7T2JqZWN0fG51bWJlcn0gW29wdHMgPSB7dGltZXM6IDUsIGludGVydmFsOiAwfXwgNV0gLSBDYW4gYmUgZWl0aGVyIGFuCiAqIG9iamVjdCB3aXRoIGB0aW1lc2AgYW5kIGBpbnRlcnZhbGAgb3IgYSBudW1iZXIuCiAqICogYHRpbWVzYCAtIFRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdG8gbWFrZSBiZWZvcmUgZ2l2aW5nIHVwLiAgVGhlIGRlZmF1bHQKICogICBpcyBgNWAuCiAqICogYGludGVydmFsYCAtIFRoZSB0aW1lIHRvIHdhaXQgYmV0d2VlbiByZXRyaWVzLCBpbiBtaWxsaXNlY29uZHMuICBUaGUKICogICBkZWZhdWx0IGlzIGAwYC4gVGhlIGludGVydmFsIG1heSBhbHNvIGJlIHNwZWNpZmllZCBhcyBhIGZ1bmN0aW9uIG9mIHRoZQogKiAgIHJldHJ5IGNvdW50IChzZWUgZXhhbXBsZSkuCiAqICogYGVycm9yRmlsdGVyYCAtIEFuIG9wdGlvbmFsIHN5bmNocm9ub3VzIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCBvbgogKiAgIGVycm9uZW91cyByZXN1bHQuIElmIGl0IHJldHVybnMgYHRydWVgIHRoZSByZXRyeSBhdHRlbXB0cyB3aWxsIGNvbnRpbnVlOwogKiAgIGlmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAgdGhlIHJldHJ5IGZsb3cgaXMgYWJvcnRlZCB3aXRoIHRoZSBjdXJyZW50CiAqICAgYXR0ZW1wdCdzIGVycm9yIGFuZCByZXN1bHQgYmVpbmcgcmV0dXJuZWQgdG8gdGhlIGZpbmFsIGNhbGxiYWNrLgogKiAgIEludm9rZWQgd2l0aCAoZXJyKS4KICogKiBJZiBgb3B0c2AgaXMgYSBudW1iZXIsIHRoZSBudW1iZXIgc3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmV0cnksCiAqICAgd2l0aCB0aGUgZGVmYXVsdCBpbnRlcnZhbCBvZiBgMGAuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGFzayAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIHJldHJ5LgogKiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZQogKiB0YXNrIGhhcyBzdWNjZWVkZWQsIG9yIGFmdGVyIHRoZSBmaW5hbCBmYWlsZWQgYXR0ZW1wdC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgCiAqIGFuZCBgcmVzdWx0YCBhcmd1bWVudHMgb2YgdGhlIGxhc3QgYXR0ZW1wdCBhdCBjb21wbGV0aW5nIHRoZSBgdGFza2AuIEludm9rZWQKICogd2l0aCAoZXJyLCByZXN1bHRzKS4KICoKICogQGV4YW1wbGUKICoKICogLy8gVGhlIGByZXRyeWAgZnVuY3Rpb24gY2FuIGJlIHVzZWQgYXMgYSBzdGFuZC1hbG9uZSBjb250cm9sIGZsb3cgYnkgcGFzc2luZwogKiAvLyBhIGNhbGxiYWNrLCBhcyBzaG93biBiZWxvdzoKICoKICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDMgdGltZXMKICogYXN5bmMucmV0cnkoMywgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdAogKiB9KTsKICoKICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDMgdGltZXMsIHdhaXRpbmcgMjAwIG1zIGJldHdlZW4gZWFjaCByZXRyeQogKiBhc3luYy5yZXRyeSh7dGltZXM6IDMsIGludGVydmFsOiAyMDB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0CiAqIH0pOwogKgogKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMTAgdGltZXMgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmCiAqIC8vIChpLmUuIGludGVydmFscyBvZiAxMDAsIDIwMCwgNDAwLCA4MDAsIDE2MDAsIC4uLiBtaWxsaXNlY29uZHMpCiAqIGFzeW5jLnJldHJ5KHsKICogICB0aW1lczogMTAsCiAqICAgaW50ZXJ2YWw6IGZ1bmN0aW9uKHJldHJ5Q291bnQpIHsKICogICAgIHJldHVybiA1MCAqIE1hdGgucG93KDIsIHJldHJ5Q291bnQpOwogKiAgIH0KICogfSwgYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdAogKiB9KTsKICoKICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIHRoZSBkZWZhdWx0IDUgdGltZXMgbm8gZGVsYXkgYmV0d2VlbiBlYWNoIHJldHJ5CiAqIGFzeW5jLnJldHJ5KGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHQKICogfSk7CiAqCiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCBvbmx5IHdoZW4gZXJyb3IgY29uZGl0aW9uIHNhdGlzZmllcywgYWxsIG90aGVyCiAqIC8vIGVycm9ycyB3aWxsIGFib3J0IHRoZSByZXRyeSBjb250cm9sIGZsb3cgYW5kIHJldHVybiB0byBmaW5hbCBjYWxsYmFjawogKiBhc3luYy5yZXRyeSh7CiAqICAgZXJyb3JGaWx0ZXI6IGZ1bmN0aW9uKGVycikgewogKiAgICAgcmV0dXJuIGVyci5tZXNzYWdlID09PSAnVGVtcG9yYXJ5IGVycm9yJzsgLy8gb25seSByZXRyeSBvbiBhIHNwZWNpZmljIGVycm9yCiAqICAgfQogKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0CiAqIH0pOwogKgogKiAvLyB0byByZXRyeSBpbmRpdmlkdWFsIG1ldGhvZHMgdGhhdCBhcmUgbm90IGFzIHJlbGlhYmxlIHdpdGhpbiBvdGhlcgogKiAvLyBjb250cm9sIGZsb3cgZnVuY3Rpb25zLCB1c2UgdGhlIGByZXRyeWFibGVgIHdyYXBwZXI6CiAqIGFzeW5jLmF1dG8oewogKiAgICAgdXNlcnM6IGFwaS5nZXRVc2Vycy5iaW5kKGFwaSksCiAqICAgICBwYXltZW50czogYXN5bmMucmV0cnlhYmxlKDMsIGFwaS5nZXRQYXltZW50cy5iaW5kKGFwaSkpCiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdHMKICogfSk7CiAqCiAqLwpmdW5jdGlvbiByZXRyeShvcHRzLCB0YXNrLCBjYWxsYmFjaykgewogICAgdmFyIERFRkFVTFRfVElNRVMgPSA1OwogICAgdmFyIERFRkFVTFRfSU5URVJWQUwgPSAwOwoKICAgIHZhciBvcHRpb25zID0gewogICAgICAgIHRpbWVzOiBERUZBVUxUX1RJTUVTLAogICAgICAgIGludGVydmFsRnVuYzogY29uc3RhbnQkMShERUZBVUxUX0lOVEVSVkFMKQogICAgfTsKCiAgICBmdW5jdGlvbiBwYXJzZVRpbWVzKGFjYywgdCkgewogICAgICAgIGlmICh0eXBlb2YgdCA9PT0gJ29iamVjdCcpIHsKICAgICAgICAgICAgYWNjLnRpbWVzID0gK3QudGltZXMgfHwgREVGQVVMVF9USU1FUzsKCiAgICAgICAgICAgIGFjYy5pbnRlcnZhbEZ1bmMgPSB0eXBlb2YgdC5pbnRlcnZhbCA9PT0gJ2Z1bmN0aW9uJyA/CiAgICAgICAgICAgICAgICB0LmludGVydmFsIDoKICAgICAgICAgICAgICAgIGNvbnN0YW50JDEoK3QuaW50ZXJ2YWwgfHwgREVGQVVMVF9JTlRFUlZBTCk7CgogICAgICAgICAgICBhY2MuZXJyb3JGaWx0ZXIgPSB0LmVycm9yRmlsdGVyOwogICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHQgPT09ICdudW1iZXInIHx8IHR5cGVvZiB0ID09PSAnc3RyaW5nJykgewogICAgICAgICAgICBhY2MudGltZXMgPSArdCB8fCBERUZBVUxUX1RJTUVTOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgZm9yIGFzeW5jLnJldHJ5Iik7CiAgICAgICAgfQogICAgfQoKICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMyAmJiB0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgIGNhbGxiYWNrID0gdGFzayB8fCBub29wOwogICAgICAgIHRhc2sgPSBvcHRzOwogICAgfSBlbHNlIHsKICAgICAgICBwYXJzZVRpbWVzKG9wdGlvbnMsIG9wdHMpOwogICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDsKICAgIH0KCiAgICBpZiAodHlwZW9mIHRhc2sgIT09ICdmdW5jdGlvbicpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIGZvciBhc3luYy5yZXRyeSIpOwogICAgfQoKICAgIHZhciBfdGFzayA9IHdyYXBBc3luYyh0YXNrKTsKCiAgICB2YXIgYXR0ZW1wdCA9IDE7CiAgICBmdW5jdGlvbiByZXRyeUF0dGVtcHQoKSB7CiAgICAgICAgX3Rhc2soZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICAgIGlmIChlcnIgJiYgYXR0ZW1wdCsrIDwgb3B0aW9ucy50aW1lcyAmJgogICAgICAgICAgICAgICAgKHR5cGVvZiBvcHRpb25zLmVycm9yRmlsdGVyICE9ICdmdW5jdGlvbicgfHwKICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmVycm9yRmlsdGVyKGVycikpKSB7CiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJldHJ5QXR0ZW1wdCwgb3B0aW9ucy5pbnRlcnZhbEZ1bmMoYXR0ZW1wdCkpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwogICAgfQoKICAgIHJldHJ5QXR0ZW1wdCgpOwp9CgovKioKICogQSBjbG9zZSByZWxhdGl2ZSBvZiBbYHJldHJ5YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnJldHJ5fS4gIFRoaXMgbWV0aG9kCiAqIHdyYXBzIGEgdGFzayBhbmQgbWFrZXMgaXQgcmV0cnlhYmxlLCByYXRoZXIgdGhhbiBpbW1lZGlhdGVseSBjYWxsaW5nIGl0CiAqIHdpdGggcmV0cmllcy4KICoKICogQG5hbWUgcmV0cnlhYmxlCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnJldHJ5XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnl9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0cyA9IHt0aW1lczogNSwgaW50ZXJ2YWw6IDB9fCA1XSAtIG9wdGlvbmFsCiAqIG9wdGlvbnMsIGV4YWN0bHkgdGhlIHNhbWUgYXMgZnJvbSBgcmV0cnlgCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGFzayAtIHRoZSBhc3luY2hyb25vdXMgZnVuY3Rpb24gdG8gd3JhcC4KICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcmV0dXJuZWQgd3JhcHBlci4KICogSW52b2tlZCB3aXRoICguLi5hcmdzLCBjYWxsYmFjaykuCiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbiwgd2hpY2ggd2hlbiBpbnZva2VkLCB3aWxsCiAqIHJldHJ5IG9uIGFuIGVycm9yLCBiYXNlZCBvbiB0aGUgcGFyYW1ldGVycyBzcGVjaWZpZWQgaW4gYG9wdHNgLgogKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWNjZXB0IHRoZSBzYW1lIHBhcmFtZXRlcnMgYXMgYHRhc2tgLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5hdXRvKHsKICogICAgIGRlcDE6IGFzeW5jLnJldHJ5YWJsZSgzLCBnZXRGcm9tRmxha3lTZXJ2aWNlKSwKICogICAgIHByb2Nlc3M6IFsiZGVwMSIsIGFzeW5jLnJldHJ5YWJsZSgzLCBmdW5jdGlvbiAocmVzdWx0cywgY2IpIHsKICogICAgICAgICBtYXliZVByb2Nlc3NEYXRhKHJlc3VsdHMuZGVwMSwgY2IpOwogKiAgICAgfSldCiAqIH0sIGNhbGxiYWNrKTsKICovCnZhciByZXRyeWFibGUgPSBmdW5jdGlvbiAob3B0cywgdGFzaykgewogICAgaWYgKCF0YXNrKSB7CiAgICAgICAgdGFzayA9IG9wdHM7CiAgICAgICAgb3B0cyA9IG51bGw7CiAgICB9CiAgICB2YXIgX3Rhc2sgPSB3cmFwQXN5bmModGFzayk7CiAgICByZXR1cm4gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHsKICAgICAgICBmdW5jdGlvbiB0YXNrRm4oY2IpIHsKICAgICAgICAgICAgX3Rhc2suYXBwbHkobnVsbCwgYXJncy5jb25jYXQoY2IpKTsKICAgICAgICB9CgogICAgICAgIGlmIChvcHRzKSByZXRyeShvcHRzLCB0YXNrRm4sIGNhbGxiYWNrKTsKICAgICAgICBlbHNlIHJldHJ5KHRhc2tGbiwgY2FsbGJhY2spOwoKICAgIH0pOwp9OwoKLyoqCiAqIFJ1biB0aGUgZnVuY3Rpb25zIGluIHRoZSBgdGFza3NgIGNvbGxlY3Rpb24gaW4gc2VyaWVzLCBlYWNoIG9uZSBydW5uaW5nIG9uY2UKICogdGhlIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIElmIGFueSBmdW5jdGlvbnMgaW4gdGhlIHNlcmllcyBwYXNzIGFuCiAqIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgbm8gbW9yZSBmdW5jdGlvbnMgYXJlIHJ1biwgYW5kIGBjYWxsYmFja2AgaXMKICogaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIHZhbHVlIG9mIHRoZSBlcnJvci4gT3RoZXJ3aXNlLCBgY2FsbGJhY2tgCiAqIHJlY2VpdmVzIGFuIGFycmF5IG9mIHJlc3VsdHMgd2hlbiBgdGFza3NgIGhhdmUgY29tcGxldGVkLgogKgogKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHVzZSBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gRWFjaCBwcm9wZXJ0eSB3aWxsCiAqIGJlIHJ1biBhcyBhIGZ1bmN0aW9uLCBhbmQgdGhlIHJlc3VsdHMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZpbmFsIGBjYWxsYmFja2AKICogYXMgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkuIFRoaXMgY2FuIGJlIGEgbW9yZSByZWFkYWJsZSB3YXkgb2YgaGFuZGxpbmcKICogIHJlc3VsdHMgZnJvbSB7QGxpbmsgYXN5bmMuc2VyaWVzfS4KICoKICogKipOb3RlKiogdGhhdCB3aGlsZSBtYW55IGltcGxlbWVudGF0aW9ucyBwcmVzZXJ2ZSB0aGUgb3JkZXIgb2Ygb2JqZWN0CiAqIHByb3BlcnRpZXMsIHRoZSBbRUNNQVNjcmlwdCBMYW5ndWFnZSBTcGVjaWZpY2F0aW9uXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtOC42KQogKiBleHBsaWNpdGx5IHN0YXRlcyB0aGF0CiAqCiAqID4gVGhlIG1lY2hhbmljcyBhbmQgb3JkZXIgb2YgZW51bWVyYXRpbmcgdGhlIHByb3BlcnRpZXMgaXMgbm90IHNwZWNpZmllZC4KICoKICogU28gaWYgeW91IHJlbHkgb24gdGhlIG9yZGVyIGluIHdoaWNoIHlvdXIgc2VyaWVzIG9mIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWQsCiAqIGFuZCB3YW50IHRoaXMgdG8gd29yayBvbiBhbGwgcGxhdGZvcm1zLCBjb25zaWRlciB1c2luZyBhbiBhcnJheS4KICoKICogQG5hbWUgc2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIGNvbnRhaW5pbmcKICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuIGluIHNlcmllcy4KICogRWFjaCBmdW5jdGlvbiBjYW4gY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlcy4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGUKICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5IChvciBvYmplY3QpCiAqIGNvbnRhaW5pbmcgYWxsIHRoZSByZXN1bHQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgYHRhc2tgIGNhbGxiYWNrcy4gSW52b2tlZAogKiB3aXRoIChlcnIsIHJlc3VsdCkuCiAqIEBleGFtcGxlCiAqIGFzeW5jLnNlcmllcyhbCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIC8vIGRvIHNvbWUgc3R1ZmYgLi4uCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIC4uLgogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTsKICogICAgIH0KICogXSwKICogLy8gb3B0aW9uYWwgY2FsbGJhY2sKICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBlcXVhbCB0byBbJ29uZScsICd0d28nXQogKiB9KTsKICoKICogYXN5bmMuc2VyaWVzKHsKICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTsKICogICAgICAgICB9LCAyMDApOwogKiAgICAgfSwKICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpOwogKiAgICAgICAgIH0sIDEwMCk7CiAqICAgICB9CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgZXF1YWwgdG86IHtvbmU6IDEsIHR3bzogMn0KICogfSk7CiAqLwpmdW5jdGlvbiBzZXJpZXModGFza3MsIGNhbGxiYWNrKSB7CiAgICBfcGFyYWxsZWwoZWFjaE9mU2VyaWVzLCB0YXNrcywgY2FsbGJhY2spOwp9CgovKioKICogUmV0dXJucyBgdHJ1ZWAgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIGBjb2xsYCBzYXRpc2ZpZXMgYW4gYXN5bmMgdGVzdC4KICogSWYgYW55IGl0ZXJhdGVlIGNhbGwgcmV0dXJucyBgdHJ1ZWAsIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkKICogY2FsbGVkLgogKgogKiBAbmFtZSBzb21lCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBhbGlhcyBhbnkKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0KICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHBhcmFsbGVsLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIGByZXN1bHRgIHZhbHVlLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55CiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLgogKiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jCiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICogQGV4YW1wbGUKICoKICogYXN5bmMuc29tZShbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlUGF0aCwgY2FsbGJhY2spIHsKICogICAgIGZzLmFjY2VzcyhmaWxlUGF0aCwgZnVuY3Rpb24oZXJyKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgIWVycikKICogICAgIH0pOwogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gaWYgcmVzdWx0IGlzIHRydWUgdGhlbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZpbGVzIGV4aXN0cwogKiB9KTsKICovCnZhciBzb21lID0gZG9QYXJhbGxlbChfY3JlYXRlVGVzdGVyKEJvb2xlYW4sIGlkZW50aXR5KSk7CgovKioKICogVGhlIHNhbWUgYXMgW2Bzb21lYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKgogKiBAbmFtZSBzb21lTGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuc29tZV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9CiAqIEBhbGlhcyBhbnlMaW1pdAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtCiAqIGluIHRoZSBjb2xsZWN0aW9ucyBpbiBwYXJhbGxlbC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueQogKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4KICogUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luYwogKiB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuCiAqLwp2YXIgc29tZUxpbWl0ID0gZG9QYXJhbGxlbExpbWl0KF9jcmVhdGVUZXN0ZXIoQm9vbGVhbiwgaWRlbnRpdHkpKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYHNvbWVgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBzb21lU2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnNvbWVde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5zb21lfQogKiBAYWxpYXMgYW55U2VyaWVzCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtCiAqIGluIHRoZSBjb2xsZWN0aW9ucyBpbiBzZXJpZXMuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gYHJlc3VsdGAgdmFsdWUuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnkKICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuCiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMKICogdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKi8KdmFyIHNvbWVTZXJpZXMgPSBkb0xpbWl0KHNvbWVMaW1pdCwgMSk7CgovKioKICogU29ydHMgYSBsaXN0IGJ5IHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBgY29sbGAgdmFsdWUgdGhyb3VnaCBhbiBhc3luYwogKiBgaXRlcmF0ZWVgLgogKgogKiBAbmFtZSBzb3J0QnkKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgdmFsdWUgdG8gdXNlIGFzIHRoZSBzb3J0IGNyaXRlcmlhIGFzCiAqIGl0cyBgcmVzdWx0YC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdHMgaXMgdGhlIGl0ZW1zCiAqIGZyb20gdGhlIG9yaWdpbmFsIGBjb2xsYCBzb3J0ZWQgYnkgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgYGl0ZXJhdGVlYAogKiBjYWxscy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5zb3J0QnkoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2spIHsKICogICAgIGZzLnN0YXQoZmlsZSwgZnVuY3Rpb24oZXJyLCBzdGF0cykgewogKiAgICAgICAgIGNhbGxiYWNrKGVyciwgc3RhdHMubXRpbWUpOwogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gcmVzdWx0cyBpcyBub3cgdGhlIG9yaWdpbmFsIGFycmF5IG9mIGZpbGVzIHNvcnRlZCBieQogKiAgICAgLy8gbW9kaWZpZWQgZGF0ZQogKiB9KTsKICoKICogLy8gQnkgbW9kaWZ5aW5nIHRoZSBjYWxsYmFjayBwYXJhbWV0ZXIgdGhlCiAqIC8vIHNvcnRpbmcgb3JkZXIgY2FuIGJlIGluZmx1ZW5jZWQ6CiAqCiAqIC8vIGFzY2VuZGluZyBvcmRlcgogKiBhc3luYy5zb3J0QnkoWzEsOSwzLDVdLCBmdW5jdGlvbih4LCBjYWxsYmFjaykgewogKiAgICAgY2FsbGJhY2sobnVsbCwgeCk7CiAqIH0sIGZ1bmN0aW9uKGVycixyZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBjYWxsYmFjawogKiB9KTsKICoKICogLy8gZGVzY2VuZGluZyBvcmRlcgogKiBhc3luYy5zb3J0QnkoWzEsOSwzLDVdLCBmdW5jdGlvbih4LCBjYWxsYmFjaykgewogKiAgICAgY2FsbGJhY2sobnVsbCwgeCotMSk7ICAgIC8vPC0geCotMSBpbnN0ZWFkIG9mIHgsIHR1cm5zIHRoZSBvcmRlciBhcm91bmQKICogfSwgZnVuY3Rpb24oZXJyLHJlc3VsdCkgewogKiAgICAgLy8gcmVzdWx0IGNhbGxiYWNrCiAqIH0pOwogKi8KZnVuY3Rpb24gc29ydEJ5IChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwogICAgbWFwKGNvbGwsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykgewogICAgICAgIF9pdGVyYXRlZSh4LCBmdW5jdGlvbiAoZXJyLCBjcml0ZXJpYSkgewogICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge3ZhbHVlOiB4LCBjcml0ZXJpYTogY3JpdGVyaWF9KTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHsKICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICBjYWxsYmFjayhudWxsLCBhcnJheU1hcChyZXN1bHRzLnNvcnQoY29tcGFyYXRvciksIGJhc2VQcm9wZXJ0eSgndmFsdWUnKSkpOwogICAgfSk7CgogICAgZnVuY3Rpb24gY29tcGFyYXRvcihsZWZ0LCByaWdodCkgewogICAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYSwgYiA9IHJpZ2h0LmNyaXRlcmlhOwogICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDsKICAgIH0KfQoKLyoqCiAqIFNldHMgYSB0aW1lIGxpbWl0IG9uIGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGRvZXMgbm90IGNhbGwKICogaXRzIGNhbGxiYWNrIHdpdGhpbiB0aGUgc3BlY2lmaWVkIG1pbGxpc2Vjb25kcywgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhCiAqIHRpbWVvdXQgZXJyb3IuIFRoZSBjb2RlIHByb3BlcnR5IGZvciB0aGUgZXJyb3Igb2JqZWN0IHdpbGwgYmUgYCdFVElNRURPVVQnYC4KICoKICogQG5hbWUgdGltZW91dAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGFzeW5jRm4gLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gbGltaXQgaW4gdGltZS4KICogQHBhcmFtIHtudW1iZXJ9IG1pbGxpc2Vjb25kcyAtIFRoZSBzcGVjaWZpZWQgdGltZSBsaW1pdC4KICogQHBhcmFtIHsqfSBbaW5mb10gLSBBbnkgdmFyaWFibGUgeW91IHdhbnQgYXR0YWNoZWQgKGBzdHJpbmdgLCBgb2JqZWN0YCwgZXRjKQogKiB0byB0aW1lb3V0IEVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLi4KICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSB3cmFwcGVkIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBhbnkKICogb2YgdGhlIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMuCiAqIEludm9rZSB0aGlzIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgcGFyYW1ldGVycyBhcyB5b3Ugd291bGQgYGFzeW5jRnVuY2AuCiAqIEBleGFtcGxlCiAqCiAqIGZ1bmN0aW9uIG15RnVuY3Rpb24oZm9vLCBjYWxsYmFjaykgewogKiAgICAgZG9Bc3luY1Rhc2soZm9vLCBmdW5jdGlvbihlcnIsIGRhdGEpIHsKICogICAgICAgICAvLyBoYW5kbGUgZXJyb3JzCiAqICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAqCiAqICAgICAgICAgLy8gZG8gc29tZSBzdHVmZiAuLi4KICoKICogICAgICAgICAvLyByZXR1cm4gcHJvY2Vzc2VkIGRhdGEKICogICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZGF0YSk7CiAqICAgICB9KTsKICogfQogKgogKiB2YXIgd3JhcHBlZCA9IGFzeW5jLnRpbWVvdXQobXlGdW5jdGlvbiwgMTAwMCk7CiAqCiAqIC8vIGNhbGwgYHdyYXBwZWRgIGFzIHlvdSB3b3VsZCBgbXlGdW5jdGlvbmAKICogd3JhcHBlZCh7IGJhcjogJ2JhcicgfSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7CiAqICAgICAvLyBpZiBgbXlGdW5jdGlvbmAgdGFrZXMgPCAxMDAwIG1zIHRvIGV4ZWN1dGUsIGBlcnJgCiAqICAgICAvLyBhbmQgYGRhdGFgIHdpbGwgaGF2ZSB0aGVpciBleHBlY3RlZCB2YWx1ZXMKICoKICogICAgIC8vIGVsc2UgYGVycmAgd2lsbCBiZSBhbiBFcnJvciB3aXRoIHRoZSBjb2RlICdFVElNRURPVVQnCiAqIH0pOwogKi8KZnVuY3Rpb24gdGltZW91dChhc3luY0ZuLCBtaWxsaXNlY29uZHMsIGluZm8pIHsKICAgIHZhciBmbiA9IHdyYXBBc3luYyhhc3luY0ZuKTsKCiAgICByZXR1cm4gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHsKICAgICAgICB2YXIgdGltZWRPdXQgPSBmYWxzZTsKICAgICAgICB2YXIgdGltZXI7CgogICAgICAgIGZ1bmN0aW9uIHRpbWVvdXRDYWxsYmFjaygpIHsKICAgICAgICAgICAgdmFyIG5hbWUgPSBhc3luY0ZuLm5hbWUgfHwgJ2Fub255bW91cyc7CiAgICAgICAgICAgIHZhciBlcnJvciAgPSBuZXcgRXJyb3IoJ0NhbGxiYWNrIGZ1bmN0aW9uICInICsgbmFtZSArICciIHRpbWVkIG91dC4nKTsKICAgICAgICAgICAgZXJyb3IuY29kZSA9ICdFVElNRURPVVQnOwogICAgICAgICAgICBpZiAoaW5mbykgewogICAgICAgICAgICAgICAgZXJyb3IuaW5mbyA9IGluZm87CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGltZWRPdXQgPSB0cnVlOwogICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7CiAgICAgICAgfQoKICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKCkgewogICAgICAgICAgICBpZiAoIXRpbWVkT3V0KSB7CiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpOwogICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwoKICAgICAgICAvLyBzZXR1cCB0aW1lciBhbmQgY2FsbCBvcmlnaW5hbCBmdW5jdGlvbgogICAgICAgIHRpbWVyID0gc2V0VGltZW91dCh0aW1lb3V0Q2FsbGJhY2ssIG1pbGxpc2Vjb25kcyk7CiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7CiAgICB9KTsKfQoKLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqLwp2YXIgbmF0aXZlQ2VpbCA9IE1hdGguY2VpbDsKdmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4OwoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndAogKiBjb2VyY2UgYXJndW1lbnRzLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS4KICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS4KICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuCiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuCiAqLwpmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7CiAgdmFyIGluZGV4ID0gLTEsCiAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLAogICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpOwoKICB3aGlsZSAobGVuZ3RoLS0pIHsKICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0OwogICAgc3RhcnQgKz0gc3RlcDsKICB9CiAgcmV0dXJuIHJlc3VsdDsKfQoKLyoqCiAqIFRoZSBzYW1lIGFzIFt0aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEKICogdGltZS4KICoKICogQG5hbWUgdGltZXNMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy50aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIGNhbGwgYG5gIHRpbWVzLgogKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfS4KICovCmZ1bmN0aW9uIHRpbWVMaW1pdChjb3VudCwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CiAgICBtYXBMaW1pdChiYXNlUmFuZ2UoMCwgY291bnQsIDEpLCBsaW1pdCwgX2l0ZXJhdGVlLCBjYWxsYmFjayk7Cn0KCi8qKgogKiBDYWxscyB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbiBgbmAgdGltZXMsIGFuZCBhY2N1bXVsYXRlcyByZXN1bHRzIGluIHRoZSBzYW1lCiAqIG1hbm5lciB5b3Ugd291bGQgdXNlIHdpdGggW21hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uCiAqCiAqIEBuYW1lIHRpbWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBjYWxsIGBuYCB0aW1lcy4KICogSW52b2tlZCB3aXRoIHRoZSBpdGVyYXRpb24gaW5kZXggYW5kIGEgY2FsbGJhY2s6IChuLCBuZXh0KS4KICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LgogKiBAZXhhbXBsZQogKgogKiAvLyBQcmV0ZW5kIHRoaXMgaXMgc29tZSBjb21wbGljYXRlZCBhc3luYyBmYWN0b3J5CiAqIHZhciBjcmVhdGVVc2VyID0gZnVuY3Rpb24oaWQsIGNhbGxiYWNrKSB7CiAqICAgICBjYWxsYmFjayhudWxsLCB7CiAqICAgICAgICAgaWQ6ICd1c2VyJyArIGlkCiAqICAgICB9KTsKICogfTsKICoKICogLy8gZ2VuZXJhdGUgNSB1c2VycwogKiBhc3luYy50aW1lcyg1LCBmdW5jdGlvbihuLCBuZXh0KSB7CiAqICAgICBjcmVhdGVVc2VyKG4sIGZ1bmN0aW9uKGVyciwgdXNlcikgewogKiAgICAgICAgIG5leHQoZXJyLCB1c2VyKTsKICogICAgIH0pOwogKiB9LCBmdW5jdGlvbihlcnIsIHVzZXJzKSB7CiAqICAgICAvLyB3ZSBzaG91bGQgbm93IGhhdmUgNSB1c2VycwogKiB9KTsKICovCnZhciB0aW1lcyA9IGRvTGltaXQodGltZUxpbWl0LCBJbmZpbml0eSk7CgovKioKICogVGhlIHNhbWUgYXMgW3RpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgdGltZXNTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMudGltZXNde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy50aW1lc30KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcnVuIHRoZSBmdW5jdGlvbi4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBjYWxsIGBuYCB0aW1lcy4KICogSW52b2tlZCB3aXRoIHRoZSBpdGVyYXRpb24gaW5kZXggYW5kIGEgY2FsbGJhY2s6IChuLCBuZXh0KS4KICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBzZWUge0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LgogKi8KdmFyIHRpbWVzU2VyaWVzID0gZG9MaW1pdCh0aW1lTGltaXQsIDEpOwoKLyoqCiAqIEEgcmVsYXRpdmUgb2YgYHJlZHVjZWAuICBUYWtlcyBhbiBPYmplY3Qgb3IgQXJyYXksIGFuZCBpdGVyYXRlcyBvdmVyIGVhY2gKICogZWxlbWVudCBpbiBzZXJpZXMsIGVhY2ggc3RlcCBwb3RlbnRpYWxseSBtdXRhdGluZyBhbiBgYWNjdW11bGF0b3JgIHZhbHVlLgogKiBUaGUgdHlwZSBvZiB0aGUgYWNjdW11bGF0b3IgZGVmYXVsdHMgdG8gdGhlIHR5cGUgb2YgY29sbGVjdGlvbiBwYXNzZWQgaW4uCiAqCiAqIEBuYW1lIHRyYW5zZm9ybQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSB0cmFuc2Zvcm0uICBJZiBvbWl0dGVkLAogKiBpdCB3aWxsIGRlZmF1bHQgdG8gYW4gZW1wdHkgT2JqZWN0IG9yIEFycmF5LCBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgYGNvbGxgCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIGFwcGxpZWQgdG8gZWFjaCBpdGVtIGluIHRoZQogKiBjb2xsZWN0aW9uIHRoYXQgcG90ZW50aWFsbHkgbW9kaWZpZXMgdGhlIGFjY3VtdWxhdG9yLgogKiBJbnZva2VkIHdpdGggKGFjY3VtdWxhdG9yLCBpdGVtLCBrZXksIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gUmVzdWx0IGlzIHRoZSB0cmFuc2Zvcm1lZCBhY2N1bXVsYXRvci4KICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLnRyYW5zZm9ybShbMSwyLDNdLCBmdW5jdGlvbihhY2MsIGl0ZW0sIGluZGV4LCBjYWxsYmFjaykgewogKiAgICAgLy8gcG9pbnRsZXNzIGFzeW5jOgogKiAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHsKICogICAgICAgICBhY2MucHVzaChpdGVtICogMikKICogICAgICAgICBjYWxsYmFjayhudWxsKQogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgaXMgbm93IGVxdWFsIHRvIFsyLCA0LCA2XQogKiB9KTsKICoKICogQGV4YW1wbGUKICoKICogYXN5bmMudHJhbnNmb3JtKHthOiAxLCBiOiAyLCBjOiAzfSwgZnVuY3Rpb24gKG9iaiwgdmFsLCBrZXksIGNhbGxiYWNrKSB7CiAqICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkgewogKiAgICAgICAgIG9ialtrZXldID0gdmFsICogMjsKICogICAgICAgICBjYWxsYmFjaygpOwogKiAgICAgfSkKICogfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgaXMgZXF1YWwgdG8ge2E6IDIsIGI6IDQsIGM6IDZ9CiAqIH0pCiAqLwpmdW5jdGlvbiB0cmFuc2Zvcm0gKGNvbGwsIGFjY3VtdWxhdG9yLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDMpIHsKICAgICAgICBjYWxsYmFjayA9IGl0ZXJhdGVlOwogICAgICAgIGl0ZXJhdGVlID0gYWNjdW11bGF0b3I7CiAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FycmF5KGNvbGwpID8gW10gOiB7fTsKICAgIH0KICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwoKICAgIGVhY2hPZihjb2xsLCBmdW5jdGlvbih2LCBrLCBjYikgewogICAgICAgIF9pdGVyYXRlZShhY2N1bXVsYXRvciwgdiwgaywgY2IpOwogICAgfSwgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgY2FsbGJhY2soZXJyLCBhY2N1bXVsYXRvcik7CiAgICB9KTsKfQoKLyoqCiAqIEl0IHJ1bnMgZWFjaCB0YXNrIGluIHNlcmllcyBidXQgc3RvcHMgd2hlbmV2ZXIgYW55IG9mIHRoZSBmdW5jdGlvbnMgd2VyZQogKiBzdWNjZXNzZnVsLiBJZiBvbmUgb2YgdGhlIHRhc2tzIHdlcmUgc3VjY2Vzc2Z1bCwgdGhlIGBjYWxsYmFja2Agd2lsbCBiZQogKiBwYXNzZWQgdGhlIHJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCB0YXNrLiBJZiBhbGwgdGFza3MgZmFpbCwgdGhlIGNhbGxiYWNrCiAqIHdpbGwgYmUgcGFzc2VkIHRoZSBlcnJvciBhbmQgcmVzdWx0IChpZiBhbnkpIG9mIHRoZSBmaW5hbCBhdHRlbXB0LgogKgogKiBAbmFtZSB0cnlFYWNoCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IHRhc2tzIC0gQSBjb2xsZWN0aW9uIGNvbnRhaW5pbmcgZnVuY3Rpb25zIHRvCiAqIHJ1biwgZWFjaCBmdW5jdGlvbiBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCByZXN1bHQpYCBpdCBtdXN0IGNhbGwgb24KICogY29tcGxldGlvbiB3aXRoIGFuIGVycm9yIGBlcnJgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgYW4gb3B0aW9uYWwgYHJlc3VsdGAKICogdmFsdWUuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBvbmUKICogb2YgdGhlIHRhc2tzIGhhcyBzdWNjZWVkZWQsIG9yIGFsbCBoYXZlIGZhaWxlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFuZAogKiBgcmVzdWx0YCBhcmd1bWVudHMgb2YgdGhlIGxhc3QgYXR0ZW1wdCBhdCBjb21wbGV0aW5nIHRoZSBgdGFza2AuIEludm9rZWQgd2l0aAogKiAoZXJyLCByZXN1bHRzKS4KICogQGV4YW1wbGUKICogYXN5bmMudHJ5RWFjaChbCiAqICAgICBmdW5jdGlvbiBnZXREYXRhRnJvbUZpcnN0V2Vic2l0ZShjYWxsYmFjaykgewogKiAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSBkYXRhIGZyb20gdGhlIGZpcnN0IHdlYnNpdGUKICogICAgICAgICBjYWxsYmFjayhlcnIsIGRhdGEpOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uIGdldERhdGFGcm9tU2Vjb25kV2Vic2l0ZShjYWxsYmFjaykgewogKiAgICAgICAgIC8vIEZpcnN0IHdlYnNpdGUgZmFpbGVkLAogKiAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSBkYXRhIGZyb20gdGhlIGJhY2t1cCB3ZWJzaXRlCiAqICAgICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTsKICogICAgIH0KICogXSwKICogLy8gb3B0aW9uYWwgY2FsbGJhY2sKICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICBOb3cgZG8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuCiAqIH0pOwogKgogKi8KZnVuY3Rpb24gdHJ5RWFjaCh0YXNrcywgY2FsbGJhY2spIHsKICAgIHZhciBlcnJvciA9IG51bGw7CiAgICB2YXIgcmVzdWx0OwogICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wOwogICAgZWFjaFNlcmllcyh0YXNrcywgZnVuY3Rpb24odGFzaywgY2FsbGJhY2spIHsKICAgICAgICB3cmFwQXN5bmModGFzaykoZnVuY3Rpb24gKGVyciwgcmVzLyosIC4uLmFyZ3MqLykgewogICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXM7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZXJyb3IgPSBlcnI7CiAgICAgICAgICAgIGNhbGxiYWNrKCFlcnIpOwogICAgICAgIH0pOwogICAgfSwgZnVuY3Rpb24gKCkgewogICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpOwogICAgfSk7Cn0KCi8qKgogKiBVbmRvZXMgYSBbbWVtb2l6ZV17QGxpbmsgbW9kdWxlOlV0aWxzLm1lbW9pemV9ZCBmdW5jdGlvbiwgcmV2ZXJ0aW5nIGl0IHRvIHRoZSBvcmlnaW5hbCwKICogdW5tZW1vaXplZCBmb3JtLiBIYW5keSBmb3IgdGVzdGluZy4KICoKICogQG5hbWUgdW5tZW1vaXplCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLm1lbW9pemVde0BsaW5rIG1vZHVsZTpVdGlscy5tZW1vaXplfQogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gdGhlIG1lbW9pemVkIGZ1bmN0aW9uCiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIG9yaWdpbmFsIHVubWVtb2l6ZWQgZnVuY3Rpb24KICovCmZ1bmN0aW9uIHVubWVtb2l6ZShmbikgewogICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gKGZuLnVubWVtb2l6ZWQgfHwgZm4pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7CiAgICB9Owp9CgovKioKICogUmVwZWF0ZWRseSBjYWxsIGBpdGVyYXRlZWAsIHdoaWxlIGB0ZXN0YCByZXR1cm5zIGB0cnVlYC4gQ2FsbHMgYGNhbGxiYWNrYCB3aGVuCiAqIHN0b3BwZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4KICoKICogQG5hbWUgd2hpbHN0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtGdW5jdGlvbn0gdGVzdCAtIHN5bmNocm9ub3VzIHRydXRoIHRlc3QgdG8gcGVyZm9ybSBiZWZvcmUgZWFjaAogKiBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYC4gSW52b2tlZCB3aXRoICgpLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZQogKiBgdGVzdGAgcGFzc2VzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0CiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgCiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzCiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTsKICogQHJldHVybnMgdW5kZWZpbmVkCiAqIEBleGFtcGxlCiAqCiAqIHZhciBjb3VudCA9IDA7CiAqIGFzeW5jLndoaWxzdCgKICogICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gY291bnQgPCA1OyB9LAogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBjb3VudCsrOwogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNvdW50KTsKICogICAgICAgICB9LCAxMDAwKTsKICogICAgIH0sCiAqICAgICBmdW5jdGlvbiAoZXJyLCBuKSB7CiAqICAgICAgICAgLy8gNSBzZWNvbmRzIGhhdmUgcGFzc2VkLCBuID0gNQogKiAgICAgfQogKiApOwogKi8KZnVuY3Rpb24gd2hpbHN0KHRlc3QsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgY2FsbGJhY2sgPSBvbmx5T25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwogICAgaWYgKCF0ZXN0KCkpIHJldHVybiBjYWxsYmFjayhudWxsKTsKICAgIHZhciBuZXh0ID0gZnVuY3Rpb24oZXJyLyosIC4uLmFyZ3MqLykgewogICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgIGlmICh0ZXN0KCkpIHJldHVybiBfaXRlcmF0ZWUobmV4dCk7CiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIFtudWxsXS5jb25jYXQoYXJncykpOwogICAgfTsKICAgIF9pdGVyYXRlZShuZXh0KTsKfQoKLyoqCiAqIFJlcGVhdGVkbHkgY2FsbCBgaXRlcmF0ZWVgIHVudGlsIGB0ZXN0YCByZXR1cm5zIGB0cnVlYC4gQ2FsbHMgYGNhbGxiYWNrYCB3aGVuCiAqIHN0b3BwZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYGNhbGxiYWNrYCB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55CiAqIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZpbmFsIGBpdGVyYXRlZWAncyBjYWxsYmFjay4KICoKICogVGhlIGludmVyc2Ugb2YgW3doaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0uCiAqCiAqIEBuYW1lIHVudGlsCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLndoaWxzdF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0IC0gc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoCiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKCkuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lCiAqIGB0ZXN0YCBmYWlscy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdAogKiBmdW5jdGlvbiBoYXMgcGFzc2VkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYAogKiB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZpbmFsIGBpdGVyYXRlZWAncwogKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSk7CiAqLwpmdW5jdGlvbiB1bnRpbCh0ZXN0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIHdoaWxzdChmdW5jdGlvbigpIHsKICAgICAgICByZXR1cm4gIXRlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgIH0sIGl0ZXJhdGVlLCBjYWxsYmFjayk7Cn0KCi8qKgogKiBSdW5zIHRoZSBgdGFza3NgIGFycmF5IG9mIGZ1bmN0aW9ucyBpbiBzZXJpZXMsIGVhY2ggcGFzc2luZyB0aGVpciByZXN1bHRzIHRvCiAqIHRoZSBuZXh0IGluIHRoZSBhcnJheS4gSG93ZXZlciwgaWYgYW55IG9mIHRoZSBgdGFza3NgIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXIKICogb3duIGNhbGxiYWNrLCB0aGUgbmV4dCBmdW5jdGlvbiBpcyBub3QgZXhlY3V0ZWQsIGFuZCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzCiAqIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci4KICoKICogQG5hbWUgd2F0ZXJmYWxsCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheX0gdGFza3MgLSBBbiBhcnJheSBvZiBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufQogKiB0byBydW4uCiAqIEVhY2ggZnVuY3Rpb24gc2hvdWxkIGNvbXBsZXRlIHdpdGggYW55IG51bWJlciBvZiBgcmVzdWx0YCB2YWx1ZXMuCiAqIFRoZSBgcmVzdWx0YCB2YWx1ZXMgd2lsbCBiZSBwYXNzZWQgYXMgYXJndW1lbnRzLCBpbiBvcmRlciwgdG8gdGhlIG5leHQgdGFzay4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIHJ1biBvbmNlIGFsbCB0aGUKICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIHdpbGwgYmUgcGFzc2VkIHRoZSByZXN1bHRzIG9mIHRoZSBsYXN0IHRhc2sncwogKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSkuCiAqIEByZXR1cm5zIHVuZGVmaW5lZAogKiBAZXhhbXBsZQogKgogKiBhc3luYy53YXRlcmZhbGwoWwogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJywgJ3R3bycpOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gYXJnMSBub3cgZXF1YWxzICdvbmUnIGFuZCBhcmcyIG5vdyBlcXVhbHMgJ3R3bycKICogICAgICAgICBjYWxsYmFjayhudWxsLCAndGhyZWUnKTsKICogICAgIH0sCiAqICAgICBmdW5jdGlvbihhcmcxLCBjYWxsYmFjaykgewogKiAgICAgICAgIC8vIGFyZzEgbm93IGVxdWFscyAndGhyZWUnCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RvbmUnKTsKICogICAgIH0KICogXSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZScKICogfSk7CiAqCiAqIC8vIE9yLCB3aXRoIG5hbWVkIGZ1bmN0aW9uczoKICogYXN5bmMud2F0ZXJmYWxsKFsKICogICAgIG15Rmlyc3RGdW5jdGlvbiwKICogICAgIG15U2Vjb25kRnVuY3Rpb24sCiAqICAgICBteUxhc3RGdW5jdGlvbiwKICogXSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZScKICogfSk7CiAqIGZ1bmN0aW9uIG15Rmlyc3RGdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScsICd0d28nKTsKICogfQogKiBmdW5jdGlvbiBteVNlY29uZEZ1bmN0aW9uKGFyZzEsIGFyZzIsIGNhbGxiYWNrKSB7CiAqICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ29uZScgYW5kIGFyZzIgbm93IGVxdWFscyAndHdvJwogKiAgICAgY2FsbGJhY2sobnVsbCwgJ3RocmVlJyk7CiAqIH0KICogZnVuY3Rpb24gbXlMYXN0RnVuY3Rpb24oYXJnMSwgY2FsbGJhY2spIHsKICogICAgIC8vIGFyZzEgbm93IGVxdWFscyAndGhyZWUnCiAqICAgICBjYWxsYmFjayhudWxsLCAnZG9uZScpOwogKiB9CiAqLwp2YXIgd2F0ZXJmYWxsID0gZnVuY3Rpb24odGFza3MsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7CiAgICBpZiAoIWlzQXJyYXkodGFza3MpKSByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byB3YXRlcmZhbGwgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKSk7CiAgICBpZiAoIXRhc2tzLmxlbmd0aCkgcmV0dXJuIGNhbGxiYWNrKCk7CiAgICB2YXIgdGFza0luZGV4ID0gMDsKCiAgICBmdW5jdGlvbiBuZXh0VGFzayhhcmdzKSB7CiAgICAgICAgdmFyIHRhc2sgPSB3cmFwQXN5bmModGFza3NbdGFza0luZGV4KytdKTsKICAgICAgICBhcmdzLnB1c2gob25seU9uY2UobmV4dCkpOwogICAgICAgIHRhc2suYXBwbHkobnVsbCwgYXJncyk7CiAgICB9CgogICAgZnVuY3Rpb24gbmV4dChlcnIvKiwgLi4uYXJncyovKSB7CiAgICAgICAgaWYgKGVyciB8fCB0YXNrSW5kZXggPT09IHRhc2tzLmxlbmd0aCkgewogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTsKICAgICAgICB9CiAgICAgICAgbmV4dFRhc2soc2xpY2UoYXJndW1lbnRzLCAxKSk7CiAgICB9CgogICAgbmV4dFRhc2soW10pOwp9OwoKLyoqCiAqIEFuICJhc3luYyBmdW5jdGlvbiIgaW4gdGhlIGNvbnRleHQgb2YgQXN5bmMgaXMgYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uIHdpdGgKICogYSB2YXJpYWJsZSBudW1iZXIgb2YgcGFyYW1ldGVycywgd2l0aCB0aGUgZmluYWwgcGFyYW1ldGVyIGJlaW5nIGEgY2FsbGJhY2suCiAqIChgZnVuY3Rpb24gKGFyZzEsIGFyZzIsIC4uLiwgY2FsbGJhY2spIHt9YCkKICogVGhlIGZpbmFsIGNhbGxiYWNrIGlzIG9mIHRoZSBmb3JtIGBjYWxsYmFjayhlcnIsIHJlc3VsdHMuLi4pYCwgd2hpY2ggbXVzdCBiZQogKiBjYWxsZWQgb25jZSB0aGUgZnVuY3Rpb24gaXMgY29tcGxldGVkLiAgVGhlIGNhbGxiYWNrIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBhCiAqIEVycm9yIGFzIGl0cyBmaXJzdCBhcmd1bWVudCB0byBzaWduYWwgdGhhdCBhbiBlcnJvciBvY2N1cnJlZC4KICogT3RoZXJ3aXNlLCBpZiBubyBlcnJvciBvY2N1cnJlZCwgaXQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGBudWxsYCBhcyB0aGUgZmlyc3QKICogYXJndW1lbnQsIGFuZCBhbnkgYWRkaXRpb25hbCBgcmVzdWx0YCBhcmd1bWVudHMgdGhhdCBtYXkgYXBwbHksIHRvIHNpZ25hbAogKiBzdWNjZXNzZnVsIGNvbXBsZXRpb24uCiAqIFRoZSBjYWxsYmFjayBtdXN0IGJlIGNhbGxlZCBleGFjdGx5IG9uY2UsIGlkZWFsbHkgb24gYSBsYXRlciB0aWNrIG9mIHRoZQogKiBKYXZhU2NyaXB0IGV2ZW50IGxvb3AuCiAqCiAqIFRoaXMgdHlwZSBvZiBmdW5jdGlvbiBpcyBhbHNvIHJlZmVycmVkIHRvIGFzIGEgIk5vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb24iLAogKiBvciBhICJjb250aW51YXRpb24gcGFzc2luZy1zdHlsZSBmdW5jdGlvbiIgKENQUykuIE1vc3Qgb2YgdGhlIG1ldGhvZHMgb2YgdGhpcwogKiBsaWJyYXJ5IGFyZSB0aGVtc2VsdmVzIENQUy9Ob2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9ucywgb3IgZnVuY3Rpb25zIHRoYXQKICogcmV0dXJuIENQUy9Ob2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9ucy4KICoKICogV2hlcmV2ZXIgd2UgYWNjZXB0IGEgTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvbiwgd2UgYWxzbyBkaXJlY3RseSBhY2NlcHQgYW4KICogW0VTMjAxNyBgYXN5bmNgIGZ1bmN0aW9uXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9TdGF0ZW1lbnRzL2FzeW5jX2Z1bmN0aW9ufS4KICogSW4gdGhpcyBjYXNlLCB0aGUgYGFzeW5jYCBmdW5jdGlvbiB3aWxsIG5vdCBiZSBwYXNzZWQgYSBmaW5hbCBjYWxsYmFjawogKiBhcmd1bWVudCwgYW5kIGFueSB0aHJvd24gZXJyb3Igd2lsbCBiZSB1c2VkIGFzIHRoZSBgZXJyYCBhcmd1bWVudCBvZiB0aGUKICogaW1wbGljaXQgY2FsbGJhY2ssIGFuZCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgYHJlc3VsdGAgdmFsdWUuCiAqIChpLmUuIGEgYHJlamVjdGVkYCBvZiB0aGUgcmV0dXJuZWQgUHJvbWlzZSBiZWNvbWVzIHRoZSBgZXJyYCBjYWxsYmFjawogKiBhcmd1bWVudCwgYW5kIGEgYHJlc29sdmVkYCB2YWx1ZSBiZWNvbWVzIHRoZSBgcmVzdWx0YC4pCiAqCiAqIE5vdGUsIGR1ZSB0byBKYXZhU2NyaXB0IGxpbWl0YXRpb25zLCB3ZSBjYW4gb25seSBkZXRlY3QgbmF0aXZlIGBhc3luY2AKICogZnVuY3Rpb25zIGFuZCBub3QgdHJhbnNwaWxpZWQgaW1wbGVtZW50YXRpb25zLgogKiBZb3VyIGVudmlyb25tZW50IG11c3QgaGF2ZSBgYXN5bmNgL2Bhd2FpdGAgc3VwcG9ydCBmb3IgdGhpcyB0byB3b3JrLgogKiAoZS5nLiBOb2RlID4gdjcuNiwgb3IgYSByZWNlbnQgdmVyc2lvbiBvZiBhIG1vZGVybiBicm93c2VyKS4KICogSWYgeW91IGFyZSB1c2luZyBgYXN5bmNgIGZ1bmN0aW9ucyB0aHJvdWdoIGEgdHJhbnNwaWxlciAoZS5nLiBCYWJlbCksIHlvdQogKiBtdXN0IHN0aWxsIHdyYXAgdGhlIGZ1bmN0aW9uIHdpdGggW2FzeW5jaWZ5XXtAbGluayBtb2R1bGU6VXRpbHMuYXN5bmNpZnl9LAogKiBiZWNhdXNlIHRoZSBgYXN5bmMgZnVuY3Rpb25gIHdpbGwgYmUgY29tcGlsZWQgdG8gYW4gb3JkaW5hcnkgZnVuY3Rpb24gdGhhdAogKiByZXR1cm5zIGEgcHJvbWlzZS4KICoKICogQHR5cGVkZWYge0Z1bmN0aW9ufSBBc3luY0Z1bmN0aW9uCiAqIEBzdGF0aWMKICovCgovKioKICogQXN5bmMgaXMgYSB1dGlsaXR5IG1vZHVsZSB3aGljaCBwcm92aWRlcyBzdHJhaWdodC1mb3J3YXJkLCBwb3dlcmZ1bCBmdW5jdGlvbnMKICogZm9yIHdvcmtpbmcgd2l0aCBhc3luY2hyb25vdXMgSmF2YVNjcmlwdC4gQWx0aG91Z2ggb3JpZ2luYWxseSBkZXNpZ25lZCBmb3IKICogdXNlIHdpdGggW05vZGUuanNdKGh0dHA6Ly9ub2RlanMub3JnKSBhbmQgaW5zdGFsbGFibGUgdmlhCiAqIGBucG0gaW5zdGFsbCAtLXNhdmUgYXN5bmNgLCBpdCBjYW4gYWxzbyBiZSB1c2VkIGRpcmVjdGx5IGluIHRoZSBicm93c2VyLgogKiBAbW9kdWxlIGFzeW5jCiAqIEBzZWUgQXN5bmNGdW5jdGlvbgogKi8KCgovKioKICogQSBjb2xsZWN0aW9uIG9mIGBhc3luY2AgZnVuY3Rpb25zIGZvciBtYW5pcHVsYXRpbmcgY29sbGVjdGlvbnMsIHN1Y2ggYXMKICogYXJyYXlzIGFuZCBvYmplY3RzLgogKiBAbW9kdWxlIENvbGxlY3Rpb25zCiAqLwoKLyoqCiAqIEEgY29sbGVjdGlvbiBvZiBgYXN5bmNgIGZ1bmN0aW9ucyBmb3IgY29udHJvbGxpbmcgdGhlIGZsb3cgdGhyb3VnaCBhIHNjcmlwdC4KICogQG1vZHVsZSBDb250cm9sRmxvdwogKi8KCi8qKgogKiBBIGNvbGxlY3Rpb24gb2YgYGFzeW5jYCB1dGlsaXR5IGZ1bmN0aW9ucy4KICogQG1vZHVsZSBVdGlscwogKi8KCnZhciBpbmRleCA9IHsKICAgIGFwcGx5OiBhcHBseSwKICAgIGFwcGx5RWFjaDogYXBwbHlFYWNoLAogICAgYXBwbHlFYWNoU2VyaWVzOiBhcHBseUVhY2hTZXJpZXMsCiAgICBhc3luY2lmeTogYXN5bmNpZnksCiAgICBhdXRvOiBhdXRvLAogICAgYXV0b0luamVjdDogYXV0b0luamVjdCwKICAgIGNhcmdvOiBjYXJnbywKICAgIGNvbXBvc2U6IGNvbXBvc2UsCiAgICBjb25jYXQ6IGNvbmNhdCwKICAgIGNvbmNhdExpbWl0OiBjb25jYXRMaW1pdCwKICAgIGNvbmNhdFNlcmllczogY29uY2F0U2VyaWVzLAogICAgY29uc3RhbnQ6IGNvbnN0YW50LAogICAgZGV0ZWN0OiBkZXRlY3QsCiAgICBkZXRlY3RMaW1pdDogZGV0ZWN0TGltaXQsCiAgICBkZXRlY3RTZXJpZXM6IGRldGVjdFNlcmllcywKICAgIGRpcjogZGlyLAogICAgZG9EdXJpbmc6IGRvRHVyaW5nLAogICAgZG9VbnRpbDogZG9VbnRpbCwKICAgIGRvV2hpbHN0OiBkb1doaWxzdCwKICAgIGR1cmluZzogZHVyaW5nLAogICAgZWFjaDogZWFjaExpbWl0LAogICAgZWFjaExpbWl0OiBlYWNoTGltaXQkMSwKICAgIGVhY2hPZjogZWFjaE9mLAogICAgZWFjaE9mTGltaXQ6IGVhY2hPZkxpbWl0LAogICAgZWFjaE9mU2VyaWVzOiBlYWNoT2ZTZXJpZXMsCiAgICBlYWNoU2VyaWVzOiBlYWNoU2VyaWVzLAogICAgZW5zdXJlQXN5bmM6IGVuc3VyZUFzeW5jLAogICAgZXZlcnk6IGV2ZXJ5LAogICAgZXZlcnlMaW1pdDogZXZlcnlMaW1pdCwKICAgIGV2ZXJ5U2VyaWVzOiBldmVyeVNlcmllcywKICAgIGZpbHRlcjogZmlsdGVyLAogICAgZmlsdGVyTGltaXQ6IGZpbHRlckxpbWl0LAogICAgZmlsdGVyU2VyaWVzOiBmaWx0ZXJTZXJpZXMsCiAgICBmb3JldmVyOiBmb3JldmVyLAogICAgZ3JvdXBCeTogZ3JvdXBCeSwKICAgIGdyb3VwQnlMaW1pdDogZ3JvdXBCeUxpbWl0LAogICAgZ3JvdXBCeVNlcmllczogZ3JvdXBCeVNlcmllcywKICAgIGxvZzogbG9nLAogICAgbWFwOiBtYXAsCiAgICBtYXBMaW1pdDogbWFwTGltaXQsCiAgICBtYXBTZXJpZXM6IG1hcFNlcmllcywKICAgIG1hcFZhbHVlczogbWFwVmFsdWVzLAogICAgbWFwVmFsdWVzTGltaXQ6IG1hcFZhbHVlc0xpbWl0LAogICAgbWFwVmFsdWVzU2VyaWVzOiBtYXBWYWx1ZXNTZXJpZXMsCiAgICBtZW1vaXplOiBtZW1vaXplLAogICAgbmV4dFRpY2s6IG5leHRUaWNrLAogICAgcGFyYWxsZWw6IHBhcmFsbGVsTGltaXQsCiAgICBwYXJhbGxlbExpbWl0OiBwYXJhbGxlbExpbWl0JDEsCiAgICBwcmlvcml0eVF1ZXVlOiBwcmlvcml0eVF1ZXVlLAogICAgcXVldWU6IHF1ZXVlJDEsCiAgICByYWNlOiByYWNlLAogICAgcmVkdWNlOiByZWR1Y2UsCiAgICByZWR1Y2VSaWdodDogcmVkdWNlUmlnaHQsCiAgICByZWZsZWN0OiByZWZsZWN0LAogICAgcmVmbGVjdEFsbDogcmVmbGVjdEFsbCwKICAgIHJlamVjdDogcmVqZWN0LAogICAgcmVqZWN0TGltaXQ6IHJlamVjdExpbWl0LAogICAgcmVqZWN0U2VyaWVzOiByZWplY3RTZXJpZXMsCiAgICByZXRyeTogcmV0cnksCiAgICByZXRyeWFibGU6IHJldHJ5YWJsZSwKICAgIHNlcTogc2VxLAogICAgc2VyaWVzOiBzZXJpZXMsCiAgICBzZXRJbW1lZGlhdGU6IHNldEltbWVkaWF0ZSQxLAogICAgc29tZTogc29tZSwKICAgIHNvbWVMaW1pdDogc29tZUxpbWl0LAogICAgc29tZVNlcmllczogc29tZVNlcmllcywKICAgIHNvcnRCeTogc29ydEJ5LAogICAgdGltZW91dDogdGltZW91dCwKICAgIHRpbWVzOiB0aW1lcywKICAgIHRpbWVzTGltaXQ6IHRpbWVMaW1pdCwKICAgIHRpbWVzU2VyaWVzOiB0aW1lc1NlcmllcywKICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLAogICAgdHJ5RWFjaDogdHJ5RWFjaCwKICAgIHVubWVtb2l6ZTogdW5tZW1vaXplLAogICAgdW50aWw6IHVudGlsLAogICAgd2F0ZXJmYWxsOiB3YXRlcmZhbGwsCiAgICB3aGlsc3Q6IHdoaWxzdCwKCiAgICAvLyBhbGlhc2VzCiAgICBhbGw6IGV2ZXJ5LAogICAgYWxsTGltaXQ6IGV2ZXJ5TGltaXQsCiAgICBhbGxTZXJpZXM6IGV2ZXJ5U2VyaWVzLAogICAgYW55OiBzb21lLAogICAgYW55TGltaXQ6IHNvbWVMaW1pdCwKICAgIGFueVNlcmllczogc29tZVNlcmllcywKICAgIGZpbmQ6IGRldGVjdCwKICAgIGZpbmRMaW1pdDogZGV0ZWN0TGltaXQsCiAgICBmaW5kU2VyaWVzOiBkZXRlY3RTZXJpZXMsCiAgICBmb3JFYWNoOiBlYWNoTGltaXQsCiAgICBmb3JFYWNoU2VyaWVzOiBlYWNoU2VyaWVzLAogICAgZm9yRWFjaExpbWl0OiBlYWNoTGltaXQkMSwKICAgIGZvckVhY2hPZjogZWFjaE9mLAogICAgZm9yRWFjaE9mU2VyaWVzOiBlYWNoT2ZTZXJpZXMsCiAgICBmb3JFYWNoT2ZMaW1pdDogZWFjaE9mTGltaXQsCiAgICBpbmplY3Q6IHJlZHVjZSwKICAgIGZvbGRsOiByZWR1Y2UsCiAgICBmb2xkcjogcmVkdWNlUmlnaHQsCiAgICBzZWxlY3Q6IGZpbHRlciwKICAgIHNlbGVjdExpbWl0OiBmaWx0ZXJMaW1pdCwKICAgIHNlbGVjdFNlcmllczogZmlsdGVyU2VyaWVzLAogICAgd3JhcFN5bmM6IGFzeW5jaWZ5Cn07CgpleHBvcnRzWydkZWZhdWx0J10gPSBpbmRleDsKZXhwb3J0cy5hcHBseSA9IGFwcGx5OwpleHBvcnRzLmFwcGx5RWFjaCA9IGFwcGx5RWFjaDsKZXhwb3J0cy5hcHBseUVhY2hTZXJpZXMgPSBhcHBseUVhY2hTZXJpZXM7CmV4cG9ydHMuYXN5bmNpZnkgPSBhc3luY2lmeTsKZXhwb3J0cy5hdXRvID0gYXV0bzsKZXhwb3J0cy5hdXRvSW5qZWN0ID0gYXV0b0luamVjdDsKZXhwb3J0cy5jYXJnbyA9IGNhcmdvOwpleHBvcnRzLmNvbXBvc2UgPSBjb21wb3NlOwpleHBvcnRzLmNvbmNhdCA9IGNvbmNhdDsKZXhwb3J0cy5jb25jYXRMaW1pdCA9IGNvbmNhdExpbWl0OwpleHBvcnRzLmNvbmNhdFNlcmllcyA9IGNvbmNhdFNlcmllczsKZXhwb3J0cy5jb25zdGFudCA9IGNvbnN0YW50OwpleHBvcnRzLmRldGVjdCA9IGRldGVjdDsKZXhwb3J0cy5kZXRlY3RMaW1pdCA9IGRldGVjdExpbWl0OwpleHBvcnRzLmRldGVjdFNlcmllcyA9IGRldGVjdFNlcmllczsKZXhwb3J0cy5kaXIgPSBkaXI7CmV4cG9ydHMuZG9EdXJpbmcgPSBkb0R1cmluZzsKZXhwb3J0cy5kb1VudGlsID0gZG9VbnRpbDsKZXhwb3J0cy5kb1doaWxzdCA9IGRvV2hpbHN0OwpleHBvcnRzLmR1cmluZyA9IGR1cmluZzsKZXhwb3J0cy5lYWNoID0gZWFjaExpbWl0OwpleHBvcnRzLmVhY2hMaW1pdCA9IGVhY2hMaW1pdCQxOwpleHBvcnRzLmVhY2hPZiA9IGVhY2hPZjsKZXhwb3J0cy5lYWNoT2ZMaW1pdCA9IGVhY2hPZkxpbWl0OwpleHBvcnRzLmVhY2hPZlNlcmllcyA9IGVhY2hPZlNlcmllczsKZXhwb3J0cy5lYWNoU2VyaWVzID0gZWFjaFNlcmllczsKZXhwb3J0cy5lbnN1cmVBc3luYyA9IGVuc3VyZUFzeW5jOwpleHBvcnRzLmV2ZXJ5ID0gZXZlcnk7CmV4cG9ydHMuZXZlcnlMaW1pdCA9IGV2ZXJ5TGltaXQ7CmV4cG9ydHMuZXZlcnlTZXJpZXMgPSBldmVyeVNlcmllczsKZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7CmV4cG9ydHMuZmlsdGVyTGltaXQgPSBmaWx0ZXJMaW1pdDsKZXhwb3J0cy5maWx0ZXJTZXJpZXMgPSBmaWx0ZXJTZXJpZXM7CmV4cG9ydHMuZm9yZXZlciA9IGZvcmV2ZXI7CmV4cG9ydHMuZ3JvdXBCeSA9IGdyb3VwQnk7CmV4cG9ydHMuZ3JvdXBCeUxpbWl0ID0gZ3JvdXBCeUxpbWl0OwpleHBvcnRzLmdyb3VwQnlTZXJpZXMgPSBncm91cEJ5U2VyaWVzOwpleHBvcnRzLmxvZyA9IGxvZzsKZXhwb3J0cy5tYXAgPSBtYXA7CmV4cG9ydHMubWFwTGltaXQgPSBtYXBMaW1pdDsKZXhwb3J0cy5tYXBTZXJpZXMgPSBtYXBTZXJpZXM7CmV4cG9ydHMubWFwVmFsdWVzID0gbWFwVmFsdWVzOwpleHBvcnRzLm1hcFZhbHVlc0xpbWl0ID0gbWFwVmFsdWVzTGltaXQ7CmV4cG9ydHMubWFwVmFsdWVzU2VyaWVzID0gbWFwVmFsdWVzU2VyaWVzOwpleHBvcnRzLm1lbW9pemUgPSBtZW1vaXplOwpleHBvcnRzLm5leHRUaWNrID0gbmV4dFRpY2s7CmV4cG9ydHMucGFyYWxsZWwgPSBwYXJhbGxlbExpbWl0OwpleHBvcnRzLnBhcmFsbGVsTGltaXQgPSBwYXJhbGxlbExpbWl0JDE7CmV4cG9ydHMucHJpb3JpdHlRdWV1ZSA9IHByaW9yaXR5UXVldWU7CmV4cG9ydHMucXVldWUgPSBxdWV1ZSQxOwpleHBvcnRzLnJhY2UgPSByYWNlOwpleHBvcnRzLnJlZHVjZSA9IHJlZHVjZTsKZXhwb3J0cy5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0OwpleHBvcnRzLnJlZmxlY3QgPSByZWZsZWN0OwpleHBvcnRzLnJlZmxlY3RBbGwgPSByZWZsZWN0QWxsOwpleHBvcnRzLnJlamVjdCA9IHJlamVjdDsKZXhwb3J0cy5yZWplY3RMaW1pdCA9IHJlamVjdExpbWl0OwpleHBvcnRzLnJlamVjdFNlcmllcyA9IHJlamVjdFNlcmllczsKZXhwb3J0cy5yZXRyeSA9IHJldHJ5OwpleHBvcnRzLnJldHJ5YWJsZSA9IHJldHJ5YWJsZTsKZXhwb3J0cy5zZXEgPSBzZXE7CmV4cG9ydHMuc2VyaWVzID0gc2VyaWVzOwpleHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZSQxOwpleHBvcnRzLnNvbWUgPSBzb21lOwpleHBvcnRzLnNvbWVMaW1pdCA9IHNvbWVMaW1pdDsKZXhwb3J0cy5zb21lU2VyaWVzID0gc29tZVNlcmllczsKZXhwb3J0cy5zb3J0QnkgPSBzb3J0Qnk7CmV4cG9ydHMudGltZW91dCA9IHRpbWVvdXQ7CmV4cG9ydHMudGltZXMgPSB0aW1lczsKZXhwb3J0cy50aW1lc0xpbWl0ID0gdGltZUxpbWl0OwpleHBvcnRzLnRpbWVzU2VyaWVzID0gdGltZXNTZXJpZXM7CmV4cG9ydHMudHJhbnNmb3JtID0gdHJhbnNmb3JtOwpleHBvcnRzLnRyeUVhY2ggPSB0cnlFYWNoOwpleHBvcnRzLnVubWVtb2l6ZSA9IHVubWVtb2l6ZTsKZXhwb3J0cy51bnRpbCA9IHVudGlsOwpleHBvcnRzLndhdGVyZmFsbCA9IHdhdGVyZmFsbDsKZXhwb3J0cy53aGlsc3QgPSB3aGlsc3Q7CmV4cG9ydHMuYWxsID0gZXZlcnk7CmV4cG9ydHMuYWxsTGltaXQgPSBldmVyeUxpbWl0OwpleHBvcnRzLmFsbFNlcmllcyA9IGV2ZXJ5U2VyaWVzOwpleHBvcnRzLmFueSA9IHNvbWU7CmV4cG9ydHMuYW55TGltaXQgPSBzb21lTGltaXQ7CmV4cG9ydHMuYW55U2VyaWVzID0gc29tZVNlcmllczsKZXhwb3J0cy5maW5kID0gZGV0ZWN0OwpleHBvcnRzLmZpbmRMaW1pdCA9IGRldGVjdExpbWl0OwpleHBvcnRzLmZpbmRTZXJpZXMgPSBkZXRlY3RTZXJpZXM7CmV4cG9ydHMuZm9yRWFjaCA9IGVhY2hMaW1pdDsKZXhwb3J0cy5mb3JFYWNoU2VyaWVzID0gZWFjaFNlcmllczsKZXhwb3J0cy5mb3JFYWNoTGltaXQgPSBlYWNoTGltaXQkMTsKZXhwb3J0cy5mb3JFYWNoT2YgPSBlYWNoT2Y7CmV4cG9ydHMuZm9yRWFjaE9mU2VyaWVzID0gZWFjaE9mU2VyaWVzOwpleHBvcnRzLmZvckVhY2hPZkxpbWl0ID0gZWFjaE9mTGltaXQ7CmV4cG9ydHMuaW5qZWN0ID0gcmVkdWNlOwpleHBvcnRzLmZvbGRsID0gcmVkdWNlOwpleHBvcnRzLmZvbGRyID0gcmVkdWNlUmlnaHQ7CmV4cG9ydHMuc2VsZWN0ID0gZmlsdGVyOwpleHBvcnRzLnNlbGVjdExpbWl0ID0gZmlsdGVyTGltaXQ7CmV4cG9ydHMuc2VsZWN0U2VyaWVzID0gZmlsdGVyU2VyaWVzOwpleHBvcnRzLndyYXBTeW5jID0gYXN5bmNpZnk7CgpPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pOwoKfSkpKTsKCn0pLmNhbGwodGhpcyxfZGVyZXFfKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiID8gd2luZG93IDoge30pCn0seyJfcHJvY2VzcyI6OTl9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSB7ICJkZWZhdWx0IjogX2RlcmVxXygiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5IiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeSI6MTh9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSB7ICJkZWZhdWx0IjogX2RlcmVxXygiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24iKSwgX19lc01vZHVsZTogdHJ1ZSB9Owp9LHsiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ24iOjE5fV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0geyAiZGVmYXVsdCI6IF9kZXJlcV8oImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlIiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlIjoyMH1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IHsgImRlZmF1bHQiOiBfZGVyZXFfKCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eSIpLCBfX2VzTW9kdWxlOiB0cnVlIH07Cn0seyJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eSI6MjF9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSB7ICJkZWZhdWx0IjogX2RlcmVxXygiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mIiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZiI6MjJ9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0geyAiZGVmYXVsdCI6IF9kZXJlcV8oImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZiIpLCBfX2VzTW9kdWxlOiB0cnVlIH07Cn0seyJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YiOjIzfV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IHsgImRlZmF1bHQiOiBfZGVyZXFfKCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sIiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wiOjI0fV0sMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IHsgImRlZmF1bHQiOiBfZGVyZXFfKCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yIiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IiOjI1fV0sMTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewoidXNlIHN0cmljdCI7CgpleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwoKZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgewogIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICB9Cn07Cn0se31dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKInVzZSBzdHJpY3QiOwoKZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKCnZhciBfZGVmaW5lUHJvcGVydHkgPSBfZGVyZXFfKCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHkiKTsKCnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpOwoKZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0KCmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHsKICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsKICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsKICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOwogICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7CiAgICAgIGlmICgidmFsdWUiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOwogICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsKICAgIH0KICB9CgogIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7CiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOwogICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7CiAgICByZXR1cm4gQ29uc3RydWN0b3I7CiAgfTsKfSgpOwp9LHsiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5Ijo4fV0sMTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewoidXNlIHN0cmljdCI7CgpleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOwoKdmFyIF9zZXRQcm90b3R5cGVPZiA9IF9kZXJlcV8oIi4uL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YiKTsKCnZhciBfc2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0UHJvdG90eXBlT2YpOwoKdmFyIF9jcmVhdGUgPSBfZGVyZXFfKCIuLi9jb3JlLWpzL29iamVjdC9jcmVhdGUiKTsKCnZhciBfY3JlYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZSk7Cgp2YXIgX3R5cGVvZjIgPSBfZGVyZXFfKCIuLi9oZWxwZXJzL3R5cGVvZiIpOwoKdmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7CgpmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfQoKZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7CiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAiZnVuY3Rpb24iICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgIiArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpOwogIH0KCiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsKICAgIGNvbnN0cnVjdG9yOiB7CiAgICAgIHZhbHVlOiBzdWJDbGFzcywKICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICBjb25maWd1cmFibGU6IHRydWUKICAgIH0KICB9KTsKICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0ID8gKDAsIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsKfTsKfSx7Ii4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZSI6NywiLi4vY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZiI6MTAsIi4uL2hlbHBlcnMvdHlwZW9mIjoxN31dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKInVzZSBzdHJpY3QiOwoKZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKCnZhciBfdHlwZW9mMiA9IF9kZXJlcV8oIi4uL2hlbHBlcnMvdHlwZW9mIik7Cgp2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTsKCmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9CgpleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkgewogIGlmICghc2VsZikgewogICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWQiKTsKICB9CgogIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSAib2JqZWN0IiB8fCB0eXBlb2YgY2FsbCA9PT0gImZ1bmN0aW9uIikgPyBjYWxsIDogc2VsZjsKfTsKfSx7Ii4uL2hlbHBlcnMvdHlwZW9mIjoxN31dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKInVzZSBzdHJpY3QiOwoKZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKCnZhciBfaXRlcmF0b3IgPSBfZGVyZXFfKCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvciIpOwoKdmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7Cgp2YXIgX3N5bWJvbCA9IF9kZXJlcV8oIi4uL2NvcmUtanMvc3ltYm9sIik7Cgp2YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpOwoKdmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gImZ1bmN0aW9uIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSAic3ltYm9sIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09ICJmdW5jdGlvbiIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyAic3ltYm9sIiA6IHR5cGVvZiBvYmo7IH07CgpmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfQoKZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09ICJmdW5jdGlvbiIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSAic3ltYm9sIiA/IGZ1bmN0aW9uIChvYmopIHsKICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2Yob2JqKTsKfSA6IGZ1bmN0aW9uIChvYmopIHsKICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSAiZnVuY3Rpb24iICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gInN5bWJvbCIgOiB0eXBlb2Ygb2JqID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogX3R5cGVvZihvYmopOwp9Owp9LHsiLi4vY29yZS1qcy9zeW1ib2wiOjExLCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvciI6MTJ9XSwxODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBjb3JlID0gX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9fY29yZScpOwp2YXIgJEpTT04gPSBjb3JlLkpTT04gfHwgKGNvcmUuSlNPTiA9IHsgc3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeSB9KTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycwogIHJldHVybiAkSlNPTi5zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3VtZW50cyk7Cn07Cgp9LHsiLi4vLi4vbW9kdWxlcy9fY29yZSI6MzF9XSwxOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cl9kZXJlcV8oJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjsKCn0seyIuLi8uLi9tb2R1bGVzL19jb3JlIjozMSwiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbiI6ODV9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cl9kZXJlcV8oJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTsKdmFyICRPYmplY3QgPSBfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0Owptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKSB7CiAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpOwp9OwoKfSx7Ii4uLy4uL21vZHVsZXMvX2NvcmUiOjMxLCIuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlIjo4Nn1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpOwp2YXIgJE9iamVjdCA9IF9kZXJlcV8oJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykgewogIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpOwp9OwoKfSx7Ii4uLy4uL21vZHVsZXMvX2NvcmUiOjMxLCIuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Ijo4N31dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mOwoKfSx7Ii4uLy4uL21vZHVsZXMvX2NvcmUiOjMxLCIuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZiI6ODh9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cl9kZXJlcV8oJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7Cm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjsKCn0seyIuLi8uLi9tb2R1bGVzL19jb3JlIjozMSwiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YiOjg5fV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpOwpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuU3ltYm9sOwoKfSx7Ii4uLy4uL21vZHVsZXMvX2NvcmUiOjMxLCIuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nIjo5MCwiLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sIjo5MiwiLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yIjo5MywiLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUiOjk0fV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7Cm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCcpLmYoJ2l0ZXJhdG9yJyk7Cgp9LHsiLi4vLi4vbW9kdWxlcy9fd2tzLWV4dCI6ODIsIi4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvciI6OTEsIi4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZSI6OTV9XSwyNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpOwogIHJldHVybiBpdDsKfTsKCn0se31dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07Cgp9LHt9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBpc09iamVjdCA9IF9kZXJlcV8oJy4vX2lzLW9iamVjdCcpOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogIGlmICghaXNPYmplY3QoaXQpKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhbiBvYmplY3QhJyk7CiAgcmV0dXJuIGl0Owp9OwoKfSx7Ii4vX2lzLW9iamVjdCI6NDd9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2YKLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXMKdmFyIHRvSU9iamVjdCA9IF9kZXJlcV8oJy4vX3RvLWlvYmplY3QnKTsKdmFyIHRvTGVuZ3RoID0gX2RlcmVxXygnLi9fdG8tbGVuZ3RoJyk7CnZhciB0b0Fic29sdXRlSW5kZXggPSBfZGVyZXFfKCcuL190by1hYnNvbHV0ZS1pbmRleCcpOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykgewogIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHsKICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTsKICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7CiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpOwogICAgdmFyIHZhbHVlOwogICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobQogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZQogICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHsKICAgICAgdmFsdWUgPSBPW2luZGV4KytdOwogICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlCiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7CiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90CiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7CiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwOwogICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xOwogIH07Cn07Cgp9LHsiLi9fdG8tYWJzb2x1dGUtaW5kZXgiOjc0LCIuL190by1pb2JqZWN0Ijo3NiwiLi9fdG8tbGVuZ3RoIjo3N31dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7Cgptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7Cn07Cgp9LHt9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMycgfTsKaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYKCn0se31dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nCnZhciBhRnVuY3Rpb24gPSBfZGVyZXFfKCcuL19hLWZ1bmN0aW9uJyk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHsKICBhRnVuY3Rpb24oZm4pOwogIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjsKICBzd2l0Y2ggKGxlbmd0aCkgewogICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHsKICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7CiAgICB9OwogICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHsKICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7CiAgICB9OwogICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHsKICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7CiAgICB9OwogIH0KICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHsKICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpOwogIH07Cn07Cgp9LHsiLi9fYS1mdW5jdGlvbiI6MjZ9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpCm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgIiArIGl0KTsKICByZXR1cm4gaXQ7Cn07Cgp9LHt9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHkKbW9kdWxlLmV4cG9ydHMgPSAhX2RlcmVxXygnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7CiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7Cn0pOwoKfSx7Ii4vX2ZhaWxzIjozOX1dLDM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGlzT2JqZWN0ID0gX2RlcmVxXygnLi9faXMtb2JqZWN0Jyk7CnZhciBkb2N1bWVudCA9IF9kZXJlcV8oJy4vX2dsb2JhbCcpLmRvY3VtZW50OwovLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUUKdmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307Cn07Cgp9LHsiLi9fZ2xvYmFsIjo0MCwiLi9faXMtb2JqZWN0Ijo0N31dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5cwptb2R1bGUuZXhwb3J0cyA9ICgKICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJwopLnNwbGl0KCcsJyk7Cgp9LHt9XSwzNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzCnZhciBnZXRLZXlzID0gX2RlcmVxXygnLi9fb2JqZWN0LWtleXMnKTsKdmFyIGdPUFMgPSBfZGVyZXFfKCcuL19vYmplY3QtZ29wcycpOwp2YXIgcElFID0gX2RlcmVxXygnLi9fb2JqZWN0LXBpZScpOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogIHZhciByZXN1bHQgPSBnZXRLZXlzKGl0KTsKICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjsKICBpZiAoZ2V0U3ltYm9scykgewogICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTsKICAgIHZhciBpc0VudW0gPSBwSUUuZjsKICAgIHZhciBpID0gMDsKICAgIHZhciBrZXk7CiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7CiAgfSByZXR1cm4gcmVzdWx0Owp9OwoKfSx7Ii4vX29iamVjdC1nb3BzIjo2MSwiLi9fb2JqZWN0LWtleXMiOjY0LCIuL19vYmplY3QtcGllIjo2NX1dLDM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGdsb2JhbCA9IF9kZXJlcV8oJy4vX2dsb2JhbCcpOwp2YXIgY29yZSA9IF9kZXJlcV8oJy4vX2NvcmUnKTsKdmFyIGN0eCA9IF9kZXJlcV8oJy4vX2N0eCcpOwp2YXIgaGlkZSA9IF9kZXJlcV8oJy4vX2hpZGUnKTsKdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnOwoKdmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7CiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7CiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7CiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7CiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDsKICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7CiAgdmFyIElTX1dSQVAgPSB0eXBlICYgJGV4cG9ydC5XOwogIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7CiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdOwogIHZhciB0YXJnZXQgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdOwogIHZhciBrZXksIG93biwgb3V0OwogIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7CiAgZm9yIChrZXkgaW4gc291cmNlKSB7CiAgICAvLyBjb250YWlucyBpbiBuYXRpdmUKICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7CiAgICBpZiAob3duICYmIGtleSBpbiBleHBvcnRzKSBjb250aW51ZTsKICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkCiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldOwogICAgLy8gcHJldmVudCBnbG9iYWwgcG9sbHV0aW9uIGZvciBuYW1lc3BhY2VzCiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XQogICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHQKICAgIDogSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpCiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeQogICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykgewogICAgICB2YXIgRiA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7CiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7CiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHsKICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IEMoKTsKICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7CiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpOwogICAgICAgICAgfSByZXR1cm4gbmV3IEMoYSwgYiwgYyk7CiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICB9OwogICAgICBGW1BST1RPVFlQRV0gPSBDW1BST1RPVFlQRV07CiAgICAgIHJldHVybiBGOwogICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzCiAgICB9KShvdXQpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7CiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSUKICAgIGlmIChJU19QUk9UTykgewogICAgICAoZXhwb3J0cy52aXJ0dWFsIHx8IChleHBvcnRzLnZpcnR1YWwgPSB7fSkpW2tleV0gPSBvdXQ7CiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlCiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7CiAgICB9CiAgfQp9OwovLyB0eXBlIGJpdG1hcAokZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZAokZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbAokZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpYwokZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvCiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZAokZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXAKJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlCiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YAptb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7Cgp9LHsiLi9fY29yZSI6MzEsIi4vX2N0eCI6MzIsIi4vX2dsb2JhbCI6NDAsIi4vX2hpZGUiOjQyfV0sMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7CiAgdHJ5IHsKICAgIHJldHVybiAhIWV4ZWMoKTsKICB9IGNhdGNoIChlKSB7CiAgICByZXR1cm4gdHJ1ZTsKICB9Cn07Cgp9LHt9XSw0MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4CnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aAogID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmCiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jCiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpOwppZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmCgp9LHt9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5Owptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7CiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7Cn07Cgp9LHt9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBkUCA9IF9kZXJlcV8oJy4vX29iamVjdC1kcCcpOwp2YXIgY3JlYXRlRGVzYyA9IF9kZXJlcV8oJy4vX3Byb3BlcnR5LWRlc2MnKTsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkgewogIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7Cn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7CiAgb2JqZWN0W2tleV0gPSB2YWx1ZTsKICByZXR1cm4gb2JqZWN0Owp9OwoKfSx7Ii4vX2Rlc2NyaXB0b3JzIjozNCwiLi9fb2JqZWN0LWRwIjo1NiwiLi9fcHJvcGVydHktZGVzYyI6Njd9XSw0MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBkb2N1bWVudCA9IF9kZXJlcV8oJy4vX2dsb2JhbCcpLmRvY3VtZW50Owptb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsKCn0seyIuL19nbG9iYWwiOjQwfV0sNDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9ICFfZGVyZXFfKCcuL19kZXNjcmlwdG9ycycpICYmICFfZGVyZXFfKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHsKICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KF9kZXJlcV8oJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3Owp9KTsKCn0seyIuL19kZXNjcmlwdG9ycyI6MzQsIi4vX2RvbS1jcmVhdGUiOjM1LCIuL19mYWlscyI6Mzl9XSw0NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzCnZhciBjb2YgPSBfZGVyZXFfKCcuL19jb2YnKTsKLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucwptb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIGNvZihpdCkgPT0gJ1N0cmluZycgPyBpdC5zcGxpdCgnJykgOiBPYmplY3QoaXQpOwp9OwoKfSx7Ii4vX2NvZiI6MzB9XSw0NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpCnZhciBjb2YgPSBfZGVyZXFfKCcuL19jb2YnKTsKbW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7CiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7Cn07Cgp9LHsiLi9fY29mIjozMH1dLDQ3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nOwp9OwoKfSx7fV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7CnZhciBjcmVhdGUgPSBfZGVyZXFfKCcuL19vYmplY3QtY3JlYXRlJyk7CnZhciBkZXNjcmlwdG9yID0gX2RlcmVxXygnLi9fcHJvcGVydHktZGVzYycpOwp2YXIgc2V0VG9TdHJpbmdUYWcgPSBfZGVyZXFfKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpOwp2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsKCi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpCl9kZXJlcV8oJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgX2RlcmVxXygnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pOwoKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHsKICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTsKICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTsKfTsKCn0seyIuL19oaWRlIjo0MiwiLi9fb2JqZWN0LWNyZWF0ZSI6NTUsIi4vX3Byb3BlcnR5LWRlc2MiOjY3LCIuL19zZXQtdG8tc3RyaW5nLXRhZyI6NzAsIi4vX3drcyI6ODN9XSw0OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKdmFyIExJQlJBUlkgPSBfZGVyZXFfKCcuL19saWJyYXJ5Jyk7CnZhciAkZXhwb3J0ID0gX2RlcmVxXygnLi9fZXhwb3J0Jyk7CnZhciByZWRlZmluZSA9IF9kZXJlcV8oJy4vX3JlZGVmaW5lJyk7CnZhciBoaWRlID0gX2RlcmVxXygnLi9faGlkZScpOwp2YXIgaGFzID0gX2RlcmVxXygnLi9faGFzJyk7CnZhciBJdGVyYXRvcnMgPSBfZGVyZXFfKCcuL19pdGVyYXRvcnMnKTsKdmFyICRpdGVyQ3JlYXRlID0gX2RlcmVxXygnLi9faXRlci1jcmVhdGUnKTsKdmFyIHNldFRvU3RyaW5nVGFnID0gX2RlcmVxXygnLi9fc2V0LXRvLXN0cmluZy10YWcnKTsKdmFyIGdldFByb3RvdHlwZU9mID0gX2RlcmVxXygnLi9fb2JqZWN0LWdwbycpOwp2YXIgSVRFUkFUT1IgPSBfZGVyZXFfKCcuL193a3MnKSgnaXRlcmF0b3InKTsKdmFyIEJVR0dZID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpOyAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgCnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJzsKdmFyIEtFWVMgPSAna2V5cyc7CnZhciBWQUxVRVMgPSAndmFsdWVzJzsKCnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTsKCm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkgewogICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTsKICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24gKGtpbmQpIHsKICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdOwogICAgc3dpdGNoIChraW5kKSB7CiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07CiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9OwogICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTsKICB9OwogIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7CiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUzsKICB2YXIgVkFMVUVTX0JVRyA9IGZhbHNlOwogIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlOwogIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdOwogIHZhciAkZGVmYXVsdCA9ICghQlVHR1kgJiYgJG5hdGl2ZSkgfHwgZ2V0TWV0aG9kKERFRkFVTFQpOwogIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7CiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlOwogIHZhciBtZXRob2RzLCBrZXksIEl0ZXJhdG9yUHJvdG90eXBlOwogIC8vIEZpeCBuYXRpdmUKICBpZiAoJGFueU5hdGl2ZSkgewogICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UoKSkpOwogICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHsKICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9ycwogICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTsKICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzCiAgICAgIGlmICghTElCUkFSWSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTsKICAgIH0KICB9CiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRgogIGlmIChERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpIHsKICAgIFZBTFVFU19CVUcgPSB0cnVlOwogICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07CiAgfQogIC8vIERlZmluZSBpdGVyYXRvcgogIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkgewogICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTsKICB9CiAgLy8gUGx1ZyBmb3IgbGlicmFyeQogIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0OwogIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpczsKICBpZiAoREVGQVVMVCkgewogICAgbWV0aG9kcyA9IHsKICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSwKICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksCiAgICAgIGVudHJpZXM6ICRlbnRyaWVzCiAgICB9OwogICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykgewogICAgICBpZiAoIShrZXkgaW4gcHJvdG8pKSByZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pOwogICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTsKICB9CiAgcmV0dXJuIG1ldGhvZHM7Cn07Cgp9LHsiLi9fZXhwb3J0IjozOCwiLi9faGFzIjo0MSwiLi9faGlkZSI6NDIsIi4vX2l0ZXItY3JlYXRlIjo0OCwiLi9faXRlcmF0b3JzIjo1MSwiLi9fbGlicmFyeSI6NTIsIi4vX29iamVjdC1ncG8iOjYyLCIuL19yZWRlZmluZSI6NjgsIi4vX3NldC10by1zdHJpbmctdGFnIjo3MCwiLi9fd2tzIjo4M31dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHsKICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9Owp9OwoKfSx7fV0sNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IHt9OwoKfSx7fV0sNTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IHRydWU7Cgp9LHt9XSw1MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBNRVRBID0gX2RlcmVxXygnLi9fdWlkJykoJ21ldGEnKTsKdmFyIGlzT2JqZWN0ID0gX2RlcmVxXygnLi9faXMtb2JqZWN0Jyk7CnZhciBoYXMgPSBfZGVyZXFfKCcuL19oYXMnKTsKdmFyIHNldERlc2MgPSBfZGVyZXFfKCcuL19vYmplY3QtZHAnKS5mOwp2YXIgaWQgPSAwOwp2YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7CiAgcmV0dXJuIHRydWU7Cn07CnZhciBGUkVFWkUgPSAhX2RlcmVxXygnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7CiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTsKfSk7CnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7CiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZTogewogICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElECiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEcwogIH0gfSk7Cn07CnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHsKICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4CiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7CiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7CiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdAogICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnOwogICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGEKICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnOwogICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGEKICAgIHNldE1ldGEoaXQpOwogIC8vIHJldHVybiBvYmplY3QgSUQKICB9IHJldHVybiBpdFtNRVRBXS5pOwp9Owp2YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7CiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7CiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdAogICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTsKICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhCiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlOwogICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGEKICAgIHNldE1ldGEoaXQpOwogIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzCiAgfSByZXR1cm4gaXRbTUVUQV0udzsKfTsKLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nCnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkgewogIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpOwogIHJldHVybiBpdDsKfTsKdmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHsKICBLRVk6IE1FVEEsCiAgTkVFRDogZmFsc2UsCiAgZmFzdEtleTogZmFzdEtleSwKICBnZXRXZWFrOiBnZXRXZWFrLAogIG9uRnJlZXplOiBvbkZyZWV6ZQp9OwoKfSx7Ii4vX2ZhaWxzIjozOSwiLi9faGFzIjo0MSwiLi9faXMtb2JqZWN0Ijo0NywiLi9fb2JqZWN0LWRwIjo1NiwiLi9fdWlkIjo4MH1dLDU0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwovLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pCnZhciBnZXRLZXlzID0gX2RlcmVxXygnLi9fb2JqZWN0LWtleXMnKTsKdmFyIGdPUFMgPSBfZGVyZXFfKCcuL19vYmplY3QtZ29wcycpOwp2YXIgcElFID0gX2RlcmVxXygnLi9fb2JqZWN0LXBpZScpOwp2YXIgdG9PYmplY3QgPSBfZGVyZXFfKCcuL190by1vYmplY3QnKTsKdmFyIElPYmplY3QgPSBfZGVyZXFfKCcuL19pb2JqZWN0Jyk7CnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjsKCi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKQptb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IF9kZXJlcV8oJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkgewogIHZhciBBID0ge307CiAgdmFyIEIgPSB7fTsKICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWYKICB2YXIgUyA9IFN5bWJvbCgpOwogIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JzsKICBBW1NdID0gNzsKICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTsKICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSzsKfSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycwogIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTsKICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7CiAgdmFyIGluZGV4ID0gMTsKICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjsKICB2YXIgaXNFbnVtID0gcElFLmY7CiAgd2hpbGUgKGFMZW4gPiBpbmRleCkgewogICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7CiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7CiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7CiAgICB2YXIgaiA9IDA7CiAgICB2YXIga2V5OwogICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07CiAgfSByZXR1cm4gVDsKfSA6ICRhc3NpZ247Cgp9LHsiLi9fZmFpbHMiOjM5LCIuL19pb2JqZWN0Ijo0NSwiLi9fb2JqZWN0LWdvcHMiOjYxLCIuL19vYmplY3Qta2V5cyI6NjQsIi4vX29iamVjdC1waWUiOjY1LCIuL190by1vYmplY3QiOjc4fV0sNTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSkKdmFyIGFuT2JqZWN0ID0gX2RlcmVxXygnLi9fYW4tb2JqZWN0Jyk7CnZhciBkUHMgPSBfZGVyZXFfKCcuL19vYmplY3QtZHBzJyk7CnZhciBlbnVtQnVnS2V5cyA9IF9kZXJlcV8oJy4vX2VudW0tYnVnLWtleXMnKTsKdmFyIElFX1BST1RPID0gX2RlcmVxXygnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpOwp2YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07CnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJzsKCi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGUKdmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7CiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWcKICB2YXIgaWZyYW1lID0gX2RlcmVxXygnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTsKICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDsKICB2YXIgbHQgPSAnPCc7CiAgdmFyIGd0ID0gJz4nOwogIHZhciBpZnJhbWVEb2N1bWVudDsKICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJzsKICBfZGVyZXFfKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTsKICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsCiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDsKICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7CiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDsKICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7CiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpOwogIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7CiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7CiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07CiAgcmV0dXJuIGNyZWF0ZURpY3QoKTsKfTsKCm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykgewogIHZhciByZXN1bHQ7CiAgaWYgKE8gIT09IG51bGwpIHsKICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTsKICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpOwogICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7CiAgICAvLyBhZGQgIl9fcHJvdG9fXyIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbAogICAgcmVzdWx0W0lFX1BST1RPXSA9IE87CiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTsKICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7Cn07Cgp9LHsiLi9fYW4tb2JqZWN0IjoyOCwiLi9fZG9tLWNyZWF0ZSI6MzUsIi4vX2VudW0tYnVnLWtleXMiOjM2LCIuL19odG1sIjo0MywiLi9fb2JqZWN0LWRwcyI6NTcsIi4vX3NoYXJlZC1rZXkiOjcxfV0sNTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgYW5PYmplY3QgPSBfZGVyZXFfKCcuL19hbi1vYmplY3QnKTsKdmFyIElFOF9ET01fREVGSU5FID0gX2RlcmVxXygnLi9faWU4LWRvbS1kZWZpbmUnKTsKdmFyIHRvUHJpbWl0aXZlID0gX2RlcmVxXygnLi9fdG8tcHJpbWl0aXZlJyk7CnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTsKCmV4cG9ydHMuZiA9IF9kZXJlcV8oJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7CiAgYW5PYmplY3QoTyk7CiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpOwogIGFuT2JqZWN0KEF0dHJpYnV0ZXMpOwogIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHsKICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTsKICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH0KICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpOwogIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlOwogIHJldHVybiBPOwp9OwoKfSx7Ii4vX2FuLW9iamVjdCI6MjgsIi4vX2Rlc2NyaXB0b3JzIjozNCwiLi9faWU4LWRvbS1kZWZpbmUiOjQ0LCIuL190by1wcmltaXRpdmUiOjc5fV0sNTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgZFAgPSBfZGVyZXFfKCcuL19vYmplY3QtZHAnKTsKdmFyIGFuT2JqZWN0ID0gX2RlcmVxXygnLi9fYW4tb2JqZWN0Jyk7CnZhciBnZXRLZXlzID0gX2RlcmVxXygnLi9fb2JqZWN0LWtleXMnKTsKCm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7CiAgYW5PYmplY3QoTyk7CiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpOwogIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDsKICB2YXIgaSA9IDA7CiAgdmFyIFA7CiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7CiAgcmV0dXJuIE87Cn07Cgp9LHsiLi9fYW4tb2JqZWN0IjoyOCwiLi9fZGVzY3JpcHRvcnMiOjM0LCIuL19vYmplY3QtZHAiOjU2LCIuL19vYmplY3Qta2V5cyI6NjR9XSw1ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBwSUUgPSBfZGVyZXFfKCcuL19vYmplY3QtcGllJyk7CnZhciBjcmVhdGVEZXNjID0gX2RlcmVxXygnLi9fcHJvcGVydHktZGVzYycpOwp2YXIgdG9JT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8taW9iamVjdCcpOwp2YXIgdG9QcmltaXRpdmUgPSBfZGVyZXFfKCcuL190by1wcmltaXRpdmUnKTsKdmFyIGhhcyA9IF9kZXJlcV8oJy4vX2hhcycpOwp2YXIgSUU4X0RPTV9ERUZJTkUgPSBfZGVyZXFfKCcuL19pZTgtZG9tLWRlZmluZScpOwp2YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7CgpleHBvcnRzLmYgPSBfZGVyZXFfKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7CiAgTyA9IHRvSU9iamVjdChPKTsKICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7CiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkgewogICAgcmV0dXJuIGdPUEQoTywgUCk7CiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9CiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pOwp9OwoKfSx7Ii4vX2Rlc2NyaXB0b3JzIjozNCwiLi9faGFzIjo0MSwiLi9faWU4LWRvbS1kZWZpbmUiOjQ0LCIuL19vYmplY3QtcGllIjo2NSwiLi9fcHJvcGVydHktZGVzYyI6NjcsIi4vX3RvLWlvYmplY3QiOjc2LCIuL190by1wcmltaXRpdmUiOjc5fV0sNTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93CnZhciB0b0lPYmplY3QgPSBfZGVyZXFfKCcuL190by1pb2JqZWN0Jyk7CnZhciBnT1BOID0gX2RlcmVxXygnLi9fb2JqZWN0LWdvcG4nKS5mOwp2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZzsKCnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzCiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107Cgp2YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHsKICB0cnkgewogICAgcmV0dXJuIGdPUE4oaXQpOwogIH0gY2F0Y2ggKGUpIHsKICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpOwogIH0KfTsKCm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7CiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTsKfTsKCn0seyIuL19vYmplY3QtZ29wbiI6NjAsIi4vX3RvLWlvYmplY3QiOjc2fV0sNjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pCnZhciAka2V5cyA9IF9kZXJlcV8oJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7CnZhciBoaWRkZW5LZXlzID0gX2RlcmVxXygnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpOwoKZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7CiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpOwp9OwoKfSx7Ii4vX2VudW0tYnVnLWtleXMiOjM2LCIuL19vYmplY3Qta2V5cy1pbnRlcm5hbCI6NjN9XSw2MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7Cgp9LHt9XSw2MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pCnZhciBoYXMgPSBfZGVyZXFfKCcuL19oYXMnKTsKdmFyIHRvT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8tb2JqZWN0Jyk7CnZhciBJRV9QUk9UTyA9IF9kZXJlcV8oJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTsKdmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTsKCm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7CiAgTyA9IHRvT2JqZWN0KE8pOwogIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107CiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHsKICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTsKICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsOwp9OwoKfSx7Ii4vX2hhcyI6NDEsIi4vX3NoYXJlZC1rZXkiOjcxLCIuL190by1vYmplY3QiOjc4fV0sNjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgaGFzID0gX2RlcmVxXygnLi9faGFzJyk7CnZhciB0b0lPYmplY3QgPSBfZGVyZXFfKCcuL190by1pb2JqZWN0Jyk7CnZhciBhcnJheUluZGV4T2YgPSBfZGVyZXFfKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTsKdmFyIElFX1BST1RPID0gX2RlcmVxXygnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpOwoKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykgewogIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7CiAgdmFyIGkgPSAwOwogIHZhciByZXN1bHQgPSBbXTsKICB2YXIga2V5OwogIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7CiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5cwogIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7CiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpOwogIH0KICByZXR1cm4gcmVzdWx0Owp9OwoKfSx7Ii4vX2FycmF5LWluY2x1ZGVzIjoyOSwiLi9faGFzIjo0MSwiLi9fc2hhcmVkLWtleSI6NzEsIi4vX3RvLWlvYmplY3QiOjc2fV0sNjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTykKdmFyICRrZXlzID0gX2RlcmVxXygnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTsKdmFyIGVudW1CdWdLZXlzID0gX2RlcmVxXygnLi9fZW51bS1idWcta2V5cycpOwoKbW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHsKICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpOwp9OwoKfSx7Ii4vX2VudW0tYnVnLWtleXMiOjM2LCIuL19vYmplY3Qta2V5cy1pbnRlcm5hbCI6NjN9XSw2NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlOwoKfSx7fV0sNjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXMKdmFyICRleHBvcnQgPSBfZGVyZXFfKCcuL19leHBvcnQnKTsKdmFyIGNvcmUgPSBfZGVyZXFfKCcuL19jb3JlJyk7CnZhciBmYWlscyA9IF9kZXJlcV8oJy4vX2ZhaWxzJyk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgZXhlYykgewogIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTsKICB2YXIgZXhwID0ge307CiAgZXhwW0tFWV0gPSBleGVjKGZuKTsKICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTsKfTsKCn0seyIuL19jb3JlIjozMSwiLi9fZXhwb3J0IjozOCwiLi9fZmFpbHMiOjM5fV0sNjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7CiAgcmV0dXJuIHsKICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksCiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksCiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSwKICAgIHZhbHVlOiB2YWx1ZQogIH07Cn07Cgp9LHt9XSw2ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9faGlkZScpOwoKfSx7Ii4vX2hpZGUiOjQyfV0sNjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy4KLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi8KdmFyIGlzT2JqZWN0ID0gX2RlcmVxXygnLi9faXMtb2JqZWN0Jyk7CnZhciBhbk9iamVjdCA9IF9kZXJlcV8oJy4vX2FuLW9iamVjdCcpOwp2YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHsKICBhbk9iamVjdChPKTsKICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSEiKTsKfTsKbW9kdWxlLmV4cG9ydHMgPSB7CiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZQogICAgZnVuY3Rpb24gKHRlc3QsIGJ1Z2d5LCBzZXQpIHsKICAgICAgdHJ5IHsKICAgICAgICBzZXQgPSBfZGVyZXFfKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCBfZGVyZXFfKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7CiAgICAgICAgc2V0KHRlc3QsIFtdKTsKICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTsKICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH0KICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7CiAgICAgICAgY2hlY2soTywgcHJvdG8pOwogICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bzsKICAgICAgICBlbHNlIHNldChPLCBwcm90byk7CiAgICAgICAgcmV0dXJuIE87CiAgICAgIH07CiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLAogIGNoZWNrOiBjaGVjawp9OwoKfSx7Ii4vX2FuLW9iamVjdCI6MjgsIi4vX2N0eCI6MzIsIi4vX2lzLW9iamVjdCI6NDcsIi4vX29iamVjdC1nb3BkIjo1OH1dLDcwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGRlZiA9IF9kZXJlcV8oJy4vX29iamVjdC1kcCcpLmY7CnZhciBoYXMgPSBfZGVyZXFfKCcuL19oYXMnKTsKdmFyIFRBRyA9IF9kZXJlcV8oJy4vX3drcycpKCd0b1N0cmluZ1RhZycpOwoKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkgewogIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7Cn07Cgp9LHsiLi9faGFzIjo0MSwiLi9fb2JqZWN0LWRwIjo1NiwiLi9fd2tzIjo4M31dLDcxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIHNoYXJlZCA9IF9kZXJlcV8oJy4vX3NoYXJlZCcpKCdrZXlzJyk7CnZhciB1aWQgPSBfZGVyZXFfKCcuL191aWQnKTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7CiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTsKfTsKCn0seyIuL19zaGFyZWQiOjcyLCIuL191aWQiOjgwfV0sNzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgZ2xvYmFsID0gX2RlcmVxXygnLi9fZ2xvYmFsJyk7CnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJzsKdmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHsKICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTsKfTsKCn0seyIuL19nbG9iYWwiOjQwfV0sNzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgdG9JbnRlZ2VyID0gX2RlcmVxXygnLi9fdG8taW50ZWdlcicpOwp2YXIgZGVmaW5lZCA9IF9kZXJlcV8oJy4vX2RlZmluZWQnKTsKLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0Ci8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdAptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHsKICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykgewogICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7CiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpOwogICAgdmFyIGwgPSBzLmxlbmd0aDsKICAgIHZhciBhLCBiOwogICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkOwogICAgYSA9IHMuY2hhckNvZGVBdChpKTsKICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmCiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhCiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwOwogIH07Cn07Cgp9LHsiLi9fZGVmaW5lZCI6MzMsIi4vX3RvLWludGVnZXIiOjc1fV0sNzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgdG9JbnRlZ2VyID0gX2RlcmVxXygnLi9fdG8taW50ZWdlcicpOwp2YXIgbWF4ID0gTWF0aC5tYXg7CnZhciBtaW4gPSBNYXRoLm1pbjsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkgewogIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTsKICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTsKfTsKCn0seyIuL190by1pbnRlZ2VyIjo3NX1dLDc1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gNy4xLjQgVG9JbnRlZ2VyCnZhciBjZWlsID0gTWF0aC5jZWlsOwp2YXIgZmxvb3IgPSBNYXRoLmZsb29yOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpOwp9OwoKfSx7fV0sNzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3MKdmFyIElPYmplY3QgPSBfZGVyZXFfKCcuL19pb2JqZWN0Jyk7CnZhciBkZWZpbmVkID0gX2RlcmVxXygnLi9fZGVmaW5lZCcpOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTsKfTsKCn0seyIuL19kZWZpbmVkIjozMywiLi9faW9iamVjdCI6NDV9XSw3NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDcuMS4xNSBUb0xlbmd0aAp2YXIgdG9JbnRlZ2VyID0gX2RlcmVxXygnLi9fdG8taW50ZWdlcicpOwp2YXIgbWluID0gTWF0aC5taW47Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTEKfTsKCn0seyIuL190by1pbnRlZ2VyIjo3NX1dLDc4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KQp2YXIgZGVmaW5lZCA9IF9kZXJlcV8oJy4vX2RlZmluZWQnKTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTsKfTsKCn0seyIuL19kZWZpbmVkIjozM31dLDc5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pCnZhciBpc09iamVjdCA9IF9kZXJlcV8oJy4vX2lzLW9iamVjdCcpOwovLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZQovLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgUykgewogIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7CiAgdmFyIGZuLCB2YWw7CiAgaWYgKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7CiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7CiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsOwogIHRocm93IFR5cGVFcnJvcigiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlIik7Cn07Cgp9LHsiLi9faXMtb2JqZWN0Ijo0N31dLDgwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGlkID0gMDsKdmFyIHB4ID0gTWF0aC5yYW5kb20oKTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7CiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTsKfTsKCn0se31dLDgxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGdsb2JhbCA9IF9kZXJlcV8oJy4vX2dsb2JhbCcpOwp2YXIgY29yZSA9IF9kZXJlcV8oJy4vX2NvcmUnKTsKdmFyIExJQlJBUlkgPSBfZGVyZXFfKCcuL19saWJyYXJ5Jyk7CnZhciB3a3NFeHQgPSBfZGVyZXFfKCcuL193a3MtZXh0Jyk7CnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9kZXJlcV8oJy4vX29iamVjdC1kcCcpLmY7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHsKICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pOwogIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTsKfTsKCn0seyIuL19jb3JlIjozMSwiLi9fZ2xvYmFsIjo0MCwiLi9fbGlicmFyeSI6NTIsIi4vX29iamVjdC1kcCI6NTYsIi4vX3drcy1leHQiOjgyfV0sODI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpleHBvcnRzLmYgPSBfZGVyZXFfKCcuL193a3MnKTsKCn0seyIuL193a3MiOjgzfV0sODM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgc3RvcmUgPSBfZGVyZXFfKCcuL19zaGFyZWQnKSgnd2tzJyk7CnZhciB1aWQgPSBfZGVyZXFfKCcuL191aWQnKTsKdmFyIFN5bWJvbCA9IF9kZXJlcV8oJy4vX2dsb2JhbCcpLlN5bWJvbDsKdmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7Cgp2YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7CiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9CiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpOwp9OwoKJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTsKCn0seyIuL19nbG9iYWwiOjQwLCIuL19zaGFyZWQiOjcyLCIuL191aWQiOjgwfV0sODQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7CnZhciBhZGRUb1Vuc2NvcGFibGVzID0gX2RlcmVxXygnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7CnZhciBzdGVwID0gX2RlcmVxXygnLi9faXRlci1zdGVwJyk7CnZhciBJdGVyYXRvcnMgPSBfZGVyZXFfKCcuL19pdGVyYXRvcnMnKTsKdmFyIHRvSU9iamVjdCA9IF9kZXJlcV8oJy4vX3RvLWlvYmplY3QnKTsKCi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKCkKLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKCkKLy8gMjIuMS4zLjI5IEFycmF5LnByb3RvdHlwZS52YWx1ZXMoKQovLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKCkKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHsKICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0CiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXgKICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZAovLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KCkKfSwgZnVuY3Rpb24gKCkgewogIHZhciBPID0gdGhpcy5fdDsKICB2YXIga2luZCA9IHRoaXMuX2s7CiAgdmFyIGluZGV4ID0gdGhpcy5faSsrOwogIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkgewogICAgdGhpcy5fdCA9IHVuZGVmaW5lZDsKICAgIHJldHVybiBzdGVwKDEpOwogIH0KICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTsKICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pOwogIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTsKfSwgJ3ZhbHVlcycpOwoKLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KQpJdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5OwoKYWRkVG9VbnNjb3BhYmxlcygna2V5cycpOwphZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTsKYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpOwoKfSx7Ii4vX2FkZC10by11bnNjb3BhYmxlcyI6MjcsIi4vX2l0ZXItZGVmaW5lIjo0OSwiLi9faXRlci1zdGVwIjo1MCwiLi9faXRlcmF0b3JzIjo1MSwiLi9fdG8taW9iamVjdCI6NzZ9XSw4NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpCnZhciAkZXhwb3J0ID0gX2RlcmVxXygnLi9fZXhwb3J0Jyk7CgokZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHsgYXNzaWduOiBfZGVyZXFfKCcuL19vYmplY3QtYXNzaWduJykgfSk7Cgp9LHsiLi9fZXhwb3J0IjozOCwiLi9fb2JqZWN0LWFzc2lnbiI6NTR9XSw4NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciAkZXhwb3J0ID0gX2RlcmVxXygnLi9fZXhwb3J0Jyk7Ci8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKQokZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgY3JlYXRlOiBfZGVyZXFfKCcuL19vYmplY3QtY3JlYXRlJykgfSk7Cgp9LHsiLi9fZXhwb3J0IjozOCwiLi9fb2JqZWN0LWNyZWF0ZSI6NTV9XSw4NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciAkZXhwb3J0ID0gX2RlcmVxXygnLi9fZXhwb3J0Jyk7Ci8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpCiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIV9kZXJlcV8oJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnR5OiBfZGVyZXFfKCcuL19vYmplY3QtZHAnKS5mIH0pOwoKfSx7Ii4vX2Rlc2NyaXB0b3JzIjozNCwiLi9fZXhwb3J0IjozOCwiLi9fb2JqZWN0LWRwIjo1Nn1dLDg4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gMTkuMS4yLjkgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pCnZhciB0b09iamVjdCA9IF9kZXJlcV8oJy4vX3RvLW9iamVjdCcpOwp2YXIgJGdldFByb3RvdHlwZU9mID0gX2RlcmVxXygnLi9fb2JqZWN0LWdwbycpOwoKX2RlcmVxXygnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHsKICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHsKICAgIHJldHVybiAkZ2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTsKICB9Owp9KTsKCn0seyIuL19vYmplY3QtZ3BvIjo2MiwiLi9fb2JqZWN0LXNhcCI6NjYsIi4vX3RvLW9iamVjdCI6Nzh9XSw4OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pCnZhciAkZXhwb3J0ID0gX2RlcmVxXygnLi9fZXhwb3J0Jyk7CiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogX2RlcmVxXygnLi9fc2V0LXByb3RvJykuc2V0IH0pOwoKfSx7Ii4vX2V4cG9ydCI6MzgsIi4vX3NldC1wcm90byI6Njl9XSw5MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cgp9LHt9XSw5MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKdmFyICRhdCA9IF9kZXJlcV8oJy4vX3N0cmluZy1hdCcpKHRydWUpOwoKLy8gMjEuMS4zLjI3IFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKQpfZGVyZXFfKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkgewogIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXQKICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleAovLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpCn0sIGZ1bmN0aW9uICgpIHsKICB2YXIgTyA9IHRoaXMuX3Q7CiAgdmFyIGluZGV4ID0gdGhpcy5faTsKICB2YXIgcG9pbnQ7CiAgaWYgKGluZGV4ID49IE8ubGVuZ3RoKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07CiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpOwogIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoOwogIHJldHVybiB7IHZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2UgfTsKfSk7Cgp9LHsiLi9faXRlci1kZWZpbmUiOjQ5LCIuL19zdHJpbmctYXQiOjczfV0sOTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7Ci8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW0KdmFyIGdsb2JhbCA9IF9kZXJlcV8oJy4vX2dsb2JhbCcpOwp2YXIgaGFzID0gX2RlcmVxXygnLi9faGFzJyk7CnZhciBERVNDUklQVE9SUyA9IF9kZXJlcV8oJy4vX2Rlc2NyaXB0b3JzJyk7CnZhciAkZXhwb3J0ID0gX2RlcmVxXygnLi9fZXhwb3J0Jyk7CnZhciByZWRlZmluZSA9IF9kZXJlcV8oJy4vX3JlZGVmaW5lJyk7CnZhciBNRVRBID0gX2RlcmVxXygnLi9fbWV0YScpLktFWTsKdmFyICRmYWlscyA9IF9kZXJlcV8oJy4vX2ZhaWxzJyk7CnZhciBzaGFyZWQgPSBfZGVyZXFfKCcuL19zaGFyZWQnKTsKdmFyIHNldFRvU3RyaW5nVGFnID0gX2RlcmVxXygnLi9fc2V0LXRvLXN0cmluZy10YWcnKTsKdmFyIHVpZCA9IF9kZXJlcV8oJy4vX3VpZCcpOwp2YXIgd2tzID0gX2RlcmVxXygnLi9fd2tzJyk7CnZhciB3a3NFeHQgPSBfZGVyZXFfKCcuL193a3MtZXh0Jyk7CnZhciB3a3NEZWZpbmUgPSBfZGVyZXFfKCcuL193a3MtZGVmaW5lJyk7CnZhciBlbnVtS2V5cyA9IF9kZXJlcV8oJy4vX2VudW0ta2V5cycpOwp2YXIgaXNBcnJheSA9IF9kZXJlcV8oJy4vX2lzLWFycmF5Jyk7CnZhciBhbk9iamVjdCA9IF9kZXJlcV8oJy4vX2FuLW9iamVjdCcpOwp2YXIgaXNPYmplY3QgPSBfZGVyZXFfKCcuL19pcy1vYmplY3QnKTsKdmFyIHRvSU9iamVjdCA9IF9kZXJlcV8oJy4vX3RvLWlvYmplY3QnKTsKdmFyIHRvUHJpbWl0aXZlID0gX2RlcmVxXygnLi9fdG8tcHJpbWl0aXZlJyk7CnZhciBjcmVhdGVEZXNjID0gX2RlcmVxXygnLi9fcHJvcGVydHktZGVzYycpOwp2YXIgX2NyZWF0ZSA9IF9kZXJlcV8oJy4vX29iamVjdC1jcmVhdGUnKTsKdmFyIGdPUE5FeHQgPSBfZGVyZXFfKCcuL19vYmplY3QtZ29wbi1leHQnKTsKdmFyICRHT1BEID0gX2RlcmVxXygnLi9fb2JqZWN0LWdvcGQnKTsKdmFyICREUCA9IF9kZXJlcV8oJy4vX29iamVjdC1kcCcpOwp2YXIgJGtleXMgPSBfZGVyZXFfKCcuL19vYmplY3Qta2V5cycpOwp2YXIgZ09QRCA9ICRHT1BELmY7CnZhciBkUCA9ICREUC5mOwp2YXIgZ09QTiA9IGdPUE5FeHQuZjsKdmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sOwp2YXIgJEpTT04gPSBnbG9iYWwuSlNPTjsKdmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7CnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJzsKdmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpOwp2YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpOwp2YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7CnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7CnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7CnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTsKdmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07CnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJzsKdmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDsKLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczCnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkOwoKLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3CnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uICgpIHsKICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7CiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9CiAgfSkpLmEgIT0gNzsKfSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkgewogIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpOwogIGlmIChwcm90b0Rlc2MpIGRlbGV0ZSBPYmplY3RQcm90b1trZXldOwogIGRQKGl0LCBrZXksIEQpOwogIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpOwp9IDogZFA7Cgp2YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHsKICB2YXIgc3ltID0gQWxsU3ltYm9sc1t0YWddID0gX2NyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pOwogIHN5bS5fayA9IHRhZzsKICByZXR1cm4gc3ltOwp9OwoKdmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkgewogIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7Cn0gOiBmdW5jdGlvbiAoaXQpIHsKICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sOwp9OwoKdmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHsKICBpZiAoaXQgPT09IE9iamVjdFByb3RvKSAkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpOwogIGFuT2JqZWN0KGl0KTsKICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpOwogIGFuT2JqZWN0KEQpOwogIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkgewogICAgaWYgKCFELmVudW1lcmFibGUpIHsKICAgICAgaWYgKCFoYXMoaXQsIEhJRERFTikpIGRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTsKICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTsKICAgIH0gZWxzZSB7CiAgICAgIGlmIChoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSBpdFtISURERU5dW2tleV0gPSBmYWxzZTsKICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTsKICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7CiAgfSByZXR1cm4gZFAoaXQsIGtleSwgRCk7Cn07CnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHsKICBhbk9iamVjdChpdCk7CiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTsKICB2YXIgaSA9IDA7CiAgdmFyIGwgPSBrZXlzLmxlbmd0aDsKICB2YXIga2V5OwogIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7CiAgcmV0dXJuIGl0Owp9Owp2YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkgewogIHJldHVybiBQID09PSB1bmRlZmluZWQgPyBfY3JlYXRlKGl0KSA6ICRkZWZpbmVQcm9wZXJ0aWVzKF9jcmVhdGUoaXQpLCBQKTsKfTsKdmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkgewogIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7CiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7CiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlOwp9Owp2YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7CiAgaXQgPSB0b0lPYmplY3QoaXQpOwogIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7CiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuOwogIHZhciBEID0gZ09QRChpdCwga2V5KTsKICBpZiAoRCAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSBELmVudW1lcmFibGUgPSB0cnVlOwogIHJldHVybiBEOwp9Owp2YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7CiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTsKICB2YXIgcmVzdWx0ID0gW107CiAgdmFyIGkgPSAwOwogIHZhciBrZXk7CiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHsKICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIGtleSAhPSBISURERU4gJiYga2V5ICE9IE1FVEEpIHJlc3VsdC5wdXNoKGtleSk7CiAgfSByZXR1cm4gcmVzdWx0Owp9Owp2YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkgewogIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bzsKICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7CiAgdmFyIHJlc3VsdCA9IFtdOwogIHZhciBpID0gMDsKICB2YXIga2V5OwogIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7CiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pOwogIH0gcmV0dXJuIHJlc3VsdDsKfTsKCi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKQppZiAoIVVTRV9OQVRJVkUpIHsKICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkgewogICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTsKICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOwogICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHsKICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7CiAgICAgIGlmIChoYXModGhpcywgSElEREVOKSAmJiBoYXModGhpc1tISURERU5dLCB0YWcpKSB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlOwogICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpOwogICAgfTsKICAgIGlmIChERVNDUklQVE9SUyAmJiBzZXR0ZXIpIHNldFN5bWJvbERlc2MoT2JqZWN0UHJvdG8sIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldCB9KTsKICAgIHJldHVybiB3cmFwKHRhZyk7CiAgfTsKICByZWRlZmluZSgkU3ltYm9sW1BST1RPVFlQRV0sICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkgewogICAgcmV0dXJuIHRoaXMuX2s7CiAgfSk7CgogICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOwogICREUC5mID0gJGRlZmluZVByb3BlcnR5OwogIF9kZXJlcV8oJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzOwogIF9kZXJlcV8oJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlOwogIF9kZXJlcV8oJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7CgogIGlmIChERVNDUklQVE9SUyAmJiAhX2RlcmVxXygnLi9fbGlicmFyeScpKSB7CiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTsKICB9CgogIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHsKICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7CiAgfTsKfQoKJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7Cgpmb3IgKHZhciBlczZTeW1ib2xzID0gKAogIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0CiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJwopLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pOwoKZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTsKCiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7CiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpCiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHsKICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJykKICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldCiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTsKICB9LAogIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKQogIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkgewogICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7CiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7CiAgfSwKICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSwKICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH0KfSk7CgokZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0JywgewogIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSkKICBjcmVhdGU6ICRjcmVhdGUsCiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpCiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSwKICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKQogIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLAogIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkKICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsCiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTykKICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcywKICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pCiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzCn0pOwoKLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pCiRKU09OICYmICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKCFVU0VfTkFUSVZFIHx8ICRmYWlscyhmdW5jdGlvbiAoKSB7CiAgdmFyIFMgPSAkU3ltYm9sKCk7CiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge30KICAvLyBXZWJLaXQgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIG51bGwKICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9scwogIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9JzsKfSkpLCAnSlNPTicsIHsKICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkgewogICAgdmFyIGFyZ3MgPSBbaXRdOwogICAgdmFyIGkgPSAxOwogICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7CiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7CiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07CiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkCiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7CiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7CiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7CiAgICB9OwogICAgYXJnc1sxXSA9IHJlcGxhY2VyOwogICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpOwogIH0KfSk7CgovLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpCiRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdIHx8IF9kZXJlcV8oJy4vX2hpZGUnKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpOwovLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddCnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTsKLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXQpzZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpOwovLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXQpzZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTsKCn0seyIuL19hbi1vYmplY3QiOjI4LCIuL19kZXNjcmlwdG9ycyI6MzQsIi4vX2VudW0ta2V5cyI6MzcsIi4vX2V4cG9ydCI6MzgsIi4vX2ZhaWxzIjozOSwiLi9fZ2xvYmFsIjo0MCwiLi9faGFzIjo0MSwiLi9faGlkZSI6NDIsIi4vX2lzLWFycmF5Ijo0NiwiLi9faXMtb2JqZWN0Ijo0NywiLi9fbGlicmFyeSI6NTIsIi4vX21ldGEiOjUzLCIuL19vYmplY3QtY3JlYXRlIjo1NSwiLi9fb2JqZWN0LWRwIjo1NiwiLi9fb2JqZWN0LWdvcGQiOjU4LCIuL19vYmplY3QtZ29wbiI6NjAsIi4vX29iamVjdC1nb3BuLWV4dCI6NTksIi4vX29iamVjdC1nb3BzIjo2MSwiLi9fb2JqZWN0LWtleXMiOjY0LCIuL19vYmplY3QtcGllIjo2NSwiLi9fcHJvcGVydHktZGVzYyI6NjcsIi4vX3JlZGVmaW5lIjo2OCwiLi9fc2V0LXRvLXN0cmluZy10YWciOjcwLCIuL19zaGFyZWQiOjcyLCIuL190by1pb2JqZWN0Ijo3NiwiLi9fdG8tcHJpbWl0aXZlIjo3OSwiLi9fdWlkIjo4MCwiLi9fd2tzIjo4MywiLi9fd2tzLWRlZmluZSI6ODEsIi4vX3drcy1leHQiOjgyfV0sOTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpfZGVyZXFfKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTsKCn0seyIuL193a3MtZGVmaW5lIjo4MX1dLDk0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7Cgp9LHsiLi9fd2tzLWRlZmluZSI6ODF9XSw5NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cl9kZXJlcV8oJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7CnZhciBnbG9iYWwgPSBfZGVyZXFfKCcuL19nbG9iYWwnKTsKdmFyIGhpZGUgPSBfZGVyZXFfKCcuL19oaWRlJyk7CnZhciBJdGVyYXRvcnMgPSBfZGVyZXFfKCcuL19pdGVyYXRvcnMnKTsKdmFyIFRPX1NUUklOR19UQUcgPSBfZGVyZXFfKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTsKCnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArCiAgJ0RPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsJyArCiAgJ01lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsJyArCiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgKwogICdUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCcpLnNwbGl0KCcsJyk7Cgpmb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykgewogIHZhciBOQU1FID0gRE9NSXRlcmFibGVzW2ldOwogIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdOwogIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7CiAgaWYgKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7CiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5Owp9Cgp9LHsiLi9fZ2xvYmFsIjo0MCwiLi9faGlkZSI6NDIsIi4vX2l0ZXJhdG9ycyI6NTEsIi4vX3drcyI6ODMsIi4vZXM2LmFycmF5Lml0ZXJhdG9yIjo4NH1dLDk2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKYXJndW1lbnRzWzRdWzkwXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykKfSx7ImR1cCI6OTB9XSw5NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JwoKZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aApleHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXkKZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheQoKdmFyIGxvb2t1cCA9IFtdCnZhciByZXZMb29rdXAgPSBbXQp2YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5Cgp2YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJwpmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkgewogIGxvb2t1cFtpXSA9IGNvZGVbaV0KICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGkKfQoKcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyCnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2MwoKZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkgewogIHZhciBsZW4gPSBiNjQubGVuZ3RoCiAgaWYgKGxlbiAlIDQgPiAwKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKQogIH0KCiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycykKICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0CiAgLy8gcmVwcmVzZW50IG9uZSBieXRlCiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzCiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZQogIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwCn0KCmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkgewogIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YQogIHJldHVybiAoYjY0Lmxlbmd0aCAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NCkKfQoKZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkgewogIHZhciBpLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyCiAgdmFyIGxlbiA9IGI2NC5sZW5ndGgKICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpCgogIGFyciA9IG5ldyBBcnIoKGxlbiAqIDMgLyA0KSAtIHBsYWNlSG9sZGVycykKCiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFycwogIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlbgoKICB2YXIgTCA9IDAKCiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNCkgewogICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldCiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRgogICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRgogICAgYXJyW0wrK10gPSB0bXAgJiAweEZGCiAgfQoKICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7CiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KQogICAgYXJyW0wrK10gPSB0bXAgJiAweEZGCiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHsKICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKQogICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRgogICAgYXJyW0wrK10gPSB0bXAgJiAweEZGCiAgfQoKICByZXR1cm4gYXJyCn0KCmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7CiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdCn0KCmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkgewogIHZhciB0bXAKICB2YXIgb3V0cHV0ID0gW10KICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykgewogICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKQogICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpCiAgfQogIHJldHVybiBvdXRwdXQuam9pbignJykKfQoKZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHsKICB2YXIgdG1wCiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aAogIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlcwogIHZhciBvdXRwdXQgPSAnJwogIHZhciBwYXJ0cyA9IFtdCiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzCgogIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXIKICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7CiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKQogIH0KCiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlcwogIGlmIChleHRyYUJ5dGVzID09PSAxKSB7CiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXQogICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl0KICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdCiAgICBvdXRwdXQgKz0gJz09JwogIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikgewogICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKQogICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdCiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXQogICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0KICAgIG91dHB1dCArPSAnPScKICB9CgogIHBhcnRzLnB1c2gob3V0cHV0KQoKICByZXR1cm4gcGFydHMuam9pbignJykKfQoKfSx7fV0sOTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovKiEKICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuCiAqCiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+CiAqIEBsaWNlbnNlICBNSVQKICovCi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovCgondXNlIHN0cmljdCcKCnZhciBiYXNlNjQgPSBfZGVyZXFfKCdiYXNlNjQtanMnKQp2YXIgaWVlZTc1NCA9IF9kZXJlcV8oJ2llZWU3NTQnKQoKZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXIKZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcgpleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTAKCnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmCmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSAoKLyoqCiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6CiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpCiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdAogKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KQogKgogKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssCiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy4KICoKICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlCiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAKICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydAogKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi4KICovCkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKQoKaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYKICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7CiAgY29uc29sZS5lcnJvcigKICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArCiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nCiAgKQp9CgpmdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7CiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkPwogIHRyeSB7CiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSkKICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fQogICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIKICB9IGNhdGNoIChlKSB7CiAgICByZXR1cm4gZmFsc2UKICB9Cn0KCmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7CiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJykKICB9CiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UKICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKQogIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlCiAgcmV0dXJuIGJ1Zgp9CgovKioKICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyCiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2YKICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kcwogKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdAogKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LgogKgogKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuCiAqLwoKZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogIC8vIENvbW1vbiBjYXNlLgogIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykgewogICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykgewogICAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJwogICAgICApCiAgICB9CiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKQogIH0KICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkKfQoKLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTcKaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmCiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywgewogICAgdmFsdWU6IG51bGwsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgIHdyaXRhYmxlOiBmYWxzZQogIH0pCn0KCkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvbgoKZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcidmFsdWUiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJykKICB9CgogIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSkgewogICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKQogIH0KCiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsKICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KQogIH0KCiAgcmV0dXJuIGZyb21PYmplY3QodmFsdWUpCn0KCi8qKgogKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvcgogKiBpZiB2YWx1ZSBpcyBhIG51bWJlci4KICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKQogKiBCdWZmZXIuZnJvbShhcnJheSkKICogQnVmZmVyLmZyb20oYnVmZmVyKQogKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSkKICoqLwpCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkKfQoKLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOgovLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OApCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlCkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5CgpmdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7CiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignInNpemUiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKQogIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcic2l6ZSIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKQogIH0KfQoKZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgYXNzZXJ0U2l6ZShzaXplKQogIGlmIChzaXplIDw9IDApIHsKICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSkKICB9CiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkgewogICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXMKICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGQKICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC4KICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnCiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpCiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCkKICB9CiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKQp9CgovKioKICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLgogKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pCiAqKi8KQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKQp9CgpmdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkgewogIGFzc2VydFNpemUoc2l6ZSkKICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKQp9CgovKioKICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS4KICogKi8KQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHsKICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSkKfQovKioKICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuCiAqLwpCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHsKICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSkKfQoKZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykgewogIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykgewogICAgZW5jb2RpbmcgPSAndXRmOCcKICB9CgogIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCciZW5jb2RpbmciIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKQogIH0KCiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwCiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpCgogIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZykKCiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7CiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGwKICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuCiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJykKICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpCiAgfQoKICByZXR1cm4gYnVmCn0KCmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7CiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMAogIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKQogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHsKICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1CiAgfQogIHJldHVybiBidWYKfQoKZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7CiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCdvZmZzZXRcJyBpcyBvdXQgb2YgYm91bmRzJykKICB9CgogIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcJ2xlbmd0aFwnIGlzIG91dCBvZiBib3VuZHMnKQogIH0KCiAgdmFyIGJ1ZgogIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHsKICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KQogIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsKICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KQogIH0gZWxzZSB7CiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKQogIH0KCiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UKICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZQogIHJldHVybiBidWYKfQoKZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7CiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7CiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDAKICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKQoKICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiBidWYKICAgIH0KCiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbikKICAgIHJldHVybiBidWYKICB9CgogIGlmIChvYmopIHsKICAgIGlmIChpc0FycmF5QnVmZmVyVmlldyhvYmopIHx8ICdsZW5ndGgnIGluIG9iaikgewogICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7CiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKQogICAgICB9CiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iaikKICAgIH0KCiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7CiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKQogICAgfQogIH0KCiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpCn0KCmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkgewogIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlbgogIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKQogIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICsKICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpCiAgfQogIHJldHVybiBsZW5ndGggfCAwCn0KCmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkgewogIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcQogICAgbGVuZ3RoID0gMAogIH0KICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpCn0KCkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7CiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZQp9CgpCdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHsKICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJykKICB9CgogIGlmIChhID09PSBiKSByZXR1cm4gMAoKICB2YXIgeCA9IGEubGVuZ3RoCiAgdmFyIHkgPSBiLmxlbmd0aAoKICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkgewogICAgaWYgKGFbaV0gIT09IGJbaV0pIHsKICAgICAgeCA9IGFbaV0KICAgICAgeSA9IGJbaV0KICAgICAgYnJlYWsKICAgIH0KICB9CgogIGlmICh4IDwgeSkgcmV0dXJuIC0xCiAgaWYgKHkgPCB4KSByZXR1cm4gMQogIHJldHVybiAwCn0KCkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHsKICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkgewogICAgY2FzZSAnaGV4JzoKICAgIGNhc2UgJ3V0ZjgnOgogICAgY2FzZSAndXRmLTgnOgogICAgY2FzZSAnYXNjaWknOgogICAgY2FzZSAnbGF0aW4xJzoKICAgIGNhc2UgJ2JpbmFyeSc6CiAgICBjYXNlICdiYXNlNjQnOgogICAgY2FzZSAndWNzMic6CiAgICBjYXNlICd1Y3MtMic6CiAgICBjYXNlICd1dGYxNmxlJzoKICAgIGNhc2UgJ3V0Zi0xNmxlJzoKICAgICAgcmV0dXJuIHRydWUKICAgIGRlZmF1bHQ6CiAgICAgIHJldHVybiBmYWxzZQogIH0KfQoKQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7CiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJykKICB9CgogIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgewogICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKQogIH0KCiAgdmFyIGkKICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsKICAgIGxlbmd0aCA9IDAKICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7CiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aAogICAgfQogIH0KCiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpCiAgdmFyIHBvcyA9IDAKICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkgewogICAgdmFyIGJ1ZiA9IGxpc3RbaV0KICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHsKICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpCiAgICB9CiAgICBidWYuY29weShidWZmZXIsIHBvcykKICAgIHBvcyArPSBidWYubGVuZ3RoCiAgfQogIHJldHVybiBidWZmZXIKfQoKZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykgewogIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkgewogICAgcmV0dXJuIHN0cmluZy5sZW5ndGgKICB9CiAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHN0cmluZykgfHwgaXNBcnJheUJ1ZmZlcihzdHJpbmcpKSB7CiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGgKICB9CiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7CiAgICBzdHJpbmcgPSAnJyArIHN0cmluZwogIH0KCiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGgKICBpZiAobGVuID09PSAwKSByZXR1cm4gMAoKICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb24KICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZQogIGZvciAoOzspIHsKICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgY2FzZSAnYXNjaWknOgogICAgICBjYXNlICdsYXRpbjEnOgogICAgICBjYXNlICdiaW5hcnknOgogICAgICAgIHJldHVybiBsZW4KICAgICAgY2FzZSAndXRmOCc6CiAgICAgIGNhc2UgJ3V0Zi04JzoKICAgICAgY2FzZSB1bmRlZmluZWQ6CiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoCiAgICAgIGNhc2UgJ3VjczInOgogICAgICBjYXNlICd1Y3MtMic6CiAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgICAgcmV0dXJuIGxlbiAqIDIKICAgICAgY2FzZSAnaGV4JzoKICAgICAgICByZXR1cm4gbGVuID4+PiAxCiAgICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGgKICAgICAgZGVmYXVsdDoKICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOAogICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkKICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWUKICAgIH0KICB9Cn0KQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoCgpmdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7CiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2UKCiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCAidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMiIgc2luY2UgaXQncyBhIHJlYWQtb25seQogIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuCgogIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZAogIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS4KICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLAogIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLgogIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkgewogICAgc3RhcnQgPSAwCiAgfQogIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyCiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy4KICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkgewogICAgcmV0dXJuICcnCiAgfQoKICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHsKICAgIGVuZCA9IHRoaXMubGVuZ3RoCiAgfQoKICBpZiAoZW5kIDw9IDApIHsKICAgIHJldHVybiAnJwogIH0KCiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC4KICBlbmQgPj4+PSAwCiAgc3RhcnQgPj4+PSAwCgogIGlmIChlbmQgPD0gc3RhcnQpIHsKICAgIHJldHVybiAnJwogIH0KCiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCcKCiAgd2hpbGUgKHRydWUpIHsKICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgY2FzZSAnaGV4JzoKICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZCkKCiAgICAgIGNhc2UgJ3V0ZjgnOgogICAgICBjYXNlICd1dGYtOCc6CiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKQoKICAgICAgY2FzZSAnYXNjaWknOgogICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpCgogICAgICBjYXNlICdsYXRpbjEnOgogICAgICBjYXNlICdiaW5hcnknOgogICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKQoKICAgICAgY2FzZSAnYmFzZTY0JzoKICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZCkKCiAgICAgIGNhc2UgJ3VjczInOgogICAgICBjYXNlICd1Y3MtMic6CiAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKQoKICAgICAgZGVmYXVsdDoKICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZykKICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpCiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlCiAgICB9CiAgfQp9CgovLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpCi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmAKLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnQKLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyCi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS4KLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0CkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZQoKZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkgewogIHZhciBpID0gYltuXQogIGJbbl0gPSBiW21dCiAgYlttXSA9IGkKfQoKQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkgewogIHZhciBsZW4gPSB0aGlzLmxlbmd0aAogIGlmIChsZW4gJSAyICE9PSAwKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKQogIH0KICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7CiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKQogIH0KICByZXR1cm4gdGhpcwp9CgpCdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7CiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoCiAgaWYgKGxlbiAlIDQgIT09IDApIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpCiAgfQogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHsKICAgIHN3YXAodGhpcywgaSwgaSArIDMpCiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMikKICB9CiAgcmV0dXJuIHRoaXMKfQoKQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkgewogIHZhciBsZW4gPSB0aGlzLmxlbmd0aAogIGlmIChsZW4gJSA4ICE9PSAwKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKQogIH0KICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7CiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KQogICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpCiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSkKICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KQogIH0KICByZXR1cm4gdGhpcwp9CgpCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkgewogIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aAogIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJwogIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aCkKICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykKfQoKQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHsKICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpCiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlCiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwCn0KCkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkgewogIHZhciBzdHIgPSAnJwogIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTCiAgaWYgKHRoaXMubGVuZ3RoID4gMCkgewogICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJykKICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICcKICB9CiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPicKfQoKQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHsKICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJykKICB9CgogIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7CiAgICBzdGFydCA9IDAKICB9CiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7CiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMAogIH0KICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHsKICAgIHRoaXNTdGFydCA9IDAKICB9CiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkgewogICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoCiAgfQoKICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKQogIH0KCiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkgewogICAgcmV0dXJuIDAKICB9CiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7CiAgICByZXR1cm4gLTEKICB9CiAgaWYgKHN0YXJ0ID49IGVuZCkgewogICAgcmV0dXJuIDEKICB9CgogIHN0YXJ0ID4+Pj0gMAogIGVuZCA+Pj49IDAKICB0aGlzU3RhcnQgPj4+PSAwCiAgdGhpc0VuZCA+Pj49IDAKCiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDAKCiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0CiAgdmFyIHkgPSBlbmQgLSBzdGFydAogIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KQoKICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCkKICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKQoKICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7CiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHsKICAgICAgeCA9IHRoaXNDb3B5W2ldCiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldCiAgICAgIGJyZWFrCiAgICB9CiAgfQoKICBpZiAoeCA8IHkpIHJldHVybiAtMQogIGlmICh5IDwgeCkgcmV0dXJuIDEKICByZXR1cm4gMAp9CgovLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsCi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuCi8vCi8vIEFyZ3VtZW50czoKLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2gKLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXIKLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyCi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nCi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mCmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikgewogIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaAogIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTEKCiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQKICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7CiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQKICAgIGJ5dGVPZmZzZXQgPSAwCiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikgewogICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmYKICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgewogICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwCiAgfQogIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci4KICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHsKICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sICJmb28iLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXIKICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKQogIH0KCiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXIKICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldAogIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHsKICAgIGlmIChkaXIpIHJldHVybiAtMQogICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDEKICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7CiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMAogICAgZWxzZSByZXR1cm4gLTEKICB9CgogIC8vIE5vcm1hbGl6ZSB2YWwKICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHsKICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpCiAgfQoKICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZgogIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkgewogICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlscwogICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuIC0xCiAgICB9CiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKQogIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHsKICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XQogICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7CiAgICAgIGlmIChkaXIpIHsKICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KQogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KQogICAgICB9CiAgICB9CiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikKICB9CgogIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpCn0KCmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKICB2YXIgaW5kZXhTaXplID0gMQogIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoCiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGgKCiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHsKICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpCiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fAogICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHsKICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7CiAgICAgICAgcmV0dXJuIC0xCiAgICAgIH0KICAgICAgaW5kZXhTaXplID0gMgogICAgICBhcnJMZW5ndGggLz0gMgogICAgICB2YWxMZW5ndGggLz0gMgogICAgICBieXRlT2Zmc2V0IC89IDIKICAgIH0KICB9CgogIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkgewogICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkgewogICAgICByZXR1cm4gYnVmW2ldCiAgICB9IGVsc2UgewogICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKQogICAgfQogIH0KCiAgdmFyIGkKICBpZiAoZGlyKSB7CiAgICB2YXIgZm91bmRJbmRleCA9IC0xCiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHsKICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkgewogICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGkKICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplCiAgICAgIH0gZWxzZSB7CiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4CiAgICAgICAgZm91bmRJbmRleCA9IC0xCiAgICAgIH0KICAgIH0KICB9IGVsc2UgewogICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGgKICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7CiAgICAgIHZhciBmb3VuZCA9IHRydWUKICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykgewogICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHsKICAgICAgICAgIGZvdW5kID0gZmFsc2UKICAgICAgICAgIGJyZWFrCiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGkKICAgIH0KICB9CgogIHJldHVybiAtMQp9CgpCdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMQp9CgpCdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7CiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpCn0KCkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSkKfQoKZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDAKICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldAogIGlmICghbGVuZ3RoKSB7CiAgICBsZW5ndGggPSByZW1haW5pbmcKICB9IGVsc2UgewogICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCkKICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHsKICAgICAgbGVuZ3RoID0gcmVtYWluaW5nCiAgICB9CiAgfQoKICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0cwogIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoCiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpCgogIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7CiAgICBsZW5ndGggPSBzdHJMZW4gLyAyCiAgfQogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpCiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGkKICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZAogIH0KICByZXR1cm4gaQp9CgpmdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpCn0KCmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKQp9CgpmdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQp9CgpmdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKQp9CgpmdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHsKICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKQogIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkgewogICAgZW5jb2RpbmcgPSAndXRmOCcKICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoCiAgICBvZmZzZXQgPSAwCiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpCiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykgewogICAgZW5jb2RpbmcgPSBvZmZzZXQKICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoCiAgICBvZmZzZXQgPSAwCiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSkKICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHsKICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHsKICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwCiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JwogICAgfSBlbHNlIHsKICAgICAgZW5jb2RpbmcgPSBsZW5ndGgKICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkCiAgICB9CiAgfSBlbHNlIHsKICAgIHRocm93IG5ldyBFcnJvcigKICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJwogICAgKQogIH0KCiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0CiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nCgogIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKQogIH0KCiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCcKCiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2UKICBmb3IgKDs7KSB7CiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgIGNhc2UgJ2hleCc6CiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpCgogICAgICBjYXNlICd1dGY4JzoKICAgICAgY2FzZSAndXRmLTgnOgogICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCiAgICAgIGNhc2UgJ2FzY2lpJzoKICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQoKICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgY2FzZSAnYmluYXJ5JzoKICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCiAgICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGUKICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCiAgICAgIGNhc2UgJ3VjczInOgogICAgICBjYXNlICd1Y3MtMic6CiAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQoKICAgICAgZGVmYXVsdDoKICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZykKICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpCiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlCiAgICB9CiAgfQp9CgpCdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7CiAgcmV0dXJuIHsKICAgIHR5cGU6ICdCdWZmZXInLAogICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApCiAgfQp9CgpmdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7CiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkgewogICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZikKICB9IGVsc2UgewogICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSkKICB9Cn0KCmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7CiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKQogIHZhciByZXMgPSBbXQoKICB2YXIgaSA9IHN0YXJ0CiAgd2hpbGUgKGkgPCBlbmQpIHsKICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV0KICAgIHZhciBjb2RlUG9pbnQgPSBudWxsCiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDQKICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzCiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMgogICAgICA6IDEKCiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7CiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnQKCiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkgewogICAgICAgIGNhc2UgMToKICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7CiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZQogICAgICAgICAgfQogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlIDI6CiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXQogICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHsKICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpCiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RikgewogICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlIDM6CiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXQogICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXQogICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7CiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKQogICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7CiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludAogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBicmVhawogICAgICAgIGNhc2UgNDoKICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdCiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdCiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXQogICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHsKICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpCiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkgewogICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkgewogICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhCiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGUKICAgICAgY29kZVBvaW50ID0gMHhGRkZECiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxCiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikgewogICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKQogICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMAogICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApCiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGCiAgICB9CgogICAgcmVzLnB1c2goY29kZVBvaW50KQogICAgaSArPSBieXRlc1BlclNlcXVlbmNlCiAgfQoKICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcykKfQoKLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoCi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy4KLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eQp2YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDAKCmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykgewogIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aAogIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHsKICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKQogIH0KCiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCAiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkIi4KICB2YXIgcmVzID0gJycKICB2YXIgaSA9IDAKICB3aGlsZSAoaSA8IGxlbikgewogICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoCiAgICAgIFN0cmluZywKICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKQogICAgKQogIH0KICByZXR1cm4gcmVzCn0KCmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkgewogIHZhciByZXQgPSAnJwogIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCkKCiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpCiAgfQogIHJldHVybiByZXQKfQoKZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkgewogIHZhciByZXQgPSAnJwogIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCkKCiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSkKICB9CiAgcmV0dXJuIHJldAp9CgpmdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7CiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGgKCiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMAogIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW4KCiAgdmFyIG91dCA9ICcnCiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgIG91dCArPSB0b0hleChidWZbaV0pCiAgfQogIHJldHVybiBvdXQKfQoKZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHsKICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCkKICB2YXIgcmVzID0gJycKICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7CiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKQogIH0KICByZXR1cm4gcmVzCn0KCkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkgewogIHZhciBsZW4gPSB0aGlzLmxlbmd0aAogIHN0YXJ0ID0gfn5zdGFydAogIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQKCiAgaWYgKHN0YXJ0IDwgMCkgewogICAgc3RhcnQgKz0gbGVuCiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDAKICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7CiAgICBzdGFydCA9IGxlbgogIH0KCiAgaWYgKGVuZCA8IDApIHsKICAgIGVuZCArPSBsZW4KICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwCiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHsKICAgIGVuZCA9IGxlbgogIH0KCiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydAoKICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKQogIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlCiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGUKICByZXR1cm4gbmV3QnVmCn0KCi8qCiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLgogKi8KZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHsKICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKQogIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJykKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCkKCiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XQogIHZhciBtdWwgPSAxCiAgdmFyIGkgPSAwCiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsCiAgfQoKICByZXR1cm4gdmFsCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIHsKICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpCiAgfQoKICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdCiAgdmFyIG11bCA9IDEKICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWwKICB9CgogIHJldHVybiB2YWwKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKQogIHJldHVybiB0aGlzW29mZnNldF0KfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKQogIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpCiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCkKCiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8CiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHwKICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArCiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCgogIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArCiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHwKICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHwKICAgIHRoaXNbb2Zmc2V0ICsgM10pCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKQoKICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdCiAgdmFyIG11bCA9IDEKICB2YXIgaSA9IDAKICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkgewogICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWwKICB9CiAgbXVsICo9IDB4ODAKCiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkKCiAgcmV0dXJuIHZhbAp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCkKCiAgdmFyIGkgPSBieXRlTGVuZ3RoCiAgdmFyIG11bCA9IDEKICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldCiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsCiAgfQogIG11bCAqPSAweDgwCgogIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpCgogIHJldHVybiB2YWwKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCkKICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pCiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpCiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpCiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbAp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKQogIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KQogIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWwKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCkKCiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHwKICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHwKICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8CiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNCkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCkKCiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHwKICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8CiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8CiAgICAodGhpc1tvZmZzZXQgKyAzXSkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCkKICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNCkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKQogIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOCkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKQogIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpCn0KCmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCciYnVmZmVyIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJykKICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCcidmFsdWUiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKQogIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJykKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxCiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCkKICB9CgogIHZhciBtdWwgPSAxCiAgdmFyIGkgPSAwCiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGCiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRgogIH0KCiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxCiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCkKICB9CgogIHZhciBpID0gYnl0ZUxlbmd0aCAtIDEKICB2YXIgbXVsID0gMQogIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkYKICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRgogIH0KCiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApCiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgMQp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkKICByZXR1cm4gb2Zmc2V0ICsgMgp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgMgp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCkKICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCkKICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNikKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDQKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApCiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCkKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNikKICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KQogIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKQogIHJldHVybiBvZmZzZXQgKyA0Cn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSkKCiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCkKICB9CgogIHZhciBpID0gMAogIHZhciBtdWwgPSAxCiAgdmFyIHN1YiA9IDAKICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkYKICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkgewogICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHsKICAgICAgc3ViID0gMQogICAgfQogICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRgogIH0KCiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIHsKICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKQoKICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KQogIH0KCiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMQogIHZhciBtdWwgPSAxCiAgdmFyIHN1YiA9IDAKICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGCiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkgewogICAgICBzdWIgPSAxCiAgICB9CiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGCiAgfQoKICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aAp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKQogIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDEKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApCiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZikKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KQogIHJldHVybiBvZmZzZXQgKyAyCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgMgp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNikKICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCkKICByZXR1cm4gb2Zmc2V0ICsgNAp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKQogIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpCiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgNAp9CgpmdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikgewogIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJykKICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpCn0KCmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgewogICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpCiAgfQogIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KQogIHJldHVybiBvZmZzZXQgKyA0Cn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KQp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpCn0KCmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIHsKICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpCiAgfQogIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KQogIHJldHVybiBvZmZzZXQgKyA4Cn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KQp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpCn0KCi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aCkKQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkgewogIGlmICghc3RhcnQpIHN0YXJ0ID0gMAogIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGgKICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoCiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwCiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0CgogIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZQogIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMAogIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMAoKICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zCiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKQogIH0KICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpCiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpCgogIC8vIEFyZSB3ZSBvb2I/CiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aAogIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkgewogICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQKICB9CgogIHZhciBsZW4gPSBlbmQgLSBzdGFydAogIHZhciBpCgogIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkgewogICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kCiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkgewogICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XQogICAgfQogIH0gZWxzZSBpZiAobGVuIDwgMTAwMCkgewogICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydAogICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7CiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdCiAgICB9CiAgfSBlbHNlIHsKICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKAogICAgICB0YXJnZXQsCiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwKICAgICAgdGFyZ2V0U3RhcnQKICAgICkKICB9CgogIHJldHVybiBsZW4KfQoKLy8gVXNhZ2U6Ci8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKQovLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSkKLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pCkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHsKICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOgogIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykgewogICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHsKICAgICAgZW5jb2RpbmcgPSBzdGFydAogICAgICBzdGFydCA9IDAKICAgICAgZW5kID0gdGhpcy5sZW5ndGgKICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHsKICAgICAgZW5jb2RpbmcgPSBlbmQKICAgICAgZW5kID0gdGhpcy5sZW5ndGgKICAgIH0KICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7CiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMCkKICAgICAgaWYgKGNvZGUgPCAyNTYpIHsKICAgICAgICB2YWwgPSBjb2RlCiAgICAgIH0KICAgIH0KICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHsKICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpCiAgICB9CiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7CiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZykKICAgIH0KICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7CiAgICB2YWwgPSB2YWwgJiAyNTUKICB9CgogIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LgogIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpCiAgfQoKICBpZiAoZW5kIDw9IHN0YXJ0KSB7CiAgICByZXR1cm4gdGhpcwogIH0KCiAgc3RhcnQgPSBzdGFydCA+Pj4gMAogIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDAKCiAgaWYgKCF2YWwpIHZhbCA9IDAKCiAgdmFyIGkKICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHsKICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgdGhpc1tpXSA9IHZhbAogICAgfQogIH0gZWxzZSB7CiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKQogICAgICA/IHZhbAogICAgICA6IG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykKICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGgKICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7CiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dCiAgICB9CiAgfQoKICByZXR1cm4gdGhpcwp9CgovLyBIRUxQRVIgRlVOQ1RJT05TCi8vID09PT09PT09PT09PT09PT0KCnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2cKCmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHsKICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXG4gYW5kIFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90CiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJykKICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnCiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJycKICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3QKICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHsKICAgIHN0ciA9IHN0ciArICc9JwogIH0KICByZXR1cm4gc3RyCn0KCmZ1bmN0aW9uIHRvSGV4IChuKSB7CiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpCiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpCn0KCmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7CiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eQogIHZhciBjb2RlUG9pbnQKICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aAogIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbAogIHZhciBieXRlcyA9IFtdCgogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpCgogICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudAogICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHsKICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWQKICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7CiAgICAgICAgLy8gbm8gbGVhZCB5ZXQKICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7CiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsCiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCkKICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7CiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkCiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCkKICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgfQoKICAgICAgICAvLyB2YWxpZCBsZWFkCiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludAoKICAgICAgICBjb250aW51ZQogICAgICB9CgogICAgICAvLyAyIGxlYWRzIGluIGEgcm93CiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHsKICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCkKICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50CiAgICAgICAgY29udGludWUKICAgICAgfQoKICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXIKICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMAogICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7CiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWQKICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpCiAgICB9CgogICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGwKCiAgICAvLyBlbmNvZGUgdXRmOAogICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHsKICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrCiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KQogICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkgewogICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWsKICAgICAgYnl0ZXMucHVzaCgKICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCwKICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MAogICAgICApCiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHsKICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrCiAgICAgIGJ5dGVzLnB1c2goCiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsCiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLAogICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwCiAgICAgICkKICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHsKICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrCiAgICAgIGJ5dGVzLnB1c2goCiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLAogICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCwKICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsCiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODAKICAgICAgKQogICAgfSBlbHNlIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKQogICAgfQogIH0KCiAgcmV0dXJuIGJ5dGVzCn0KCmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7CiAgdmFyIGJ5dGVBcnJheSA9IFtdCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLgogICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKQogIH0KICByZXR1cm4gYnl0ZUFycmF5Cn0KCmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7CiAgdmFyIGMsIGhpLCBsbwogIHZhciBieXRlQXJyYXkgPSBbXQogIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWsKCiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSkKICAgIGhpID0gYyA+PiA4CiAgICBsbyA9IGMgJSAyNTYKICAgIGJ5dGVBcnJheS5wdXNoKGxvKQogICAgYnl0ZUFycmF5LnB1c2goaGkpCiAgfQoKICByZXR1cm4gYnl0ZUFycmF5Cn0KCmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikgewogIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSkKfQoKZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVhawogICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldCiAgfQogIHJldHVybiBpCn0KCi8vIEFycmF5QnVmZmVycyBmcm9tIGFub3RoZXIgY29udGV4dCAoaS5lLiBhbiBpZnJhbWUpIGRvIG5vdCBwYXNzIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sKLy8gYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NgpmdW5jdGlvbiBpc0FycmF5QnVmZmVyIChvYmopIHsKICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwKICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJgogICAgICB0eXBlb2Ygb2JqLmJ5dGVMZW5ndGggPT09ICdudW1iZXInKQp9CgovLyBOb2RlIDAuMTAgc3VwcG9ydHMgYEFycmF5QnVmZmVyYCBidXQgbGFja3MgYEFycmF5QnVmZmVyLmlzVmlld2AKZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcgKG9iaikgewogIHJldHVybiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikKfQoKZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikgewogIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZQp9Cgp9LHsiYmFzZTY0LWpzIjo5NywiaWVlZTc1NCI6MTAzfV0sOTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXIKdmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9OwoKLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0Ci8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpcwovLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhCi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuCgp2YXIgY2FjaGVkU2V0VGltZW91dDsKdmFyIGNhY2hlZENsZWFyVGltZW91dDsKCmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTsKfQpmdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHsKICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7Cn0KKGZ1bmN0aW9uICgpIHsKICAgIHRyeSB7CiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0OwogICAgICAgIH0KICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDsKICAgIH0KICAgIHRyeSB7CiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7CiAgICAgICAgfQogICAgfSBjYXRjaCAoZSkgewogICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7CiAgICB9Cn0gKCkpCmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7CiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkgewogICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9ucwogICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7CiAgICB9CiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZAogICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7CiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7CiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTsKICAgIH0KICAgIHRyeSB7CiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzcwogICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7CiAgICB9IGNhdGNoKGUpewogICAgICAgIHRyeSB7CiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseQogICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7CiAgICAgICAgfSBjYXRjaChlKXsKICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IKICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApOwogICAgICAgIH0KICAgIH0KCgp9CmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHsKICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkgewogICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9ucwogICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTsKICAgIH0KICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWQKICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkgewogICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDsKICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7CiAgICB9CiAgICB0cnkgewogICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3MKICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7CiAgICB9IGNhdGNoIChlKXsKICAgICAgICB0cnkgewogICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5CiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpOwogICAgICAgIH0gY2F0Y2ggKGUpewogICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci4KICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dAogICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTsKICAgICAgICB9CiAgICB9CgoKCn0KdmFyIHF1ZXVlID0gW107CnZhciBkcmFpbmluZyA9IGZhbHNlOwp2YXIgY3VycmVudFF1ZXVlOwp2YXIgcXVldWVJbmRleCA9IC0xOwoKZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkgewogICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7CiAgICAgICAgcmV0dXJuOwogICAgfQogICAgZHJhaW5pbmcgPSBmYWxzZTsKICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7CiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTsKICAgIH0gZWxzZSB7CiAgICAgICAgcXVldWVJbmRleCA9IC0xOwogICAgfQogICAgaWYgKHF1ZXVlLmxlbmd0aCkgewogICAgICAgIGRyYWluUXVldWUoKTsKICAgIH0KfQoKZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHsKICAgIGlmIChkcmFpbmluZykgewogICAgICAgIHJldHVybjsKICAgIH0KICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spOwogICAgZHJhaW5pbmcgPSB0cnVlOwoKICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7CiAgICB3aGlsZShsZW4pIHsKICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTsKICAgICAgICBxdWV1ZSA9IFtdOwogICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHsKICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkgewogICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHF1ZXVlSW5kZXggPSAtMTsKICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7CiAgICB9CiAgICBjdXJyZW50UXVldWUgPSBudWxsOwogICAgZHJhaW5pbmcgPSBmYWxzZTsKICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTsKfQoKcHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHsKICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTsKICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgewogICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldOwogICAgICAgIH0KICAgIH0KICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7CiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykgewogICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7CiAgICB9Cn07CgovLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzCmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkgewogICAgdGhpcy5mdW4gPSBmdW47CiAgICB0aGlzLmFycmF5ID0gYXJyYXk7Cn0KSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkgewogICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7Cn07CnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7CnByb2Nlc3MuYnJvd3NlciA9IHRydWU7CnByb2Nlc3MuZW52ID0ge307CnByb2Nlc3MuYXJndiA9IFtdOwpwcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXMKcHJvY2Vzcy52ZXJzaW9ucyA9IHt9OwoKZnVuY3Rpb24gbm9vcCgpIHt9Cgpwcm9jZXNzLm9uID0gbm9vcDsKcHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7CnByb2Nlc3Mub25jZSA9IG5vb3A7CnByb2Nlc3Mub2ZmID0gbm9vcDsKcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7CnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDsKcHJvY2Vzcy5lbWl0ID0gbm9vcDsKcHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wOwpwcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wOwoKcHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfQoKcHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHsKICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTsKfTsKCnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07CnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpOwp9Owpwcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9OwoKfSx7fV0sMTAwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChCdWZmZXIpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgovLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmAKLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuCgpmdW5jdGlvbiBpc0FycmF5KGFyZykgewogIGlmIChBcnJheS5pc0FycmF5KSB7CiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpOwogIH0KICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJzsKfQpleHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5OwoKZnVuY3Rpb24gaXNCb29sZWFuKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7Cn0KZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47CgpmdW5jdGlvbiBpc051bGwoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PT0gbnVsbDsKfQpleHBvcnRzLmlzTnVsbCA9IGlzTnVsbDsKCmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykgewogIHJldHVybiBhcmcgPT0gbnVsbDsKfQpleHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7CgpmdW5jdGlvbiBpc051bWJlcihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7Cn0KZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyOwoKZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnOwp9CmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZzsKCmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJzsKfQpleHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7CgpmdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHsKICByZXR1cm4gYXJnID09PSB2b2lkIDA7Cn0KZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkOwoKZnVuY3Rpb24gaXNSZWdFeHAocmUpIHsKICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJzsKfQpleHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7CgpmdW5jdGlvbiBpc09iamVjdChhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsOwp9CmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDsKCmZ1bmN0aW9uIGlzRGF0ZShkKSB7CiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7Cn0KZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7CgpmdW5jdGlvbiBpc0Vycm9yKGUpIHsKICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7Cn0KZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjsKCmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7Cn0KZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjsKCmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykgewogIHJldHVybiBhcmcgPT09IG51bGwgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8CiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8CiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8CiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sCiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnOwp9CmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTsKCmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7CgpmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7CiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTsKfQoKfSkuY2FsbCh0aGlzLHsiaXNCdWZmZXIiOl9kZXJlcV8oIi4uLy4uL2lzLWJ1ZmZlci9pbmRleC5qcyIpfSkKfSx7Ii4uLy4uL2lzLWJ1ZmZlci9pbmRleC5qcyI6MTA1fV0sMTAxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIG9uY2UgPSBfZGVyZXFfKCdvbmNlJyk7Cgp2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307Cgp2YXIgaXNSZXF1ZXN0ID0gZnVuY3Rpb24oc3RyZWFtKSB7CglyZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nOwp9OwoKdmFyIGlzQ2hpbGRQcm9jZXNzID0gZnVuY3Rpb24oc3RyZWFtKSB7CglyZXR1cm4gc3RyZWFtLnN0ZGlvICYmIEFycmF5LmlzQXJyYXkoc3RyZWFtLnN0ZGlvKSAmJiBzdHJlYW0uc3RkaW8ubGVuZ3RoID09PSAzCn07Cgp2YXIgZW9zID0gZnVuY3Rpb24oc3RyZWFtLCBvcHRzLCBjYWxsYmFjaykgewoJaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7CglpZiAoIW9wdHMpIG9wdHMgPSB7fTsKCgljYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7CgoJdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlOwoJdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwoJdmFyIHJlYWRhYmxlID0gb3B0cy5yZWFkYWJsZSB8fCAob3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlKTsKCXZhciB3cml0YWJsZSA9IG9wdHMud3JpdGFibGUgfHwgKG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZSk7CgoJdmFyIG9ubGVnYWN5ZmluaXNoID0gZnVuY3Rpb24oKSB7CgkJaWYgKCFzdHJlYW0ud3JpdGFibGUpIG9uZmluaXNoKCk7Cgl9OwoKCXZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uKCkgewoJCXdyaXRhYmxlID0gZmFsc2U7CgkJaWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pOwoJfTsKCgl2YXIgb25lbmQgPSBmdW5jdGlvbigpIHsKCQlyZWFkYWJsZSA9IGZhbHNlOwoJCWlmICghd3JpdGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTsKCX07CgoJdmFyIG9uZXhpdCA9IGZ1bmN0aW9uKGV4aXRDb2RlKSB7CgkJY2FsbGJhY2suY2FsbChzdHJlYW0sIGV4aXRDb2RlID8gbmV3IEVycm9yKCdleGl0ZWQgd2l0aCBlcnJvciBjb2RlOiAnICsgZXhpdENvZGUpIDogbnVsbCk7Cgl9OwoKCXZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7CgkJY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7Cgl9OwoKCXZhciBvbmNsb3NlID0gZnVuY3Rpb24oKSB7CgkJaWYgKHJlYWRhYmxlICYmICEocnMgJiYgcnMuZW5kZWQpKSByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIG5ldyBFcnJvcigncHJlbWF0dXJlIGNsb3NlJykpOwoJCWlmICh3cml0YWJsZSAmJiAhKHdzICYmIHdzLmVuZGVkKSkgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBuZXcgRXJyb3IoJ3ByZW1hdHVyZSBjbG9zZScpKTsKCX07CgoJdmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uKCkgewoJCXN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTsKCX07CgoJaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7CgkJc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTsKCQlzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7CgkJaWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpOwoJCWVsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTsKCX0gZWxzZSBpZiAod3JpdGFibGUgJiYgIXdzKSB7IC8vIGxlZ2FjeSBzdHJlYW1zCgkJc3RyZWFtLm9uKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7CgkJc3RyZWFtLm9uKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTsKCX0KCglpZiAoaXNDaGlsZFByb2Nlc3Moc3RyZWFtKSkgc3RyZWFtLm9uKCdleGl0Jywgb25leGl0KTsKCglzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKTsKCXN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpOwoJaWYgKG9wdHMuZXJyb3IgIT09IGZhbHNlKSBzdHJlYW0ub24oJ2Vycm9yJywgb25lcnJvcik7CglzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7CgoJcmV0dXJuIGZ1bmN0aW9uKCkgewoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7CgkJc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpOwoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7CgkJaWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpOwoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpOwoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXhpdCcsIG9uZXhpdCk7CgkJc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7CgkJc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpOwoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTsKCX07Cn07Cgptb2R1bGUuZXhwb3J0cyA9IGVvczsKCn0seyJvbmNlIjoxMTZ9XSwxMDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgpmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7CiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9OwogIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7Cn0KbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7CgovLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLngKRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjsKCkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDsKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkOwoKLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlCi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuCkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7CgovLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3MKLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuCkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikgewogIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpCiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpOwogIHRoaXMuX21heExpc3RlbmVycyA9IG47CiAgcmV0dXJuIHRoaXM7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7CiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVyczsKCiAgaWYgKCF0aGlzLl9ldmVudHMpCiAgICB0aGlzLl9ldmVudHMgPSB7fTsKCiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LgogIGlmICh0eXBlID09PSAnZXJyb3InKSB7CiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fAogICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkgewogICAgICBlciA9IGFyZ3VtZW50c1sxXTsKICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHsKICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnQKICAgICAgfSBlbHNlIHsKICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyCiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkICJlcnJvciIgZXZlbnQuICgnICsgZXIgKyAnKScpOwogICAgICAgIGVyci5jb250ZXh0ID0gZXI7CiAgICAgICAgdGhyb3cgZXJyOwogICAgICB9CiAgICB9CiAgfQoKICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdOwoKICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpCiAgICByZXR1cm4gZmFsc2U7CgogIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7CiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHsKICAgICAgLy8gZmFzdCBjYXNlcwogICAgICBjYXNlIDE6CiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDI6CiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgMzoKICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pOwogICAgICAgIGJyZWFrOwogICAgICAvLyBzbG93ZXIKICAgICAgZGVmYXVsdDoKICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgfQogIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHsKICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOwogICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpOwogICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsKICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykKICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpOwogIH0KCiAgcmV0dXJuIHRydWU7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHsKICB2YXIgbTsKCiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSkKICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CgogIGlmICghdGhpcy5fZXZlbnRzKQogICAgdGhpcy5fZXZlbnRzID0ge307CgogIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09ICJuZXdMaXN0ZW5lciIhIEJlZm9yZQogIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0ICJuZXdMaXN0ZW5lciIuCiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcikKICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLAogICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID8KICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTsKCiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pCiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC4KICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyOwogIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpCiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuCiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7CiAgZWxzZQogICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuCiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07CgogIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrCiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHsKICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkgewogICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzOwogICAgfSBlbHNlIHsKICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzOwogICAgfQoKICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7CiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlOwogICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICsKICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICsKICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJywKICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTsKICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMAogICAgICAgIGNvbnNvbGUudHJhY2UoKTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIHRoaXM7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjsKCkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7CiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSkKICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CgogIHZhciBmaXJlZCA9IGZhbHNlOwoKICBmdW5jdGlvbiBnKCkgewogICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTsKCiAgICBpZiAoIWZpcmVkKSB7CiAgICAgIGZpcmVkID0gdHJ1ZTsKICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgIH0KICB9CgogIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjsKICB0aGlzLm9uKHR5cGUsIGcpOwoKICByZXR1cm4gdGhpczsKfTsKCi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkCkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikgewogIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpOwoKICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKQogICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTsKCiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSkKICAgIHJldHVybiB0aGlzOwoKICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdOwogIGxlbmd0aCA9IGxpc3QubGVuZ3RoOwogIHBvc2l0aW9uID0gLTE7CgogIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fAogICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHsKICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07CiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKQogICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpOwoKICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7CiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7CiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fAogICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7CiAgICAgICAgcG9zaXRpb24gPSBpOwogICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CgogICAgaWYgKHBvc2l0aW9uIDwgMCkKICAgICAgcmV0dXJuIHRoaXM7CgogICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7CiAgICAgIGxpc3QubGVuZ3RoID0gMDsKICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTsKICAgIH0gZWxzZSB7CiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTsKICAgIH0KCiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKQogICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpOwogIH0KCiAgcmV0dXJuIHRoaXM7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHsKICB2YXIga2V5LCBsaXN0ZW5lcnM7CgogIGlmICghdGhpcy5fZXZlbnRzKQogICAgcmV0dXJuIHRoaXM7CgogIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXQKICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikgewogICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApCiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9OwogICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKQogICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdOwogICAgcmV0dXJuIHRoaXM7CiAgfQoKICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHMKICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgewogICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7CiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlOwogICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpOwogICAgfQogICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7CiAgICB0aGlzLl9ldmVudHMgPSB7fTsKICAgIHJldHVybiB0aGlzOwogIH0KCiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdOwoKICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7CiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7CiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHsKICAgIC8vIExJRk8gb3JkZXIKICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKQogICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pOwogIH0KICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdOwoKICByZXR1cm4gdGhpczsKfTsKCkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkgewogIHZhciByZXQ7CiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSkKICAgIHJldCA9IFtdOwogIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSkKICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dOwogIGVsc2UKICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpOwogIHJldHVybiByZXQ7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7CiAgaWYgKHRoaXMuX2V2ZW50cykgewogICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07CgogICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpCiAgICAgIHJldHVybiAxOwogICAgZWxzZSBpZiAoZXZsaXN0ZW5lcikKICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoOwogIH0KICByZXR1cm4gMDsKfTsKCkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkgewogIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7Cn07CgpmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nOwp9CgpmdW5jdGlvbiBpc051bWJlcihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7Cn0KCmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7Cn0KCmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykgewogIHJldHVybiBhcmcgPT09IHZvaWQgMDsKfQoKfSx7fV0sMTAzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHsKICB2YXIgZSwgbQogIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxCiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEKICB2YXIgZUJpYXMgPSBlTWF4ID4+IDEKICB2YXIgbkJpdHMgPSAtNwogIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAKICB2YXIgZCA9IGlzTEUgPyAtMSA6IDEKICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXQoKICBpICs9IGQKCiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSkKICBzID4+PSAoLW5CaXRzKQogIG5CaXRzICs9IGVMZW4KICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fQoKICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKQogIGUgPj49ICgtbkJpdHMpCiAgbkJpdHMgKz0gbUxlbgogIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9CgogIGlmIChlID09PSAwKSB7CiAgICBlID0gMSAtIGVCaWFzCiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7CiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSkKICB9IGVsc2UgewogICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKQogICAgZSA9IGUgLSBlQmlhcwogIH0KICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKQp9CgpleHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7CiAgdmFyIGUsIG0sIGMKICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMQogIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxCiAgdmFyIGVCaWFzID0gZU1heCA+PiAxCiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKQogIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSkKICB2YXIgZCA9IGlzTEUgPyAxIDogLTEKICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMAoKICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKQoKICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkgewogICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwCiAgICBlID0gZU1heAogIH0gZWxzZSB7CiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMikKICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHsKICAgICAgZS0tCiAgICAgIGMgKj0gMgogICAgfQogICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7CiAgICAgIHZhbHVlICs9IHJ0IC8gYwogICAgfSBlbHNlIHsKICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpCiAgICB9CiAgICBpZiAodmFsdWUgKiBjID49IDIpIHsKICAgICAgZSsrCiAgICAgIGMgLz0gMgogICAgfQoKICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkgewogICAgICBtID0gMAogICAgICBlID0gZU1heAogICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkgewogICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbikKICAgICAgZSA9IGUgKyBlQmlhcwogICAgfSBlbHNlIHsKICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pCiAgICAgIGUgPSAwCiAgICB9CiAgfQoKICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fQoKICBlID0gKGUgPDwgbUxlbikgfCBtCiAgZUxlbiArPSBtTGVuCiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fQoKICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjgKfQoKfSx7fV0sMTA0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7CiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGUKICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3RvcikgewogICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3IKICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7CiAgICAgIGNvbnN0cnVjdG9yOiB7CiAgICAgICAgdmFsdWU6IGN0b3IsCiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsCiAgICAgICAgd3JpdGFibGU6IHRydWUsCiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICAgIH0KICAgIH0pOwogIH07Cn0gZWxzZSB7CiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnMKICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3RvcikgewogICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3IKICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9CiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlCiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpCiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3IKICB9Cn0KCn0se31dLDEwNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8qIQogKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyCiAqCiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPgogKiBAbGljZW5zZSAgTUlUCiAqLwoKLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZwovLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikgewogIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpCn0KCmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHsKICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKQp9CgovLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LgpmdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikgewogIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKQp9Cgp9LHt9XSwxMDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZzsKCm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7CiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nOwp9OwoKfSx7fV0sMTA3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKInVzZSBzdHJpY3QiOwoKLy8gdWludDMyICh0d28ncyBjb21wbGVtZW50KSBtYXgKLy8gbW9yZSBjb25zZXJ2YXRpdmUgdGhhbiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUgp2YXIgTUFYID0gNDI5NDk2NzI5NTsKdmFyIGlkQ291bnRlciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1BWCk7Cgptb2R1bGUuZXhwb3J0cyA9IGdldFVuaXF1ZUlkOwoKZnVuY3Rpb24gZ2V0VW5pcXVlSWQoKSB7CiAgaWRDb3VudGVyID0gKGlkQ291bnRlciArIDEpICUgTUFYOwogIHJldHVybiBpZENvdW50ZXI7Cn0KCn0se31dLDEwODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCnZhciBnZXRVbmlxdWVJZCA9IF9kZXJlcV8oJy4vZ2V0VW5pcXVlSWQnKTsKCm1vZHVsZS5leHBvcnRzID0gY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmU7CgpmdW5jdGlvbiBjcmVhdGVJZFJlbWFwTWlkZGxld2FyZSgpIHsKICByZXR1cm4gZnVuY3Rpb24gKHJlcSwgcmVzLCBuZXh0LCBlbmQpIHsKICAgIHZhciBvcmlnaW5hbElkID0gcmVxLmlkOwogICAgdmFyIG5ld0lkID0gZ2V0VW5pcXVlSWQoKTsKICAgIHJlcS5pZCA9IG5ld0lkOwogICAgcmVzLmlkID0gbmV3SWQ7CiAgICBuZXh0KGZ1bmN0aW9uIChkb25lKSB7CiAgICAgIHJlcS5pZCA9IG9yaWdpbmFsSWQ7CiAgICAgIHJlcy5pZCA9IG9yaWdpbmFsSWQ7CiAgICAgIGRvbmUoKTsKICAgIH0pOwogIH07Cn0KCn0seyIuL2dldFVuaXF1ZUlkIjoxMDd9XSwxMDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7Cgp2YXIgX3N0cmluZ2lmeSA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeScpOwoKdmFyIF9zdHJpbmdpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5naWZ5KTsKCnZhciBfY2xhc3NDYWxsQ2hlY2syID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7Cgp2YXIgX2NsYXNzQ2FsbENoZWNrMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NsYXNzQ2FsbENoZWNrMik7Cgp2YXIgX2NyZWF0ZUNsYXNzMiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpOwoKdmFyIF9jcmVhdGVDbGFzczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVDbGFzczIpOwoKZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0KCnZhciBhc3luYyA9IF9kZXJlcV8oJ2FzeW5jJyk7Cgp2YXIgUnBjRW5naW5lID0gZnVuY3Rpb24gKCkgewogIGZ1bmN0aW9uIFJwY0VuZ2luZSgpIHsKICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIFJwY0VuZ2luZSk7CgogICAgdGhpcy5fbWlkZGxld2FyZSA9IFtdOwogIH0KCiAgLy8KICAvLyBQdWJsaWMKICAvLwoKICAoMCwgX2NyZWF0ZUNsYXNzMy5kZWZhdWx0KShScGNFbmdpbmUsIFt7CiAgICBrZXk6ICdwdXNoJywKICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKG1pZGRsZXdhcmUpIHsKICAgICAgdGhpcy5fbWlkZGxld2FyZS5wdXNoKG1pZGRsZXdhcmUpOwogICAgfQogIH0sIHsKICAgIGtleTogJ2hhbmRsZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlKHJlcSwgY2IpIHsKICAgICAgLy8gYmF0Y2ggcmVxdWVzdCBzdXBwb3J0CiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcSkpIHsKICAgICAgICBhc3luYy5tYXAocmVxLCB0aGlzLl9oYW5kbGUuYmluZCh0aGlzKSwgY2IpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuX2hhbmRsZShyZXEsIGNiKTsKICAgICAgfQogICAgfQoKICAgIC8vCiAgICAvLyBQcml2YXRlCiAgICAvLwoKICB9LCB7CiAgICBrZXk6ICdfaGFuZGxlJywKICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlKHJlcSwgY2IpIHsKICAgICAgLy8gY3JlYXRlIHJlc3BvbnNlIG9iagogICAgICB2YXIgcmVzID0gewogICAgICAgIGlkOiByZXEuaWQsCiAgICAgICAganNvbnJwYzogcmVxLmpzb25ycGMKICAgICAgICAvLyBwcm9jZXNzIGFsbCBtaWRkbGV3YXJlCiAgICAgIH07dGhpcy5fcnVuTWlkZGxld2FyZShyZXEsIHJlcywgZnVuY3Rpb24gKGVycikgewogICAgICAgIC8vIHJldHVybiByZXNwb25zZQogICAgICAgIGNiKGVyciwgcmVzKTsKICAgICAgfSk7CiAgICB9CiAgfSwgewogICAga2V5OiAnX3J1bk1pZGRsZXdhcmUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9ydW5NaWRkbGV3YXJlKHJlcSwgcmVzLCBvbkRvbmUpIHsKICAgICAgdmFyIF90aGlzID0gdGhpczsKCiAgICAgIC8vIGZsb3cKICAgICAgYXN5bmMud2F0ZXJmYWxsKFtmdW5jdGlvbiAoY2IpIHsKICAgICAgICByZXR1cm4gX3RoaXMuX3J1bk1pZGRsZXdhcmVEb3duKHJlcSwgcmVzLCBjYik7CiAgICAgIH0sIGNoZWNrRm9yQ29tcGxldGlvbiwgZnVuY3Rpb24gKHJldHVybkhhbmRsZXJzLCBjYikgewogICAgICAgIHJldHVybiBfdGhpcy5fcnVuUmV0dXJuSGFuZGxlcnNVcChyZXR1cm5IYW5kbGVycywgY2IpOwogICAgICB9XSwgb25Eb25lKTsKCiAgICAgIGZ1bmN0aW9uIGNoZWNrRm9yQ29tcGxldGlvbihfcmVmLCBjYikgewogICAgICAgIHZhciBpc0NvbXBsZXRlID0gX3JlZi5pc0NvbXBsZXRlLAogICAgICAgICAgICByZXR1cm5IYW5kbGVycyA9IF9yZWYucmV0dXJuSGFuZGxlcnM7CgogICAgICAgIC8vIGZhaWwgaWYgbm90IGNvbXBsZXRlZAogICAgICAgIGlmICghKCdyZXN1bHQnIGluIHJlcykgJiYgISgnZXJyb3InIGluIHJlcykpIHsKICAgICAgICAgIHZhciByZXF1ZXN0Qm9keSA9ICgwLCBfc3RyaW5naWZ5Mi5kZWZhdWx0KShyZXEsIG51bGwsIDIpOwogICAgICAgICAgdmFyIG1lc3NhZ2UgPSAnSnNvblJwY0VuZ2luZSAtIHJlc3BvbnNlIGhhcyBubyBlcnJvciBvciByZXN1bHQgZm9yIHJlcXVlc3Q6XG4nICsgcmVxdWVzdEJvZHk7CiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKG1lc3NhZ2UpKTsKICAgICAgICB9CiAgICAgICAgaWYgKCFpc0NvbXBsZXRlKSB7CiAgICAgICAgICB2YXIgX3JlcXVlc3RCb2R5ID0gKDAsIF9zdHJpbmdpZnkyLmRlZmF1bHQpKHJlcSwgbnVsbCwgMik7CiAgICAgICAgICB2YXIgX21lc3NhZ2UgPSAnSnNvblJwY0VuZ2luZSAtIG5vdGhpbmcgZW5kZWQgcmVxdWVzdDpcbicgKyBfcmVxdWVzdEJvZHk7CiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKF9tZXNzYWdlKSk7CiAgICAgICAgfQogICAgICAgIC8vIGNvbnRpbnVlCiAgICAgICAgcmV0dXJuIGNiKG51bGwsIHJldHVybkhhbmRsZXJzKTsKICAgICAgfQoKICAgICAgZnVuY3Rpb24gcnVuUmV0dXJuSGFuZGxlcnMocmV0dXJuSGFuZGxlcnMsIGNiKSB7CiAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhyZXR1cm5IYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIsIG5leHQpIHsKICAgICAgICAgIHJldHVybiBoYW5kbGVyKG5leHQpOwogICAgICAgIH0sIG9uRG9uZSk7CiAgICAgIH0KICAgIH0KCiAgICAvLyB3YWxrcyBkb3duIHN0YWNrIG9mIG1pZGRsZXdhcmUKCiAgfSwgewogICAga2V5OiAnX3J1bk1pZGRsZXdhcmVEb3duJywKICAgIHZhbHVlOiBmdW5jdGlvbiBfcnVuTWlkZGxld2FyZURvd24ocmVxLCByZXMsIG9uRG9uZSkgewogICAgICAvLyBmb3IgY2xpbWJpbmcgYmFjayB1cCB0aGUgc3RhY2sKICAgICAgdmFyIGFsbFJldHVybkhhbmRsZXJzID0gW107CiAgICAgIC8vIGZsYWcgZm9yIHN0YWNrIHJldHVybgogICAgICB2YXIgaXNDb21wbGV0ZSA9IGZhbHNlOwoKICAgICAgLy8gZG93biBzdGFjayBvZiBtaWRkbGV3YXJlLCBjYWxsIGFuZCBjb2xsZWN0IG9wdGlvbmFsIGFsbFJldHVybkhhbmRsZXJzCiAgICAgIGFzeW5jLm1hcFNlcmllcyh0aGlzLl9taWRkbGV3YXJlLCBlYWNoTWlkZGxld2FyZSwgY29tcGxldGVSZXF1ZXN0KTsKCiAgICAgIC8vIHJ1bnMgYW4gaW5kaXZpZHVhbCBtaWRkbGV3YXJlCiAgICAgIGZ1bmN0aW9uIGVhY2hNaWRkbGV3YXJlKG1pZGRsZXdhcmUsIGNiKSB7CiAgICAgICAgLy8gc2tpcCBtaWRkbGV3YXJlIGlmIGNvbXBsZXRlZAogICAgICAgIGlmIChpc0NvbXBsZXRlKSByZXR1cm4gY2IoKTsKICAgICAgICAvLyBydW4gaW5kaXZpZHVhbCBtaWRkbGV3YXJlCiAgICAgICAgbWlkZGxld2FyZShyZXEsIHJlcywgbmV4dCwgZW5kKTsKCiAgICAgICAgZnVuY3Rpb24gbmV4dChyZXR1cm5IYW5kbGVyKSB7CiAgICAgICAgICAvLyBhZGQgcmV0dXJuIGhhbmRsZXIKICAgICAgICAgIGFsbFJldHVybkhhbmRsZXJzLnB1c2gocmV0dXJuSGFuZGxlcik7CiAgICAgICAgICBjYigpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBlbmQoZXJyKSB7CiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTsKICAgICAgICAgIC8vIG1hcmsgYXMgY29tcGxldGVkCiAgICAgICAgICBpc0NvbXBsZXRlID0gdHJ1ZTsKICAgICAgICAgIGNiKCk7CiAgICAgICAgfQogICAgICB9CgogICAgICAvLyByZXR1cm5zLCBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IGl0IGVuZGVkCiAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlUmVxdWVzdChlcnIpIHsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAvLyBwcmVwYXJlIGVycm9yIG1lc3NhZ2UKICAgICAgICAgIHJlcy5lcnJvciA9IHsKICAgICAgICAgICAgY29kZTogZXJyLmNvZGUgfHwgLTMyNjAzLAogICAgICAgICAgICBtZXNzYWdlOiBlcnIuc3RhY2sKICAgICAgICAgICAgLy8gcmV0dXJuIGVycm9yLWZpcnN0IGFuZCByZXMgd2l0aCBlcnIKICAgICAgICAgIH07cmV0dXJuIG9uRG9uZShlcnIsIHJlcyk7CiAgICAgICAgfQogICAgICAgIHZhciByZXR1cm5IYW5kbGVycyA9IGFsbFJldHVybkhhbmRsZXJzLmZpbHRlcihCb29sZWFuKS5yZXZlcnNlKCk7CiAgICAgICAgb25Eb25lKG51bGwsIHsgaXNDb21wbGV0ZTogaXNDb21wbGV0ZSwgcmV0dXJuSGFuZGxlcnM6IHJldHVybkhhbmRsZXJzIH0pOwogICAgICB9CiAgICB9CgogICAgLy8gY2xpbWJzIHRoZSBzdGFjayBjYWxsaW5nIHJldHVybiBoYW5kbGVycwoKICB9LCB7CiAgICBrZXk6ICdfcnVuUmV0dXJuSGFuZGxlcnNVcCcsCiAgICB2YWx1ZTogZnVuY3Rpb24gX3J1blJldHVybkhhbmRsZXJzVXAocmV0dXJuSGFuZGxlcnMsIGNiKSB7CiAgICAgIGFzeW5jLmVhY2hTZXJpZXMocmV0dXJuSGFuZGxlcnMsIGZ1bmN0aW9uIChoYW5kbGVyLCBuZXh0KSB7CiAgICAgICAgcmV0dXJuIGhhbmRsZXIobmV4dCk7CiAgICAgIH0sIGNiKTsKICAgIH0KICB9XSk7CiAgcmV0dXJuIFJwY0VuZ2luZTsKfSgpOwoKbW9kdWxlLmV4cG9ydHMgPSBScGNFbmdpbmU7Cgp9LHsiYXN5bmMiOjQsImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9qc29uL3N0cmluZ2lmeSI6NSwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrIjoxMywiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzIjoxNH1dLDExMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmNvbnN0IER1cGxleFN0cmVhbSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbScpLkR1cGxleAoKbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlCgpmdW5jdGlvbiBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlKCkgewogIGNvbnN0IGlkTWFwID0ge30KICBjb25zdCBzdHJlYW0gPSBuZXcgRHVwbGV4U3RyZWFtKHsgb2JqZWN0TW9kZTogdHJ1ZSwgcmVhZCwgd3JpdGUgfSkKCiAgY29uc3QgbWlkZGxld2FyZSA9IChyZXEsIHJlcywgbmV4dCwgZW5kKSA9PiB7CiAgICAvLyB3cml0ZSByZXEgdG8gc3RyZWFtCiAgICBzdHJlYW0ucHVzaChyZXEpCiAgICAvLyByZWdpc3RlciByZXF1ZXN0IG9uIGlkIG1hcAogICAgaWRNYXBbcmVxLmlkXSA9IHsgcmVxLCByZXMsIG5leHQsIGVuZCB9CiAgfQoKICBtaWRkbGV3YXJlLnN0cmVhbSA9IHN0cmVhbQogIAogIHJldHVybiBtaWRkbGV3YXJlCgogIGZ1bmN0aW9uIHJlYWQgKCkgewogICAgcmV0dXJuIGZhbHNlCiAgfQoKICBmdW5jdGlvbiB3cml0ZSAocmVzLCBlbmNvZGluZywgY2IpIHsKICAgIC8vIGNvbnNvbGUubG9nKHJlcywgZW5jb2RpbmcsIGNiKQogICAgY29uc3QgY29udGV4dCA9IGlkTWFwW3Jlcy5pZF0KICAgIGlmICghY29udGV4dCkgY2IobmV3IEVycm9yKGBTdHJlYW1NaWRkbGV3YXJlIC0gVW5rbm93biByZXNwb25zZSBpZCAke3Jlcy5pZH1gKSkKICAgIGRlbGV0ZSBpZE1hcFtyZXMuaWRdCiAgICAvLyBjb3B5IHdob2xlIHJlcyBvbnRvIG9yaWdpbmFsIHJlcwogICAgT2JqZWN0LmFzc2lnbihjb250ZXh0LnJlcywgcmVzKQogICAgLy8gcnVuIGNhbGxiYWNrIG9uIGVtcHR5IHN0YWNrLAogICAgLy8gcHJldmVudCBpbnRlcm5hbCBzdHJlYW0taGFuZGxlciBmcm9tIGNhdGNoaW5nIGVycm9ycwogICAgc2V0VGltZW91dChjb250ZXh0LmVuZCkKICAgIC8vIGNvbnRpbnVlIHByb2Nlc3Npbmcgc3RyZWFtCiAgICBjYigpCiAgfQoKfQp9LHsicmVhZGFibGUtc3RyZWFtIjoxMzJ9XSwxMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovKgoqIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsCioKKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5CiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLgoqLwooZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHsKICAgICJ1c2Ugc3RyaWN0IjsKICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHsKICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7CiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7CiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7CiAgICB9IGVsc2UgewogICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpOwogICAgfQp9KHRoaXMsIGZ1bmN0aW9uICgpIHsKICAgICJ1c2Ugc3RyaWN0IjsKCiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplCiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307CiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9ICJ1bmRlZmluZWQiOwoKICAgIHZhciBsb2dNZXRob2RzID0gWwogICAgICAgICJ0cmFjZSIsCiAgICAgICAgImRlYnVnIiwKICAgICAgICAiaW5mbyIsCiAgICAgICAgIndhcm4iLAogICAgICAgICJlcnJvciIKICAgIF07CgogICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNgogICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHsKICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdOwogICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZwogICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTsKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICB9CgogICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52CiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXMKICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgewogICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7CiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJzsKICAgICAgICB9CgogICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMKICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTsKICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHJldHVybiBub29wOwogICAgICAgIH0KICAgIH0KCiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5CgogICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7CiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi8KICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldOwogICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgPwogICAgICAgICAgICAgICAgbm9vcCA6CiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpOwogICAgICAgIH0KCiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1ZwogICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZzsKICAgIH0KCiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuCiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kcwogICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkgewogICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkgewogICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpOwogICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgfTsKICAgIH0KCiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZAogICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi4KICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7CiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi8KICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fAogICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICB9CgogICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkgewogICAgICB2YXIgc2VsZiA9IHRoaXM7CiAgICAgIHZhciBjdXJyZW50TGV2ZWw7CiAgICAgIHZhciBzdG9yYWdlS2V5ID0gImxvZ2xldmVsIjsKICAgICAgaWYgKG5hbWUpIHsKICAgICAgICBzdG9yYWdlS2V5ICs9ICI6IiArIG5hbWU7CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHsKICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7CgogICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjsKCiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZQogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lOwogICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge30KCiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2sKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9CiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyAiPSIgKyBsZXZlbE5hbWUgKyAiOyI7CiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9CiAgICAgIH0KCiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkgewogICAgICAgICAgdmFyIHN0b3JlZExldmVsOwoKICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47CgogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07CiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9CgogICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmcKICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHsKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTsKICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoCiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyAiPSIpOwogICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7CiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge30KICAgICAgICAgIH0KCiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLgogICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7CiAgICAgICAgICB9CgogICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsOwogICAgICB9CgogICAgICAvKgogICAgICAgKgogICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHMKICAgICAgICoKICAgICAgICovCgogICAgICBzZWxmLm5hbWUgPSBuYW1lOwoKICAgICAgc2VsZi5sZXZlbHMgPSB7ICJUUkFDRSI6IDAsICJERUJVRyI6IDEsICJJTkZPIjogMiwgIldBUk4iOiAzLAogICAgICAgICAgIkVSUk9SIjogNCwgIlNJTEVOVCI6IDV9OwoKICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTsKCiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsOwogICAgICB9OwoKICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkgewogICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gInN0cmluZyIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSAibnVtYmVyIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkgewogICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsOwogICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZQogICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpOwogICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nIjsKICAgICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHRocm93ICJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiAiICsgbGV2ZWw7CiAgICAgICAgICB9CiAgICAgIH07CgogICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkgewogICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7CiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpOwogICAgICAgICAgfQogICAgICB9OwoKICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7CiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTsKICAgICAgfTsKCiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHsKICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTsKICAgICAgfTsKCiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWwKICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7CiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkgewogICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyAiV0FSTiIgOiBkZWZhdWx0TGV2ZWw7CiAgICAgIH0KICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTsKICAgIH0KCiAgICAvKgogICAgICoKICAgICAqIFRvcC1sZXZlbCBBUEkKICAgICAqCiAgICAgKi8KCiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTsKCiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTsKICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHsKICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICJzdHJpbmciIHx8IG5hbWUgPT09ICIiKSB7CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuIik7CiAgICAgICAgfQoKICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07CiAgICAgICAgaWYgKCFsb2dnZXIpIHsKICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcigKICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbG9nZ2VyOwogICAgfTsKCiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGUKICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDsKICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkgewogICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmCiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHsKICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjsKICAgIH07CgogICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHsKICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7CiAgICB9OwoKICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyOwp9KSk7Cgp9LHt9XSwxMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpjb25zdCB7IER1cGxleCB9ID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtJykKY29uc3QgZW5kT2ZTdHJlYW0gPSBfZGVyZXFfKCdlbmQtb2Ytc3RyZWFtJykKY29uc3Qgb25jZSA9IF9kZXJlcV8oJ29uY2UnKQpjb25zdCBub29wID0gKCkgPT4ge30KCmNvbnN0IElHTk9SRV9TVUJTVFJFQU0gPSB7fQoKCmNsYXNzIE9iamVjdE11bHRpcGxleCBleHRlbmRzIER1cGxleCB7CgogIGNvbnN0cnVjdG9yKF9vcHRzID0ge30pIHsKICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBfb3B0cywgewogICAgICBvYmplY3RNb2RlOiB0cnVlLAogICAgfSkKICAgIHN1cGVyKG9wdHMpCgogICAgdGhpcy5fc3Vic3RyZWFtcyA9IHt9CiAgfQoKICBjcmVhdGVTdHJlYW0gKG5hbWUpIHsKICAgIC8vIHZhbGlkYXRlIG5hbWUKICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKCdPYmplY3RNdWx0aXBsZXggLSBuYW1lIG11c3Qgbm90IGJlIGVtcHR5JykKICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdE11bHRpcGxleCAtIFN1YnN0cmVhbSBmb3IgbmFtZSAiJHtuYW1lfSIgYWxyZWFkeSBleGlzdHMnKQoKICAgIC8vIGNyZWF0ZSBzdWJzdHJlYW0KICAgIGNvbnN0IHN1YnN0cmVhbSA9IG5ldyBTdWJzdHJlYW0oeyBwYXJlbnQ6IHRoaXMsIG5hbWU6IG5hbWUgfSkKICAgIHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0gPSBzdWJzdHJlYW0KCiAgICAvLyBsaXN0ZW4gZm9yIHBhcmVudCBzdHJlYW0gdG8gZW5kCiAgICBhbnlTdHJlYW1FbmQodGhpcywgKGVycikgPT4gewogICAgICBzdWJzdHJlYW0uZGVzdHJveShlcnIpCiAgICB9KQoKICAgIHJldHVybiBzdWJzdHJlYW0KICB9CgogIC8vIGlnbm9yZSBzdHJlYW1zIChkb250IGRpc3BsYXkgb3JwaGFuZWQgZGF0YSB3YXJuaW5nKQogIGlnbm9yZVN0cmVhbSAobmFtZSkgewogICAgLy8gdmFsaWRhdGUgbmFtZQogICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdE11bHRpcGxleCAtIG5hbWUgbXVzdCBub3QgYmUgZW1wdHknKQogICAgaWYgKHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0pIHRocm93IG5ldyBFcnJvcignT2JqZWN0TXVsdGlwbGV4IC0gU3Vic3RyZWFtIGZvciBuYW1lICIke25hbWV9IiBhbHJlYWR5IGV4aXN0cycpCiAgICAvLyBzZXQKICAgIHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0gPSBJR05PUkVfU1VCU1RSRUFNCiAgfQoKICAvLyBzdHJlYW0gcGx1bWJpbmcKCiAgX3JlYWQgKCkge30KCiAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHsKICAgIC8vIHBhcnNlIG1lc3NhZ2UKICAgIGNvbnN0IG5hbWUgPSBjaHVuay5uYW1lCiAgICBjb25zdCBkYXRhID0gY2h1bmsuZGF0YQogICAgaWYgKCFuYW1lKSB7CiAgICAgIGNvbnNvbGUud2FybihgT2JqZWN0TXVsdGlwbGV4IC0gbWFsZm9ybWVkIGNodW5rIHdpdGhvdXQgbmFtZSAiJHtjaHVua30iYCkKICAgICAgcmV0dXJuIGNhbGxiYWNrKCkKICAgIH0KCiAgICAvLyBnZXQgY29ycmVzcG9uZGluZyBzdWJzdHJlYW0KICAgIGNvbnN0IHN1YnN0cmVhbSA9IHRoaXMuX3N1YnN0cmVhbXNbbmFtZV0KICAgIGlmICghc3Vic3RyZWFtKSB7CiAgICAgIGNvbnNvbGUud2FybihgT2JqZWN0TXVsdGlwbGV4IC0gb3JwaGFuZWQgZGF0YSBmb3Igc3RyZWFtICIke25hbWV9ImApCiAgICAgIHJldHVybiBjYWxsYmFjaygpCiAgICB9CgogICAgLy8gcHVzaCBkYXRhIGludG8gc3Vic3RyZWFtCiAgICBpZiAoc3Vic3RyZWFtICE9PSBJR05PUkVfU1VCU1RSRUFNKSB7CiAgICAgIHN1YnN0cmVhbS5wdXNoKGRhdGEpCiAgICB9CgogICAgY2FsbGJhY2soKQogIH0KCn0KCgpjbGFzcyBTdWJzdHJlYW0gZXh0ZW5kcyBEdXBsZXggewoKICBjb25zdHJ1Y3RvciAoeyBwYXJlbnQsIG5hbWUgfSkgewogICAgc3VwZXIoewogICAgICBvYmplY3RNb2RlOiB0cnVlLAogICAgfSkKCiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQKICAgIHRoaXMuX25hbWUgPSBuYW1lCiAgfQoKICBfcmVhZCAoKSB7fQoKICBfd3JpdGUgKGNodW5rLCBlbmMsIGNhbGxiYWNrKSB7CiAgICB0aGlzLl9wYXJlbnQucHVzaCh7CiAgICAgIG5hbWU6IHRoaXMuX25hbWUsCiAgICAgIGRhdGE6IGNodW5rLAogICAgfSkKICAgIGNhbGxiYWNrKCkKICB9Cgp9Cgptb2R1bGUuZXhwb3J0cyA9IE9iamVjdE11bHRpcGxleAoKLy8gdXRpbAoKZnVuY3Rpb24gYW55U3RyZWFtRW5kKHN0cmVhbSwgX2NiKSB7CiAgY29uc3QgY2IgPSBvbmNlKF9jYikKICBlbmRPZlN0cmVhbShzdHJlYW0sIHsgcmVhZGFibGU6IGZhbHNlIH0sIGNiKQogIGVuZE9mU3RyZWFtKHN0cmVhbSwgeyB3cml0YWJsZTogZmFsc2UgfSwgY2IpCn0KfSx7ImVuZC1vZi1zdHJlYW0iOjEwMSwib25jZSI6MTE2LCJyZWFkYWJsZS1zdHJlYW0iOjEzMn1dLDExMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCnZhciBfYXNzaWduID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24nKTsKCnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7Cgp2YXIgX3R5cGVvZjIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mJyk7Cgp2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTsKCnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTsKCnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpOwoKdmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTsKCnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTsKCnZhciBfY3JlYXRlQ2xhc3MyID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7Cgp2YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7Cgp2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTsKCnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7Cgp2YXIgX2luaGVyaXRzMiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpOwoKdmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpOwoKZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0KCnZhciBleHRlbmQgPSBfZGVyZXFfKCd4dGVuZCcpOwp2YXIgRXZlbnRFbWl0dGVyID0gX2RlcmVxXygnZXZlbnRzJyk7Cgp2YXIgT2JzZXJ2YWJsZVN0b3JlID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHsKICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShPYnNlcnZhYmxlU3RvcmUsIF9FdmVudEVtaXR0ZXIpOwoKICBmdW5jdGlvbiBPYnNlcnZhYmxlU3RvcmUoKSB7CiAgICB2YXIgaW5pdFN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTsKICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIE9ic2VydmFibGVTdG9yZSk7CgogICAgLy8gc2V0IGluaXQgc3RhdGUKICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKE9ic2VydmFibGVTdG9yZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoT2JzZXJ2YWJsZVN0b3JlKSkuY2FsbCh0aGlzKSk7CgogICAgX3RoaXMuX3N0YXRlID0gaW5pdFN0YXRlOwogICAgcmV0dXJuIF90aGlzOwogIH0KCiAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgZ2V0U3RhdGUKCgogICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKE9ic2VydmFibGVTdG9yZSwgW3sKICAgIGtleTogJ2dldFN0YXRlJywKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZSgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2dldFN0YXRlKCk7CiAgICB9CgogICAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgcHV0U3RhdGUKCiAgfSwgewogICAga2V5OiAncHV0U3RhdGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIHB1dFN0YXRlKG5ld1N0YXRlKSB7CiAgICAgIHRoaXMuX3B1dFN0YXRlKG5ld1N0YXRlKTsKICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBuZXdTdGF0ZSk7CiAgICB9CiAgfSwgewogICAga2V5OiAndXBkYXRlU3RhdGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHBhcnRpYWxTdGF0ZSkgewogICAgICAvLyBpZiBub24tbnVsbCBvYmplY3QsIG1lcmdlCiAgICAgIGlmIChwYXJ0aWFsU3RhdGUgJiYgKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkocGFydGlhbFN0YXRlKSkgPT09ICdvYmplY3QnKSB7CiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpOwogICAgICAgIHZhciBuZXdTdGF0ZSA9ICgwLCBfYXNzaWduMi5kZWZhdWx0KSh7fSwgc3RhdGUsIHBhcnRpYWxTdGF0ZSk7CiAgICAgICAgdGhpcy5wdXRTdGF0ZShuZXdTdGF0ZSk7CiAgICAgICAgLy8gaWYgbm90IG9iamVjdCwgdXNlIG5ldyB2YWx1ZQogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMucHV0U3RhdGUocGFydGlhbFN0YXRlKTsKICAgICAgfQogICAgfQoKICAgIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzCgogIH0sIHsKICAgIGtleTogJ3N1YnNjcmliZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlKGhhbmRsZXIpIHsKICAgICAgdGhpcy5vbigndXBkYXRlJywgaGFuZGxlcik7CiAgICB9CgogICAgLy8gdW5zdWJzY3JpYmUgdG8gY2hhbmdlcwoKICB9LCB7CiAgICBrZXk6ICd1bnN1YnNjcmliZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoaGFuZGxlcikgewogICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnLCBoYW5kbGVyKTsKICAgIH0KCiAgICAvLwogICAgLy8gcHJpdmF0ZQogICAgLy8KCiAgICAvLyByZWFkIGZyb20gcGVyc2lzdGVuY2UKCiAgfSwgewogICAga2V5OiAnX2dldFN0YXRlJywKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RhdGUoKSB7CiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTsKICAgIH0KCiAgICAvLyB3cml0ZSB0byBwZXJzaXN0ZW5jZQoKICB9LCB7CiAgICBrZXk6ICdfcHV0U3RhdGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9wdXRTdGF0ZShuZXdTdGF0ZSkgewogICAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlOwogICAgfQogIH1dKTsKICByZXR1cm4gT2JzZXJ2YWJsZVN0b3JlOwp9KEV2ZW50RW1pdHRlcik7Cgptb2R1bGUuZXhwb3J0cyA9IE9ic2VydmFibGVTdG9yZTsKCn0seyJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbiI6NiwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mIjo5LCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2siOjEzLCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MiOjE0LCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMiOjE1LCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiI6MTYsImJhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YiOjE3LCJldmVudHMiOjEwMiwieHRlbmQiOjE0MX1dLDExNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTsKCnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpOwoKdmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTsKCnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTsKCnZhciBfY3JlYXRlQ2xhc3MyID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7Cgp2YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7Cgp2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTsKCnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7Cgp2YXIgX2luaGVyaXRzMiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpOwoKdmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpOwoKZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0KCnZhciBEdXBsZXhTdHJlYW0gPSBfZGVyZXFfKCdzdHJlYW0nKS5EdXBsZXg7Cgptb2R1bGUuZXhwb3J0cyA9IGFzU3RyZWFtOwoKZnVuY3Rpb24gYXNTdHJlYW0ob2JzU3RvcmUpIHsKICByZXR1cm4gbmV3IE9ic1N0b3JlU3RyZWFtKG9ic1N0b3JlKTsKfQoKLy8KLy8KLy8KLy8KCnZhciBPYnNTdG9yZVN0cmVhbSA9IGZ1bmN0aW9uIChfRHVwbGV4U3RyZWFtKSB7CiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoT2JzU3RvcmVTdHJlYW0sIF9EdXBsZXhTdHJlYW0pOwoKICBmdW5jdGlvbiBPYnNTdG9yZVN0cmVhbShvYnNTdG9yZSkgewogICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgT2JzU3RvcmVTdHJlYW0pOwoKICAgIC8vIGRvbnQgYnVmZmVyIG91dGdvaW5nIHVwZGF0ZXMKICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKE9ic1N0b3JlU3RyZWFtLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShPYnNTdG9yZVN0cmVhbSkpLmNhbGwodGhpcywgewogICAgICAvLyBwYXNzIHZhbHVlcywgbm90IHNlcmlhbGl6YXRpb25zCiAgICAgIG9iamVjdE1vZGU6IHRydWUKICAgIH0pKTsKCiAgICBfdGhpcy5yZXN1bWUoKTsKICAgIC8vIHN1YnNjcmliZSB0byBvYnNTdG9yZSBjaGFuZ2VzCiAgICBfdGhpcy5vYnNTdG9yZSA9IG9ic1N0b3JlOwogICAgX3RoaXMub2JzU3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdGF0ZSkgewogICAgICByZXR1cm4gX3RoaXMucHVzaChzdGF0ZSk7CiAgICB9KTsKICAgIHJldHVybiBfdGhpczsKICB9CgogIC8vIGVtaXQgY3VycmVudCBzdGF0ZSBvbiBuZXcgZGVzdGluYXRpb24KCgogICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKE9ic1N0b3JlU3RyZWFtLCBbewogICAga2V5OiAncGlwZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gcGlwZShkZXN0LCBvcHRpb25zKSB7CiAgICAgIHZhciByZXN1bHQgPSBEdXBsZXhTdHJlYW0ucHJvdG90eXBlLnBpcGUuY2FsbCh0aGlzLCBkZXN0LCBvcHRpb25zKTsKICAgICAgZGVzdC53cml0ZSh0aGlzLm9ic1N0b3JlLmdldFN0YXRlKCkpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQoKICAgIC8vIHdyaXRlIGZyb20gaW5jb21taW5nIHN0cmVhbSB0byBzdGF0ZQoKICB9LCB7CiAgICBrZXk6ICdfd3JpdGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7CiAgICAgIHRoaXMub2JzU3RvcmUucHV0U3RhdGUoY2h1bmspOwogICAgICBjYWxsYmFjaygpOwogICAgfQoKICAgIC8vIG5vb3AgLSBvdXRnb2luZyBzdHJlYW0gaXMgYXNraW5nIHVzIGlmIHdlIGhhdmUgZGF0YSB3ZSBhcmVudCBnaXZpbmcgaXQKCiAgfSwgewogICAga2V5OiAnX3JlYWQnLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFkKHNpemUpIHt9CiAgfV0pOwogIHJldHVybiBPYnNTdG9yZVN0cmVhbTsKfShEdXBsZXhTdHJlYW0pOwoKfSx7ImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZiI6OSwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrIjoxMywiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzIjoxNCwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzIjoxNSwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iOjE2LCJzdHJlYW0iOjEzNX1dLDExNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2sKLy8gVGhlIHdyYXBwZXIgZnVuY3Rpb24gc2hvdWxkIGRvIHNvbWUgc3R1ZmYsIGFuZCByZXR1cm4gYQovLyBwcmVzdW1hYmx5IGRpZmZlcmVudCBjYWxsYmFjayBmdW5jdGlvbi4KLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0Ci8vIGRlY29yYXRpb25zIGFuZCBzdWNoIGFyZSBub3QgbG9zdCBhbG9uZyB0aGUgd2F5Lgptb2R1bGUuZXhwb3J0cyA9IHdyYXBweQpmdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikgewogIGlmIChmbiAmJiBjYikgcmV0dXJuIHdyYXBweShmbikoY2IpCgogIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpCiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduZWVkIHdyYXBwZXIgZnVuY3Rpb24nKQoKICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykgewogICAgd3JhcHBlcltrXSA9IGZuW2tdCiAgfSkKCiAgcmV0dXJuIHdyYXBwZXIKCiAgZnVuY3Rpb24gd3JhcHBlcigpIHsKICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHsKICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXQogICAgfQogICAgdmFyIHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpCiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdCiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ2Z1bmN0aW9uJyAmJiByZXQgIT09IGNiKSB7CiAgICAgIE9iamVjdC5rZXlzKGNiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7CiAgICAgICAgcmV0W2tdID0gY2Jba10KICAgICAgfSkKICAgIH0KICAgIHJldHVybiByZXQKICB9Cn0KCn0se31dLDExNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciB3cmFwcHkgPSBfZGVyZXFfKCd3cmFwcHknKQptb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKQptb2R1bGUuZXhwb3J0cy5zdHJpY3QgPSB3cmFwcHkob25jZVN0cmljdCkKCm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHsKICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBvbmNlKHRoaXMpCiAgICB9LAogICAgY29uZmlndXJhYmxlOiB0cnVlCiAgfSkKCiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2VTdHJpY3QnLCB7CiAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gb25jZVN0cmljdCh0aGlzKQogICAgfSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogIH0pCn0pCgpmdW5jdGlvbiBvbmNlIChmbikgewogIHZhciBmID0gZnVuY3Rpb24gKCkgewogICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZQogICAgZi5jYWxsZWQgPSB0cnVlCiAgICByZXR1cm4gZi52YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykKICB9CiAgZi5jYWxsZWQgPSBmYWxzZQogIHJldHVybiBmCn0KCmZ1bmN0aW9uIG9uY2VTdHJpY3QgKGZuKSB7CiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7CiAgICBpZiAoZi5jYWxsZWQpCiAgICAgIHRocm93IG5ldyBFcnJvcihmLm9uY2VFcnJvcikKICAgIGYuY2FsbGVkID0gdHJ1ZQogICAgcmV0dXJuIGYudmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpCiAgfQogIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCcKICBmLm9uY2VFcnJvciA9IG5hbWUgKyAiIHNob3VsZG4ndCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UiCiAgZi5jYWxsZWQgPSBmYWxzZQogIHJldHVybiBmCn0KCn0seyJ3cmFwcHkiOjExNX1dLDExNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmNvbnN0IER1cGxleFN0cmVhbSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbScpLkR1cGxleApjb25zdCBpbmhlcml0cyA9IF9kZXJlcV8oJ3V0aWwnKS5pbmhlcml0cwoKbW9kdWxlLmV4cG9ydHMgPSBQb3N0TWVzc2FnZVN0cmVhbQoKaW5oZXJpdHMoUG9zdE1lc3NhZ2VTdHJlYW0sIER1cGxleFN0cmVhbSkKCmZ1bmN0aW9uIFBvc3RNZXNzYWdlU3RyZWFtIChvcHRzKSB7CiAgRHVwbGV4U3RyZWFtLmNhbGwodGhpcywgewogICAgb2JqZWN0TW9kZTogdHJ1ZSwKICB9KQoKICB0aGlzLl9uYW1lID0gb3B0cy5uYW1lCiAgdGhpcy5fdGFyZ2V0ID0gb3B0cy50YXJnZXQKICB0aGlzLl90YXJnZXRXaW5kb3cgPSBvcHRzLnRhcmdldFdpbmRvdyB8fCB3aW5kb3cKICB0aGlzLl9vcmlnaW4gPSAob3B0cy50YXJnZXRXaW5kb3cgPyAnKicgOiBsb2NhdGlvbi5vcmlnaW4pCgogIC8vIGluaXRpYWxpemF0aW9uIGZsYWdzCiAgdGhpcy5faW5pdCA9IGZhbHNlCiAgdGhpcy5faGF2ZVN5biA9IGZhbHNlCgogIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fb25NZXNzYWdlLmJpbmQodGhpcyksIGZhbHNlKQogIC8vIHNlbmQgc3luY29yaXphdGlvbiBtZXNzYWdlCiAgdGhpcy5fd3JpdGUoJ1NZTicsIG51bGwsIG5vb3ApCiAgdGhpcy5jb3JrKCkKfQoKLy8gcHJpdmF0ZQpQb3N0TWVzc2FnZVN0cmVhbS5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkgewogIHZhciBtc2cgPSBldmVudC5kYXRhCgogIC8vIHZhbGlkYXRlIG1lc3NhZ2UKICBpZiAodGhpcy5fb3JpZ2luICE9PSAnKicgJiYgZXZlbnQub3JpZ2luICE9PSB0aGlzLl9vcmlnaW4pIHJldHVybgogIGlmIChldmVudC5zb3VyY2UgIT09IHRoaXMuX3RhcmdldFdpbmRvdykgcmV0dXJuCiAgaWYgKHR5cGVvZiBtc2cgIT09ICdvYmplY3QnKSByZXR1cm4KICBpZiAobXNnLnRhcmdldCAhPT0gdGhpcy5fbmFtZSkgcmV0dXJuCiAgaWYgKCFtc2cuZGF0YSkgcmV0dXJuCgogIGlmICghdGhpcy5faW5pdCkgewogICAgaWYgKG1zZy5kYXRhID09PSAnU1lOJykgewogICAgICB0aGlzLl9oYXZlU3luID0gdHJ1ZQogICAgICB0aGlzLl93cml0ZSgnQUNLJywgbnVsbCwgbm9vcCkKICAgIH0gZWxzZSBpZiAobXNnLmRhdGEgPT09ICdBQ0snKSB7CiAgICAgIHRoaXMuX2luaXQgPSB0cnVlCiAgICAgIGlmICghdGhpcy5faGF2ZVN5bikgewogICAgICAgIHRoaXMuX3dyaXRlKCdBQ0snLCBudWxsLCBub29wKQogICAgICB9CiAgICAgIHRoaXMudW5jb3JrKCkKICAgIH0KICB9IGVsc2UgewogICAgLy8gZm9yd2FyZCBtZXNzYWdlCiAgICB0cnkgewogICAgICB0aGlzLnB1c2gobXNnLmRhdGEpCiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycikKICAgIH0KICB9Cn0KCi8vIHN0cmVhbSBwbHVtYmluZwpQb3N0TWVzc2FnZVN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBub29wCgpQb3N0TWVzc2FnZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYikgewogIHZhciBtZXNzYWdlID0gewogICAgdGFyZ2V0OiB0aGlzLl90YXJnZXQsCiAgICBkYXRhOiBkYXRhLAogIH0KICB0aGlzLl90YXJnZXRXaW5kb3cucG9zdE1lc3NhZ2UobWVzc2FnZSwgdGhpcy5fb3JpZ2luKQogIGNiKCkKfQoKLy8gdXRpbAoKZnVuY3Rpb24gbm9vcCAoKSB7fQoKfSx7InJlYWRhYmxlLXN0cmVhbSI6MTMyLCJ1dGlsIjoxMzl9XSwxMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKHByb2Nlc3MpewondXNlIHN0cmljdCc7CgppZiAoIXByb2Nlc3MudmVyc2lvbiB8fAogICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8CiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHsKICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrOwp9IGVsc2UgewogIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5uZXh0VGljazsKfQoKZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHsKICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCciY2FsbGJhY2siIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpOwogIH0KICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsKICB2YXIgYXJncywgaTsKICBzd2l0Y2ggKGxlbikgewogIGNhc2UgMDoKICBjYXNlIDE6CiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7CiAgY2FzZSAyOgogICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkgewogICAgICBmbi5jYWxsKG51bGwsIGFyZzEpOwogICAgfSk7CiAgY2FzZSAzOgogICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkgewogICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpOwogICAgfSk7CiAgY2FzZSA0OgogICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7CiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7CiAgICB9KTsKICBkZWZhdWx0OgogICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTsKICAgIGkgPSAwOwogICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkgewogICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07CiAgICB9CiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7CiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpOwogICAgfSk7CiAgfQp9Cgp9KS5jYWxsKHRoaXMsX2RlcmVxXygnX3Byb2Nlc3MnKSkKfSx7Il9wcm9jZXNzIjo5OX1dLDExOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBvbmNlID0gX2RlcmVxXygnb25jZScpCnZhciBlb3MgPSBfZGVyZXFfKCdlbmQtb2Ytc3RyZWFtJykKdmFyIGZzID0gX2RlcmVxXygnZnMnKSAvLyB3ZSBvbmx5IG5lZWQgZnMgdG8gZ2V0IHRoZSBSZWFkU3RyZWFtIGFuZCBXcml0ZVN0cmVhbSBwcm90b3R5cGVzCgp2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9Cgp2YXIgaXNGbiA9IGZ1bmN0aW9uIChmbikgewogIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicKfQoKdmFyIGlzRlMgPSBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgaWYgKCFmcykgcmV0dXJuIGZhbHNlIC8vIGJyb3dzZXIKICByZXR1cm4gKHN0cmVhbSBpbnN0YW5jZW9mIChmcy5SZWFkU3RyZWFtIHx8IG5vb3ApIHx8IHN0cmVhbSBpbnN0YW5jZW9mIChmcy5Xcml0ZVN0cmVhbSB8fCBub29wKSkgJiYgaXNGbihzdHJlYW0uY2xvc2UpCn0KCnZhciBpc1JlcXVlc3QgPSBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgaXNGbihzdHJlYW0uYWJvcnQpCn0KCnZhciBkZXN0cm95ZXIgPSBmdW5jdGlvbiAoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBjYWxsYmFjaykgewogIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaykKCiAgdmFyIGNsb3NlZCA9IGZhbHNlCiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHsKICAgIGNsb3NlZCA9IHRydWUKICB9KQoKICBlb3Moc3RyZWFtLCB7cmVhZGFibGU6IHJlYWRpbmcsIHdyaXRhYmxlOiB3cml0aW5nfSwgZnVuY3Rpb24gKGVycikgewogICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycikKICAgIGNsb3NlZCA9IHRydWUKICAgIGNhbGxiYWNrKCkKICB9KQoKICB2YXIgZGVzdHJveWVkID0gZmFsc2UKICByZXR1cm4gZnVuY3Rpb24gKGVycikgewogICAgaWYgKGNsb3NlZCkgcmV0dXJuCiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm4KICAgIGRlc3Ryb3llZCA9IHRydWUKCiAgICBpZiAoaXNGUyhzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmNsb3NlKG5vb3ApIC8vIHVzZSBjbG9zZSBmb3IgZnMgc3RyZWFtcyB0byBhdm9pZCBmZCBsZWFrcwogICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCkgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnQKCiAgICBpZiAoaXNGbihzdHJlYW0uZGVzdHJveSkpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpCgogICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFcnJvcignc3RyZWFtIHdhcyBkZXN0cm95ZWQnKSkKICB9Cn0KCnZhciBjYWxsID0gZnVuY3Rpb24gKGZuKSB7CiAgZm4oKQp9Cgp2YXIgcGlwZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykgewogIHJldHVybiBmcm9tLnBpcGUodG8pCn0KCnZhciBwdW1wID0gZnVuY3Rpb24gKCkgewogIHZhciBzdHJlYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKQogIHZhciBjYWxsYmFjayA9IGlzRm4oc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdIHx8IG5vb3ApICYmIHN0cmVhbXMucG9wKCkgfHwgbm9vcAoKICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF0KICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB0aHJvdyBuZXcgRXJyb3IoJ3B1bXAgcmVxdWlyZXMgdHdvIHN0cmVhbXMgcGVyIG1pbmltdW0nKQoKICB2YXIgZXJyb3IKICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7CiAgICB2YXIgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDEKICAgIHZhciB3cml0aW5nID0gaSA+IDAKICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbiAoZXJyKSB7CiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyCiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbCkKICAgICAgaWYgKHJlYWRpbmcpIHJldHVybgogICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpCiAgICAgIGNhbGxiYWNrKGVycm9yKQogICAgfSkKICB9KQoKICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSkKfQoKbW9kdWxlLmV4cG9ydHMgPSBwdW1wCgp9LHsiZW5kLW9mLXN0cmVhbSI6MTAxLCJmcyI6OTYsIm9uY2UiOjExNn1dLDEyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTsKCn0seyIuL2xpYi9fc3RyZWFtX2R1cGxleC5qcyI6MTIxfV0sMTIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS4KLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3MKLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbQovLyBXcml0YWJsZS4KCid1c2Ugc3RyaWN0JzsKCi8qPHJlcGxhY2VtZW50PiovCgp2YXIgcHJvY2Vzc05leHRUaWNrID0gX2RlcmVxXygncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHsKICB2YXIga2V5cyA9IFtdOwogIGZvciAodmFyIGtleSBpbiBvYmopIHsKICAgIGtleXMucHVzaChrZXkpOwogIH1yZXR1cm4ga2V5czsKfTsKLyo8L3JlcGxhY2VtZW50PiovCgptb2R1bGUuZXhwb3J0cyA9IER1cGxleDsKCi8qPHJlcGxhY2VtZW50PiovCnZhciB1dGlsID0gX2RlcmVxXygnY29yZS11dGlsLWlzJyk7CnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCnZhciBSZWFkYWJsZSA9IF9kZXJlcV8oJy4vX3N0cmVhbV9yZWFkYWJsZScpOwp2YXIgV3JpdGFibGUgPSBfZGVyZXFfKCcuL19zdHJlYW1fd3JpdGFibGUnKTsKCnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7Cgp2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTsKZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7CiAgdmFyIG1ldGhvZCA9IGtleXNbdl07CiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdOwp9CgpmdW5jdGlvbiBEdXBsZXgob3B0aW9ucykgewogIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTsKCiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTsKICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpOwoKICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlOwoKICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlOwoKICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlOwogIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlOwoKICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTsKfQoKLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlcgpmdW5jdGlvbiBvbmVuZCgpIHsKICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLAogIC8vIHRoZW4gd2UncmUgb2suCiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47CgogIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi4KICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay4KICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7Cn0KCmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikgewogIHNlbGYuZW5kKCk7Cn0KCk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywgewogIGdldDogZnVuY3Rpb24gKCkgewogICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkOwogIH0sCiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsKICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbQogICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldAogICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHkKICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZAogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7CiAgfQp9KTsKCkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikgewogIHRoaXMucHVzaChudWxsKTsKICB0aGlzLmVuZCgpOwoKICBwcm9jZXNzTmV4dFRpY2soY2IsIGVycik7Cn07CgpmdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7CiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgIGYoeHNbaV0sIGkpOwogIH0KfQp9LHsiLi9fc3RyZWFtX3JlYWRhYmxlIjoxMjMsIi4vX3N0cmVhbV93cml0YWJsZSI6MTI1LCJjb3JlLXV0aWwtaXMiOjEwMCwiaW5oZXJpdHMiOjEwNCwicHJvY2Vzcy1uZXh0aWNrLWFyZ3MiOjExOH1dLDEyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLgovLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS4KLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy4KCid1c2Ugc3RyaWN0JzsKCm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7Cgp2YXIgVHJhbnNmb3JtID0gX2RlcmVxXygnLi9fc3RyZWFtX3RyYW5zZm9ybScpOwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIHV0aWwgPSBfZGVyZXFfKCdjb3JlLXV0aWwtaXMnKTsKdXRpbC5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKdXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTsKCmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHsKICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpOwoKICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTsKfQoKUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewogIGNiKG51bGwsIGNodW5rKTsKfTsKfSx7Ii4vX3N0cmVhbV90cmFuc2Zvcm0iOjEyNCwiY29yZS11dGlsLWlzIjoxMDAsImluaGVyaXRzIjoxMDR9XSwxMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKJ3VzZSBzdHJpY3QnOwoKLyo8cmVwbGFjZW1lbnQ+Ki8KCnZhciBwcm9jZXNzTmV4dFRpY2sgPSBfZGVyZXFfKCdwcm9jZXNzLW5leHRpY2stYXJncycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7CgovKjxyZXBsYWNlbWVudD4qLwp2YXIgaXNBcnJheSA9IF9kZXJlcV8oJ2lzYXJyYXknKTsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgRHVwbGV4OwovKjwvcmVwbGFjZW1lbnQ+Ki8KClJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlOwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIEVFID0gX2RlcmVxXygnZXZlbnRzJykuRXZlbnRFbWl0dGVyOwoKdmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7CiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDsKfTsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgU3RyZWFtID0gX2RlcmVxXygnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8vIFRPRE8oYm1ldXJlcik6IENoYW5nZSB0aGlzIGJhY2sgdG8gY29uc3Qgb25jZSBob2xlIGNoZWNrcyBhcmUKLy8gcHJvcGVybHkgb3B0aW1pemVkIGF3YXkgZWFybHkgaW4gSWduaXRpb24rVHVyYm9GYW4uCi8qPHJlcGxhY2VtZW50PiovCnZhciBCdWZmZXIgPSBfZGVyZXFfKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjsKdmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTsKZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykgewogIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7Cn0KZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHsKICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTsKfQovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciB1dGlsID0gX2RlcmVxXygnY29yZS11dGlsLWlzJyk7CnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBkZWJ1Z1V0aWwgPSBfZGVyZXFfKCd1dGlsJyk7CnZhciBkZWJ1ZyA9IHZvaWQgMDsKaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHsKICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7Cn0gZWxzZSB7CiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTsKfQovKjwvcmVwbGFjZW1lbnQ+Ki8KCnZhciBCdWZmZXJMaXN0ID0gX2RlcmVxXygnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTsKdmFyIGRlc3Ryb3lJbXBsID0gX2RlcmVxXygnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTsKdmFyIFN0cmluZ0RlY29kZXI7Cgp1dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pOwoKdmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTsKCmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHsKICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93bgogIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLgogIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHsKICAgIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOwogIH0gZWxzZSB7CiAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55CiAgICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHMKICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGUKICAgIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay4KICAgIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dOwogIH0KfQoKZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHsKICBEdXBsZXggPSBEdXBsZXggfHwgX2RlcmVxXygnLi9fc3RyZWFtX2R1cGxleCcpOwoKICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKCiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG8KICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheQogIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlOwoKICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsKCiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXIKICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zICJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyIgogIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7CiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDsKICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTsKCiAgLy8gY2FzdCB0byBpbnRzLgogIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTsKCiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGUKICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhbgogIC8vIGFycmF5LnNoaWZ0KCkKICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7CiAgdGhpcy5sZW5ndGggPSAwOwogIHRoaXMucGlwZXMgPSBudWxsOwogIHRoaXMucGlwZXNDb3VudCA9IDA7CiAgdGhpcy5mbG93aW5nID0gbnVsbDsKICB0aGlzLmVuZGVkID0gZmFsc2U7CiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7CiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7CgogIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWQKICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZQogIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCAibGF0ZXIiIHNob3VsZCBnZW5lcmFsbHkgYWxzbwogIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuCiAgdGhpcy5zeW5jID0gdHJ1ZTsKCiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXkKICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi4KICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlOwogIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7CiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlOwogIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7CgogIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZAogIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7CgogIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmcKICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuCiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLgogIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOwoKICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpcwogIHRoaXMuYXdhaXREcmFpbiA9IDA7CgogIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWQKICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7CgogIHRoaXMuZGVjb2RlciA9IG51bGw7CiAgdGhpcy5lbmNvZGluZyA9IG51bGw7CiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHsKICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IF9kZXJlcV8oJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7CiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTsKICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nOwogIH0KfQoKZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykgewogIER1cGxleCA9IER1cGxleCB8fCBfZGVyZXFfKCcuL19zdHJlYW1fZHVwbGV4Jyk7CgogIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7CgogIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTsKCiAgLy8gbGVnYWN5CiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7CgogIGlmIChvcHRpb25zKSB7CiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDsKCiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTsKICB9CgogIFN0cmVhbS5jYWxsKHRoaXMpOwp9CgpPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywgewogIGdldDogZnVuY3Rpb24gKCkgewogICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7CiAgfSwKICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgewogICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtCiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0CiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHkKICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZAogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTsKICB9Cn0pOwoKUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95OwpSZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTsKUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHsKICB0aGlzLnB1c2gobnVsbCk7CiAgY2IoZXJyKTsKfTsKCi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLgovLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCwKLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZAovLyB3cml0ZSgpIHNvbWUgbW9yZS4KUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICB2YXIgc2tpcENodW5rQ2hlY2s7CgogIGlmICghc3RhdGUub2JqZWN0TW9kZSkgewogICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHsKICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7CiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHsKICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7CiAgICAgICAgZW5jb2RpbmcgPSAnJzsKICAgICAgfQogICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7CiAgICB9CiAgfSBlbHNlIHsKICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTsKICB9CgogIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTsKfTsKCi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpClJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7CiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTsKfTsKCmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7CiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwogIGlmIChjaHVuayA9PT0gbnVsbCkgewogICAgc3RhdGUucmVhZGluZyA9IGZhbHNlOwogICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTsKICB9IGVsc2UgewogICAgdmFyIGVyOwogICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTsKICAgIGlmIChlcikgewogICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7CiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkgewogICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7CiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTsKICAgICAgfQoKICAgICAgaWYgKGFkZFRvRnJvbnQpIHsKICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTsKICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkgewogICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlOwogICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykgewogICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsKICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7CiAgICAgICAgfQogICAgICB9CiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7CiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTsKICAgIH0KICB9CgogIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpOwp9CgpmdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkgewogIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykgewogICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7CiAgICBzdHJlYW0ucmVhZCgwKTsKICB9IGVsc2UgewogICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby4KICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDsKICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7CgogICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7CiAgfQogIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7Cn0KCmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHsKICB2YXIgZXI7CiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHsKICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpOwogIH0KICByZXR1cm4gZXI7Cn0KCi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuCi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lCi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLAovLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYQovLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXQKLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXIKLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC4KZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7CiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTsKfQoKUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkgewogIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlOwp9OwoKLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuClJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHsKICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSBfZGVyZXFfKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyOwogIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7CiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYzsKICByZXR1cm4gdGhpczsKfTsKCi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUIKdmFyIE1BWF9IV00gPSAweDgwMDAwMDsKZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikgewogIGlmIChuID49IE1BWF9IV00pIHsKICAgIG4gPSBNQVhfSFdNOwogIH0gZWxzZSB7CiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW4KICAgIC8vIHRpbnkgYW1vdW50cwogICAgbi0tOwogICAgbiB8PSBuID4+PiAxOwogICAgbiB8PSBuID4+PiAyOwogICAgbiB8PSBuID4+PiA0OwogICAgbiB8PSBuID4+PiA4OwogICAgbiB8PSBuID4+PiAxNjsKICAgIG4rKzsKICB9CiAgcmV0dXJuIG47Cn0KCi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nCi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuCmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHsKICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7CiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxOwogIGlmIChuICE9PSBuKSB7CiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWUKICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDsKICB9CiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uCiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7CiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjsKICAvLyBEb24ndCBoYXZlIGVub3VnaAogIGlmICghc3RhdGUuZW5kZWQpIHsKICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CiAgICByZXR1cm4gMDsKICB9CiAgcmV0dXJuIHN0YXRlLmxlbmd0aDsKfQoKLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy4KUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikgewogIGRlYnVnKCdyZWFkJywgbik7CiAgbiA9IHBhcnNlSW50KG4sIDEwKTsKICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogIHZhciBuT3JpZyA9IG47CgogIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsKCiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZQogIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXIKICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi4KICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkgewogICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpOwogICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7CiAgICByZXR1cm4gbnVsbDsKICB9CgogIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsKCiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLgogIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7CiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTsKICAgIHJldHVybiBudWxsOwogIH0KCiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZQogIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpbgogIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWQKICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlCiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW4KICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC4KICAvLwogIC8vIFNvLCB0aGUgc3RlcHMgYXJlOgogIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG8KICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLgogIC8vCiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC4KICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXMKICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW4KICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlCiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy4KICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGwKICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0CiAgLy8gJ3JlYWRhYmxlJyBldGMuCiAgLy8KICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uCgogIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy4KICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlOwogIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsKCiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lCiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykgewogICAgZG9SZWFkID0gdHJ1ZTsKICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7CiAgfQoKICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeQogIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS4KICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykgewogICAgZG9SZWFkID0gZmFsc2U7CiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7CiAgfSBlbHNlIGlmIChkb1JlYWQpIHsKICAgIGRlYnVnKCdkbyByZWFkJyk7CiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTsKICAgIHN0YXRlLnN5bmMgPSB0cnVlOwogICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC4KICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kCiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspOwogICAgc3RhdGUuc3luYyA9IGZhbHNlOwogICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSwKICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci4KICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTsKICB9CgogIHZhciByZXQ7CiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsOwoKICBpZiAocmV0ID09PSBudWxsKSB7CiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwogICAgbiA9IDA7CiAgfSBlbHNlIHsKICAgIHN0YXRlLmxlbmd0aCAtPSBuOwogIH0KCiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgewogICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93CiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuCiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwoKICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay4KICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7CiAgfQoKICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpOwoKICByZXR1cm4gcmV0Owp9OwoKZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47CiAgaWYgKHN0YXRlLmRlY29kZXIpIHsKICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7CiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7CiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTsKICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoOwogICAgfQogIH0KICBzdGF0ZS5lbmRlZCA9IHRydWU7CgogIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLgogIGVtaXRSZWFkYWJsZShzdHJlYW0pOwp9CgovLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXIKLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyCi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC4KZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkgewogIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTsKICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkgewogICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpOwogICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTsKICAgIGlmIChzdGF0ZS5zeW5jKSBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTsKICB9Cn0KCmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7CiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTsKICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTsKICBmbG93KHN0cmVhbSk7Cn0KCi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsCi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWQKLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWYKLy8gaXQncyBpbiBwcm9ncmVzcy4KLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSwKLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS4KZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkgewogICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlOwogICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTsKICB9Cn0KCmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHsKICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoOwogIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykgewogICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7CiAgICBzdHJlYW0ucmVhZCgwKTsKICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkKICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy4KICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7CiAgfQogIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7Cn0KCi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy4KLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC4KLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsICJsZW5ndGgiIGlzIHNvbWV3aGF0Ci8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC4KUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHsKICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTsKfTsKClJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7CiAgdmFyIHNyYyA9IHRoaXM7CiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKCiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7CiAgICBjYXNlIDA6CiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDsKICAgICAgYnJlYWs7CiAgICBjYXNlIDE6CiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTsKICAgICAgYnJlYWs7CiAgICBkZWZhdWx0OgogICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpOwogICAgICBicmVhazsKICB9CiAgc3RhdGUucGlwZXNDb3VudCArPSAxOwogIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7CgogIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7CgogIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7CiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pOwoKICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7CiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHsKICAgIGRlYnVnKCdvbnVucGlwZScpOwogICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHsKICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkgewogICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7CiAgICAgICAgY2xlYW51cCgpOwogICAgICB9CiAgICB9CiAgfQoKICBmdW5jdGlvbiBvbmVuZCgpIHsKICAgIGRlYnVnKCdvbmVuZCcpOwogICAgZGVzdC5lbmQoKTsKICB9CgogIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXIKICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKCkKICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpcwogIC8vIHRvbyBzbG93LgogIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTsKICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pOwoKICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7CiAgZnVuY3Rpb24gY2xlYW51cCgpIHsKICAgIGRlYnVnKCdjbGVhbnVwJyk7CiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuCiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpOwogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpOwogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7CiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7CiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTsKICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTsKICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7CgogICAgY2xlYW5lZFVwID0gdHJ1ZTsKCiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzCiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnQKICAgIC8vIGZsb3dpbmcgYWdhaW4uCiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuCiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuCiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7CiAgfQoKICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cAogIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlCiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy4KICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uCiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTsKICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpOwogIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykgewogICAgZGVidWcoJ29uZGF0YScpOwogICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlOwogICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspOwogICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHsKICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlCiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlCiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuCiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLgogICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7CiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTsKICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrOwogICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlOwogICAgICB9CiAgICAgIHNyYy5wYXVzZSgpOwogICAgfQogIH0KCiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuCiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLgogIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHsKICAgIGRlYnVnKCdvbmVycm9yJywgZXIpOwogICAgdW5waXBlKCk7CiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpOwogICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTsKICB9CgogIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy4KICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7CgogIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuCiAgZnVuY3Rpb24gb25jbG9zZSgpIHsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTsKICAgIHVucGlwZSgpOwogIH0KICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7CiAgZnVuY3Rpb24gb25maW5pc2goKSB7CiAgICBkZWJ1Zygnb25maW5pc2gnKTsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7CiAgICB1bnBpcGUoKTsKICB9CiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7CgogIGZ1bmN0aW9uIHVucGlwZSgpIHsKICAgIGRlYnVnKCd1bnBpcGUnKTsKICAgIHNyYy51bnBpcGUoZGVzdCk7CiAgfQoKICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0bwogIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7CgogIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS4KICBpZiAoIXN0YXRlLmZsb3dpbmcpIHsKICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpOwogICAgc3JjLnJlc3VtZSgpOwogIH0KCiAgcmV0dXJuIGRlc3Q7Cn07CgpmdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHsKICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlOwogICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7CiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tOwogICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkgewogICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsKICAgICAgZmxvdyhzcmMpOwogICAgfQogIH07Cn0KClJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkgewogIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07CgogIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy4KICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7CgogIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS4KICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgewogICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuCiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7CgogICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7CgogICAgLy8gZ290IGEgbWF0Y2guCiAgICBzdGF0ZS5waXBlcyA9IG51bGw7CiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDsKICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTsKICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pOwogICAgcmV0dXJuIHRoaXM7CiAgfQoKICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLgoKICBpZiAoIWRlc3QpIHsKICAgIC8vIHJlbW92ZSBhbGwuCiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlczsKICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50OwogICAgc3RhdGUucGlwZXMgPSBudWxsOwogICAgc3RhdGUucGlwZXNDb3VudCA9IDA7CiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTsKICAgIH1yZXR1cm4gdGhpczsKICB9CgogIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuCiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7CiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7CgogIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7CiAgc3RhdGUucGlwZXNDb3VudCAtPSAxOwogIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdOwoKICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pOwoKICByZXR1cm4gdGhpczsKfTsKCi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3IKLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmcKUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikgewogIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTsKCiAgaWYgKGV2ID09PSAnZGF0YScpIHsKICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZAogICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7CiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykgewogICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHsKICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwogICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsKICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7CiAgICAgICAgcHJvY2Vzc05leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpOwogICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkgewogICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIHJlczsKfTsKUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uOwoKZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7CiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpOwogIHNlbGYucmVhZCgwKTsKfQoKLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSQovLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuClJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICBpZiAoIXN0YXRlLmZsb3dpbmcpIHsKICAgIGRlYnVnKCdyZXN1bWUnKTsKICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOwogICAgcmVzdW1lKHRoaXMsIHN0YXRlKTsKICB9CiAgcmV0dXJuIHRoaXM7Cn07CgpmdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkgewogIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7CiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlOwogICAgcHJvY2Vzc05leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpOwogIH0KfQoKZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7CiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpOwogICAgc3RyZWFtLnJlYWQoMCk7CiAgfQoKICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTsKICBzdGF0ZS5hd2FpdERyYWluID0gMDsKICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7CiAgZmxvdyhzdHJlYW0pOwogIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTsKfQoKUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgewogIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpOwogIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7CiAgICBkZWJ1ZygncGF1c2UnKTsKICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlOwogICAgdGhpcy5lbWl0KCdwYXVzZScpOwogIH0KICByZXR1cm4gdGhpczsKfTsKCmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7CiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwogIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7CiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge30KfQoKLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS4KLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLgovLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS4KUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICB2YXIgcGF1c2VkID0gZmFsc2U7CgogIHZhciBzZWxmID0gdGhpczsKICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHsKICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpOwogICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7CiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7CiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHNlbGYucHVzaChjaHVuayk7CiAgICB9CgogICAgc2VsZi5wdXNoKG51bGwpOwogIH0pOwoKICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHsKICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTsKICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOwoKICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZQogICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuOwoKICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspOwogICAgaWYgKCFyZXQpIHsKICAgICAgcGF1c2VkID0gdHJ1ZTsKICAgICAgc3RyZWFtLnBhdXNlKCk7CiAgICB9CiAgfSk7CgogIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy4KICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy4KICBmb3IgKHZhciBpIGluIHN0cmVhbSkgewogICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7CiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7CiAgICAgICAgfTsKICAgICAgfShpKTsKICAgIH0KICB9CgogIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy4KICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykgewogICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgc2VsZi5lbWl0LmJpbmQoc2VsZiwga1Byb3h5RXZlbnRzW25dKSk7CiAgfQoKICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlCiAgLy8gdW5kZXJseWluZyBzdHJlYW0uCiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7CiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pOwogICAgaWYgKHBhdXNlZCkgewogICAgICBwYXVzZWQgPSBmYWxzZTsKICAgICAgc3RyZWFtLnJlc3VtZSgpOwogICAgfQogIH07CgogIHJldHVybiBzZWxmOwp9OwoKLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LgpSZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDsKCi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy4KLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC4KLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmcKLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS4KZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHsKICAvLyBub3RoaW5nIGJ1ZmZlcmVkCiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7CgogIHZhciByZXQ7CiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7CiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3QKICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTsKICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpOwogIH0gZWxzZSB7CiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdAogICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7CiAgfQoKICByZXR1cm4gcmV0Owp9CgovLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuCi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nCi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuCmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7CiAgdmFyIHJldDsKICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkgewogICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MKICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pOwogICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTsKICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkgewogICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoCiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7CiAgfSBlbHNlIHsKICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlcgogICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7CiAgfQogIHJldHVybiByZXQ7Cn0KCi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEKLy8gY2h1bmtzLgovLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZwovLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LgpmdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7CiAgdmFyIHAgPSBsaXN0LmhlYWQ7CiAgdmFyIGMgPSAxOwogIHZhciByZXQgPSBwLmRhdGE7CiAgbiAtPSByZXQubGVuZ3RoOwogIHdoaWxlIChwID0gcC5uZXh0KSB7CiAgICB2YXIgc3RyID0gcC5kYXRhOwogICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjsKICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7CiAgICBuIC09IG5iOwogICAgaWYgKG4gPT09IDApIHsKICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7CiAgICAgICAgKytjOwogICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbGlzdC5oZWFkID0gcDsKICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpOwogICAgICB9CiAgICAgIGJyZWFrOwogICAgfQogICAgKytjOwogIH0KICBsaXN0Lmxlbmd0aCAtPSBjOwogIHJldHVybiByZXQ7Cn0KCi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy4KLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmcKLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS4KZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkgewogIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7CiAgdmFyIHAgPSBsaXN0LmhlYWQ7CiAgdmFyIGMgPSAxOwogIHAuZGF0YS5jb3B5KHJldCk7CiAgbiAtPSBwLmRhdGEubGVuZ3RoOwogIHdoaWxlIChwID0gcC5uZXh0KSB7CiAgICB2YXIgYnVmID0gcC5kYXRhOwogICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjsKICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTsKICAgIG4gLT0gbmI7CiAgICBpZiAobiA9PT0gMCkgewogICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHsKICAgICAgICArK2M7CiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDsKICAgICAgfSBlbHNlIHsKICAgICAgICBsaXN0LmhlYWQgPSBwOwogICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7CiAgICAgIH0KICAgICAgYnJlYWs7CiAgICB9CiAgICArK2M7CiAgfQogIGxpc3QubGVuZ3RoIC09IGM7CiAgcmV0dXJuIHJldDsKfQoKZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7CiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwoKICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhCiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLgogIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJyJlbmRSZWFkYWJsZSgpIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpOwoKICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHsKICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTsKICAgIHByb2Nlc3NOZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTsKICB9Cn0KCmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkgewogIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LgogIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHsKICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlOwogICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7CiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7CiAgfQp9CgpmdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7CiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgIGYoeHNbaV0sIGkpOwogIH0KfQoKZnVuY3Rpb24gaW5kZXhPZih4cywgeCkgewogIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpOwogIH0KICByZXR1cm4gLTE7Cn0KfSkuY2FsbCh0aGlzLF9kZXJlcV8oJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSkKfSx7Ii4vX3N0cmVhbV9kdXBsZXgiOjEyMSwiLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QiOjEyNiwiLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kiOjEyNywiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbSI6MTI4LCJfcHJvY2VzcyI6OTksImNvcmUtdXRpbC1pcyI6MTAwLCJldmVudHMiOjEwMiwiaW5oZXJpdHMiOjEwNCwiaXNhcnJheSI6MTA2LCJwcm9jZXNzLW5leHRpY2stYXJncyI6MTE4LCJzYWZlLWJ1ZmZlciI6MTI5LCJzdHJpbmdfZGVjb2Rlci8iOjEzMCwidXRpbCI6OTZ9XSwxMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgovLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvCi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgImZpbHRlciIsCi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlCi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGQKLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKQovLwovLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhCi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLAovLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW4KLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLgovLwovLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6Ci8vCi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZQovLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpCi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXMKLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbAovLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuCi8vCi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuCi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlCi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZQovLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdAovLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG8KLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LgovLwovLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsCi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsCi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmcKLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXMKLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueQovLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluCi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbAovLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluCi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbAovLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZAovLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LgovLwovLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rCi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWwKLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuCgondXNlIHN0cmljdCc7Cgptb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTsKCnZhciBEdXBsZXggPSBfZGVyZXFfKCcuL19zdHJlYW1fZHVwbGV4Jyk7CgovKjxyZXBsYWNlbWVudD4qLwp2YXIgdXRpbCA9IF9kZXJlcV8oJ2NvcmUtdXRpbC1pcycpOwp1dGlsLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTsKLyo8L3JlcGxhY2VtZW50PiovCgp1dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTsKCmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKHN0cmVhbSkgewogIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHsKICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTsKICB9OwoKICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTsKICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlOwogIHRoaXMud3JpdGVjYiA9IG51bGw7CiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDsKICB0aGlzLndyaXRlZW5jb2RpbmcgPSBudWxsOwp9CgpmdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7CiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTsKICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTsKCiAgdmFyIGNiID0gdHMud3JpdGVjYjsKCiAgaWYgKCFjYikgewogICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpOwogIH0KCiAgdHMud3JpdGVjaHVuayA9IG51bGw7CiAgdHMud3JpdGVjYiA9IG51bGw7CgogIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZCkgc3RyZWFtLnB1c2goZGF0YSk7CgogIGNiKGVyKTsKCiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwogIHJzLnJlYWRpbmcgPSBmYWxzZTsKICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHsKICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTsKICB9Cn0KCmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7CiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpOwoKICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTsKCiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7CgogIHZhciBzdHJlYW0gPSB0aGlzOwoKICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC4KICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CgogIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5ncwogIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGUKICAvLyBzeW5jIGd1YXJkIGZsYWcuCiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7CgogIGlmIChvcHRpb25zKSB7CiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTsKCiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDsKICB9CgogIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy4KICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHsKICAgIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkgewogICAgICBkb25lKHN0cmVhbSwgZXIsIGRhdGEpOwogICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7CiAgfSk7Cn0KClRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHsKICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7CiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7Cn07CgovLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiEKLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLgovLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLgovLwovLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXQKLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy4KLy8KLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3MKLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdQovLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLgpUcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewogIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpOwp9OwoKVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewogIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlOwogIHRzLndyaXRlY2IgPSBjYjsKICB0cy53cml0ZWNodW5rID0gY2h1bms7CiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nOwogIGlmICghdHMudHJhbnNmb3JtaW5nKSB7CiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7CiAgfQp9OwoKLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS4KLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay4KLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS4KVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7CiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7CgogIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykgewogICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTsKICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7CiAgfSBlbHNlIHsKICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW4KICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LgogICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7CiAgfQp9OwoKVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7CiAgdmFyIF90aGlzID0gdGhpczsKCiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHsKICAgIGNiKGVycjIpOwogICAgX3RoaXMuZW1pdCgnY2xvc2UnKTsKICB9KTsKfTsKCmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkgewogIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTsKCiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTsKCiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFucwogIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZAogIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTsKICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlOwoKICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpOwoKICBpZiAodHMudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTsKCiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpOwp9Cn0seyIuL19zdHJlYW1fZHVwbGV4IjoxMjEsImNvcmUtdXRpbC1pcyI6MTAwLCJpbmhlcml0cyI6MTA0fV0sMTI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLgovLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGwKLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuCgondXNlIHN0cmljdCc7CgovKjxyZXBsYWNlbWVudD4qLwoKdmFyIHByb2Nlc3NOZXh0VGljayA9IF9kZXJlcV8oJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKbW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTsKCi8qIDxyZXBsYWNlbWVudD4gKi8KZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikgewogIHRoaXMuY2h1bmsgPSBjaHVuazsKICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7CiAgdGhpcy5jYWxsYmFjayA9IGNiOwogIHRoaXMubmV4dCA9IG51bGw7Cn0KCi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdAovLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW0KZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkgewogIHZhciBfdGhpcyA9IHRoaXM7CgogIHRoaXMubmV4dCA9IG51bGw7CiAgdGhpcy5lbnRyeSA9IG51bGw7CiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7CiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpOwogIH07Cn0KLyogPC9yZXBsYWNlbWVudD4gKi8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIER1cGxleDsKLyo8L3JlcGxhY2VtZW50PiovCgpXcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTsKCi8qPHJlcGxhY2VtZW50PiovCnZhciB1dGlsID0gX2RlcmVxXygnY29yZS11dGlsLWlzJyk7CnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBpbnRlcm5hbFV0aWwgPSB7CiAgZGVwcmVjYXRlOiBfZGVyZXFfKCd1dGlsLWRlcHJlY2F0ZScpCn07Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIFN0cmVhbSA9IF9kZXJlcV8oJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgQnVmZmVyID0gX2RlcmVxXygnc2FmZS1idWZmZXInKS5CdWZmZXI7CnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307CmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHsKICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspOwp9CmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7CiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7Cn0KLyo8L3JlcGxhY2VtZW50PiovCgp2YXIgZGVzdHJveUltcGwgPSBfZGVyZXFfKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpOwoKdXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTsKCmZ1bmN0aW9uIG5vcCgpIHt9CgpmdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkgewogIER1cGxleCA9IER1cGxleCB8fCBfZGVyZXFfKCcuL19zdHJlYW1fZHVwbGV4Jyk7CgogIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwoKICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW0KICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuCiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7CgogIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlOwoKICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlCiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWYKICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpCiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyazsKICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0OwogIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtOwoKICAvLyBjYXN0IHRvIGludHMuCiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspOwoKICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkCiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlOwoKICAvLyBkcmFpbiBldmVudCBmbGFnLgogIHRoaXMubmVlZERyYWluID0gZmFsc2U7CiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKCkKICB0aGlzLmVuZGluZyA9IGZhbHNlOwogIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWQKICB0aGlzLmVuZGVkID0gZmFsc2U7CiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkCiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlOwoKICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWQKICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOwoKICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT8KICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmcKICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLgogIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7CiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlOwoKICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nCiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLgogIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC4KICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsKCiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnQKICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nCiAgLy8gc29ja2V0IG9yIGZpbGUuCiAgdGhpcy5sZW5ndGggPSAwOwoKICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLgogIHRoaXMud3JpdGluZyA9IGZhbHNlOwoKICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsCiAgdGhpcy5jb3JrZWQgPSAwOwoKICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSwKICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueQogIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsICJsYXRlciIgc2hvdWxkIGdlbmVyYWxseSBhbHNvCiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuCiAgdGhpcy5zeW5jID0gdHJ1ZTsKCiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaAogIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0CiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uCiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7CgogIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYikKICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHsKICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7CiAgfTsKCiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpCiAgdGhpcy53cml0ZWNiID0gbnVsbDsKCiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLgogIHRoaXMud3JpdGVsZW4gPSAwOwoKICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsKCiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3MKICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWQKICB0aGlzLnBlbmRpbmdjYiA9IDA7CgogIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnMKICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtcwogIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTsKCiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW4KICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlOwoKICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0cwogIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwOwoKICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzCiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3bwogIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7Cn0KCldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHsKICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0OwogIHZhciBvdXQgPSBbXTsKICB3aGlsZSAoY3VycmVudCkgewogICAgb3V0LnB1c2goY3VycmVudCk7CiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0OwogIH0KICByZXR1cm4gb3V0Owp9OwoKKGZ1bmN0aW9uICgpIHsKICB0cnkgewogICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywgewogICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpOwogICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJykKICAgIH0pOwogIH0gY2F0Y2ggKF8pIHt9Cn0pKCk7CgovLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcywKLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLgp2YXIgcmVhbEhhc0luc3RhbmNlOwppZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7CiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHsKICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7CiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTsKCiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTsKICAgIH0KICB9KTsKfSBlbHNlIHsKICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7CiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpczsKICB9Owp9CgpmdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7CiAgRHVwbGV4ID0gRHVwbGV4IHx8IF9kZXJlcV8oJy4vX3N0cmVhbV9kdXBsZXgnKTsKCiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uCiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgCiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLgoKICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGUKICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3IKICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uCiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgewogICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTsKICB9CgogIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTsKCiAgLy8gbGVnYWN5LgogIHRoaXMud3JpdGFibGUgPSB0cnVlOwoKICBpZiAob3B0aW9ucykgewogICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7CgogICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7CgogICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7CgogICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7CiAgfQoKICBTdHJlYW0uY2FsbCh0aGlzKTsKfQoKLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLgpXcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHsKICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpOwp9OwoKZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7CiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTsKICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYgogIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTsKICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTsKfQoKLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhcgovLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkCi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS4KZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHsKICB2YXIgdmFsaWQgPSB0cnVlOwogIHZhciBlciA9IGZhbHNlOwoKICBpZiAoY2h1bmsgPT09IG51bGwpIHsKICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTsKICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkgewogICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7CiAgfQogIGlmIChlcikgewogICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpOwogICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7CiAgICB2YWxpZCA9IGZhbHNlOwogIH0KICByZXR1cm4gdmFsaWQ7Cn0KCldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTsKICB2YXIgcmV0ID0gZmFsc2U7CiAgdmFyIGlzQnVmID0gX2lzVWludDhBcnJheShjaHVuaykgJiYgIXN0YXRlLm9iamVjdE1vZGU7CgogIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgewogICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTsKICB9CgogIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHsKICAgIGNiID0gZW5jb2Rpbmc7CiAgICBlbmNvZGluZyA9IG51bGw7CiAgfQoKICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZzsKCiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7CgogIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkgewogICAgc3RhdGUucGVuZGluZ2NiKys7CiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7CiAgfQoKICByZXR1cm4gcmV0Owp9OwoKV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTsKCiAgc3RhdGUuY29ya2VkKys7Cn07CgpXcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkgewogIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CgogIGlmIChzdGF0ZS5jb3JrZWQpIHsKICAgIHN0YXRlLmNvcmtlZC0tOwoKICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTsKICB9Cn07CgpXcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7CiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuCiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTsKICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpOwogIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7CiAgcmV0dXJuIHRoaXM7Cn07CgpmdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7CiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHsKICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTsKICB9CiAgcmV0dXJuIGNodW5rOwp9CgovLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXMKLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGUKLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy4KZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikgewogIGlmICghaXNCdWYpIHsKICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpOwogICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykgewogICAgICBpc0J1ZiA9IHRydWU7CiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7CiAgICAgIGNodW5rID0gbmV3Q2h1bms7CiAgICB9CiAgfQogIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDsKCiAgc3RhdGUubGVuZ3RoICs9IGxlbjsKCiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7CiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuCiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7CgogIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkgewogICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0OwogICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHsKICAgICAgY2h1bms6IGNodW5rLAogICAgICBlbmNvZGluZzogZW5jb2RpbmcsCiAgICAgIGlzQnVmOiBpc0J1ZiwKICAgICAgY2FsbGJhY2s6IGNiLAogICAgICBuZXh0OiBudWxsCiAgICB9OwogICAgaWYgKGxhc3QpIHsKICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDsKICAgIH0gZWxzZSB7CiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7CiAgICB9CiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxOwogIH0gZWxzZSB7CiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpOwogIH0KCiAgcmV0dXJuIHJldDsKfQoKZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikgewogIHN0YXRlLndyaXRlbGVuID0gbGVuOwogIHN0YXRlLndyaXRlY2IgPSBjYjsKICBzdGF0ZS53cml0aW5nID0gdHJ1ZTsKICBzdGF0ZS5zeW5jID0gdHJ1ZTsKICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7CiAgc3RhdGUuc3luYyA9IGZhbHNlOwp9CgpmdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7CiAgLS1zdGF0ZS5wZW5kaW5nY2I7CgogIGlmIChzeW5jKSB7CiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5CiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFjawogICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7CiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlbgogICAgLy8gYWZ0ZXIgZXJyb3IKICAgIHByb2Nlc3NOZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7CiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTsKICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTsKICB9IGVsc2UgewogICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmCiAgICAvLyBpdCBpcyBhc3luYwogICAgY2IoZXIpOwogICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7CiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7CiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0CiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yCiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTsKICB9Cn0KCmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkgewogIHN0YXRlLndyaXRpbmcgPSBmYWxzZTsKICBzdGF0ZS53cml0ZWNiID0gbnVsbDsKICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47CiAgc3RhdGUud3JpdGVsZW4gPSAwOwp9CgpmdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHsKICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7CiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jOwogIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7CgogIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7CgogIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7CiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldAogICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7CgogICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgewogICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTsKICAgIH0KCiAgICBpZiAoc3luYykgewogICAgICAvKjxyZXBsYWNlbWVudD4qLwogICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7CiAgICAgIC8qPC9yZXBsYWNlbWVudD4qLwogICAgfSBlbHNlIHsKICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpOwogICAgfQogIH0KfQoKZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHsKICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7CiAgc3RhdGUucGVuZGluZ2NiLS07CiAgY2IoKTsKICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTsKfQoKLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3QKLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVybgovLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLgpmdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkgewogIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7CiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTsKICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpOwogIH0KfQoKLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXQKZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkgewogIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlOwogIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDsKCiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHsKICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KCkKICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7CiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpOwogICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTsKICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5OwoKICAgIHZhciBjb3VudCA9IDA7CiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7CiAgICB3aGlsZSAoZW50cnkpIHsKICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5OwogICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7CiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDsKICAgICAgY291bnQgKz0gMTsKICAgIH0KICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVyczsKCiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7CgogICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWUKICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZQogICAgc3RhdGUucGVuZGluZ2NiKys7CiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsKICAgIGlmIChob2xkZXIubmV4dCkgewogICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDsKICAgICAgaG9sZGVyLm5leHQgPSBudWxsOwogICAgfSBlbHNlIHsKICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpOwogICAgfQogIH0gZWxzZSB7CiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lCiAgICB3aGlsZSAoZW50cnkpIHsKICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7CiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nOwogICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjazsKICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoOwoKICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTsKICAgICAgZW50cnkgPSBlbnRyeS5uZXh0OwogICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlbgogICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLgogICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5CiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLgogICAgICBpZiAoc3RhdGUud3JpdGluZykgewogICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CgogICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsKICB9CgogIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsKICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTsKICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7Cn0KCldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewogIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpOwp9OwoKV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsOwoKV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTsKCiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykgewogICAgY2IgPSBjaHVuazsKICAgIGNodW5rID0gbnVsbDsKICAgIGVuY29kaW5nID0gbnVsbDsKICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykgewogICAgY2IgPSBlbmNvZGluZzsKICAgIGVuY29kaW5nID0gbnVsbDsKICB9CgogIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7CgogIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzCiAgaWYgKHN0YXRlLmNvcmtlZCkgewogICAgc3RhdGUuY29ya2VkID0gMTsKICAgIHRoaXMudW5jb3JrKCk7CiAgfQoKICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuCiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpOwp9OwoKZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkgewogIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7Cn0KZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHsKICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHsKICAgIHN0YXRlLnBlbmRpbmdjYi0tOwogICAgaWYgKGVycikgewogICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpOwogICAgfQogICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlOwogICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpOwogICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7CiAgfSk7Cn0KZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHsKICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkgewogICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7CiAgICAgIHN0YXRlLnBlbmRpbmdjYisrOwogICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7CiAgICAgIHByb2Nlc3NOZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpOwogICAgfSBlbHNlIHsKICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlOwogICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7CiAgICB9CiAgfQp9CgpmdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7CiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTsKICBpZiAobmVlZCkgewogICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpOwogICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkgewogICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7CiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTsKICAgIH0KICB9CiAgcmV0dXJuIG5lZWQ7Cn0KCmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7CiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTsKICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTsKICBpZiAoY2IpIHsKICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzc05leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7CiAgfQogIHN0YXRlLmVuZGVkID0gdHJ1ZTsKICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTsKfQoKZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikgewogIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7CiAgY29ya1JlcS5lbnRyeSA9IG51bGw7CiAgd2hpbGUgKGVudHJ5KSB7CiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjazsKICAgIHN0YXRlLnBlbmRpbmdjYi0tOwogICAgY2IoZXJyKTsKICAgIGVudHJ5ID0gZW50cnkubmV4dDsKICB9CiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkgewogICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxOwogIH0gZWxzZSB7CiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxOwogIH0KfQoKT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHsKICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkOwogIH0sCiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHsKICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbQogICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldAogICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5CiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWQKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7CiAgfQp9KTsKCldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTsKV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7CldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7CiAgdGhpcy5lbmQoKTsKICBjYihlcnIpOwp9Owp9KS5jYWxsKHRoaXMsX2RlcmVxXygnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHt9KQp9LHsiLi9fc3RyZWFtX2R1cGxleCI6MTIxLCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveSI6MTI3LCIuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtIjoxMjgsIl9wcm9jZXNzIjo5OSwiY29yZS11dGlsLWlzIjoxMDAsImluaGVyaXRzIjoxMDQsInByb2Nlc3MtbmV4dGljay1hcmdzIjoxMTgsInNhZmUtYnVmZmVyIjoxMjksInV0aWwtZGVwcmVjYXRlIjoxMzZ9XSwxMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7CgovKjxyZXBsYWNlbWVudD4qLwoKZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsgfSB9Cgp2YXIgQnVmZmVyID0gX2RlcmVxXygnc2FmZS1idWZmZXInKS5CdWZmZXI7Ci8qPC9yZXBsYWNlbWVudD4qLwoKZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7CiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpOwp9Cgptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsKICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpOwoKICAgIHRoaXMuaGVhZCA9IG51bGw7CiAgICB0aGlzLnRhaWwgPSBudWxsOwogICAgdGhpcy5sZW5ndGggPSAwOwogIH0KCiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikgewogICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07CiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7CiAgICB0aGlzLnRhaWwgPSBlbnRyeTsKICAgICsrdGhpcy5sZW5ndGg7CiAgfTsKCiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikgewogICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTsKICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7CiAgICB0aGlzLmhlYWQgPSBlbnRyeTsKICAgICsrdGhpcy5sZW5ndGg7CiAgfTsKCiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHsKICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuOwogICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhOwogICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7CiAgICAtLXRoaXMubGVuZ3RoOwogICAgcmV0dXJuIHJldDsKICB9OwoKICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkgewogICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDsKICAgIHRoaXMubGVuZ3RoID0gMDsKICB9OwoKICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7CiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJzsKICAgIHZhciBwID0gdGhpcy5oZWFkOwogICAgdmFyIHJldCA9ICcnICsgcC5kYXRhOwogICAgd2hpbGUgKHAgPSBwLm5leHQpIHsKICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7CiAgICB9cmV0dXJuIHJldDsKICB9OwoKICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikgewogICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApOwogICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7CiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApOwogICAgdmFyIHAgPSB0aGlzLmhlYWQ7CiAgICB2YXIgaSA9IDA7CiAgICB3aGlsZSAocCkgewogICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTsKICAgICAgaSArPSBwLmRhdGEubGVuZ3RoOwogICAgICBwID0gcC5uZXh0OwogICAgfQogICAgcmV0dXJuIHJldDsKICB9OwoKICByZXR1cm4gQnVmZmVyTGlzdDsKfSgpOwp9LHsic2FmZS1idWZmZXIiOjEyOX1dLDEyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCi8qPHJlcGxhY2VtZW50PiovCgp2YXIgcHJvY2Vzc05leHRUaWNrID0gX2RlcmVxXygncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTsKLyo8L3JlcGxhY2VtZW50PiovCgovLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJCmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikgewogIHZhciBfdGhpcyA9IHRoaXM7CgogIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7CiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDsKCiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7CiAgICBpZiAoY2IpIHsKICAgICAgY2IoZXJyKTsKICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7CiAgICAgIHByb2Nlc3NOZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTsKICAgIH0KICAgIHJldHVybjsKICB9CgogIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlcgogIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrcwoKICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkgewogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlOwogIH0KCiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbAogIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7CiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7CiAgfQoKICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7CiAgICBpZiAoIWNiICYmIGVycikgewogICAgICBwcm9jZXNzTmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpOwogICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHsKICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlOwogICAgICB9CiAgICB9IGVsc2UgaWYgKGNiKSB7CiAgICAgIGNiKGVycik7CiAgICB9CiAgfSk7Cn0KCmZ1bmN0aW9uIHVuZGVzdHJveSgpIHsKICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkgewogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTsKICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlOwogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlOwogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7CiAgfQoKICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkgewogICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7CiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7CiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlOwogIH0KfQoKZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7CiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7Cn0KCm1vZHVsZS5leHBvcnRzID0gewogIGRlc3Ryb3k6IGRlc3Ryb3ksCiAgdW5kZXN0cm95OiB1bmRlc3Ryb3kKfTsKfSx7InByb2Nlc3MtbmV4dGljay1hcmdzIjoxMTh9XSwxMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjsKCn0seyJldmVudHMiOjEwMn1dLDEyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi8KdmFyIGJ1ZmZlciA9IF9kZXJlcV8oJ2J1ZmZlcicpCnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyCgovLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzCmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHsKICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7CiAgICBkc3Rba2V5XSA9IHNyY1trZXldCiAgfQp9CmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHsKICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlcgp9IGVsc2UgewogIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpCiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cykKICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXIKfQoKZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKQp9CgovLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyCmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpCgpTYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHsKICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJykKICB9CiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkKfQoKU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykgewogIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKQogIH0KICB2YXIgYnVmID0gQnVmZmVyKHNpemUpCiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkgewogICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHsKICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpCiAgICB9IGVsc2UgewogICAgICBidWYuZmlsbChmaWxsKQogICAgfQogIH0gZWxzZSB7CiAgICBidWYuZmlsbCgwKQogIH0KICByZXR1cm4gYnVmCn0KClNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkgewogIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKQogIH0KICByZXR1cm4gQnVmZmVyKHNpemUpCn0KClNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHsKICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJykKICB9CiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpCn0KCn0seyJidWZmZXIiOjk4fV0sMTMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwoKdmFyIEJ1ZmZlciA9IF9kZXJlcV8oJ3NhZmUtYnVmZmVyJykuQnVmZmVyOwoKdmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHsKICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7CiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7CiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzoKICAgICAgcmV0dXJuIHRydWU7CiAgICBkZWZhdWx0OgogICAgICByZXR1cm4gZmFsc2U7CiAgfQp9OwoKZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykgewogIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnOwogIHZhciByZXRyaWVkOwogIHdoaWxlICh0cnVlKSB7CiAgICBzd2l0Y2ggKGVuYykgewogICAgICBjYXNlICd1dGY4JzoKICAgICAgY2FzZSAndXRmLTgnOgogICAgICAgIHJldHVybiAndXRmOCc7CiAgICAgIGNhc2UgJ3VjczInOgogICAgICBjYXNlICd1Y3MtMic6CiAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgICAgcmV0dXJuICd1dGYxNmxlJzsKICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgY2FzZSAnYmluYXJ5JzoKICAgICAgICByZXR1cm4gJ2xhdGluMSc7CiAgICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgIGNhc2UgJ2FzY2lpJzoKICAgICAgY2FzZSAnaGV4JzoKICAgICAgICByZXR1cm4gZW5jOwogICAgICBkZWZhdWx0OgogICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZAogICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTsKICAgICAgICByZXRyaWVkID0gdHJ1ZTsKICAgIH0KICB9Cn07CgovLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWUKLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5ncwpmdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHsKICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpOwogIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpOwogIHJldHVybiBuZW5jIHx8IGVuYzsKfQoKLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZgovLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGUKLy8gY2hhcmFjdGVycy4KZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjsKZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykgewogIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7CiAgdmFyIG5iOwogIHN3aXRjaCAodGhpcy5lbmNvZGluZykgewogICAgY2FzZSAndXRmMTZsZSc6CiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDsKICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDsKICAgICAgbmIgPSA0OwogICAgICBicmVhazsKICAgIGNhc2UgJ3V0ZjgnOgogICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0OwogICAgICBuYiA9IDQ7CiAgICAgIGJyZWFrOwogICAgY2FzZSAnYmFzZTY0JzoKICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDsKICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7CiAgICAgIG5iID0gMzsKICAgICAgYnJlYWs7CiAgICBkZWZhdWx0OgogICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7CiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kOwogICAgICByZXR1cm47CiAgfQogIHRoaXMubGFzdE5lZWQgPSAwOwogIHRoaXMubGFzdFRvdGFsID0gMDsKICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTsKfQoKU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7CiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJzsKICB2YXIgcjsKICB2YXIgaTsKICBpZiAodGhpcy5sYXN0TmVlZCkgewogICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTsKICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJzsKICAgIGkgPSB0aGlzLmxhc3ROZWVkOwogICAgdGhpcy5sYXN0TmVlZCA9IDA7CiAgfSBlbHNlIHsKICAgIGkgPSAwOwogIH0KICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7CiAgcmV0dXJuIHIgfHwgJyc7Cn07CgpTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kOwoKLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIKU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0OwoKLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlcgpTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHsKICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7CiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpOwogICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpOwogIH0KICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpOwogIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDsKfTsKCi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGEKLy8gY29udGludWF0aW9uIGJ5dGUuCmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkgewogIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0OwogIHJldHVybiAtMTsKfQoKLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhbgovLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KQovLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLgpmdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkgewogIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7CiAgaWYgKGogPCBpKSByZXR1cm4gMDsKICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7CiAgaWYgKG5iID49IDApIHsKICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7CiAgICByZXR1cm4gbmI7CiAgfQogIGlmICgtLWogPCBpKSByZXR1cm4gMDsKICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTsKICBpZiAobmIgPj0gMCkgewogICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjsKICAgIHJldHVybiBuYjsKICB9CiAgaWYgKC0taiA8IGkpIHJldHVybiAwOwogIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pOwogIGlmIChuYiA+PSAwKSB7CiAgICBpZiAobmIgPiAwKSB7CiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMzsKICAgIH0KICAgIHJldHVybiBuYjsKICB9CiAgcmV0dXJuIDA7Cn0KCi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhcwovLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdAovLyBvbmUsIHdlICJyZXBsYWNlIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoCi8vIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgKCdcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZwovLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlCi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuCi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGEKLy8gbG9vcC4KZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHsKICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7CiAgICBzZWxmLmxhc3ROZWVkID0gMDsKICAgIHJldHVybiAnXHVmZmZkJy5yZXBlYXQocCk7CiAgfQogIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkgewogICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkgewogICAgICBzZWxmLmxhc3ROZWVkID0gMTsKICAgICAgcmV0dXJuICdcdWZmZmQnLnJlcGVhdChwICsgMSk7CiAgICB9CiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHsKICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkgewogICAgICAgIHNlbGYubGFzdE5lZWQgPSAyOwogICAgICAgIHJldHVybiAnXHVmZmZkJy5yZXBlYXQocCArIDIpOwogICAgICB9CiAgICB9CiAgfQp9CgovLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuCmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHsKICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDsKICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTsKICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjsKICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7CiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTsKICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTsKICB9CiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7CiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoOwp9CgovLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGEKLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkCi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLgpmdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHsKICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7CiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7CiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDsKICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpOwogIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7CiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7Cn0KCi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgZm9yIGVhY2ggYnVmZmVyZWQgYnl0ZSBvZiBhIChwYXJ0aWFsKQovLyBjaGFyYWN0ZXIgbmVlZHMgdG8gYmUgYWRkZWQgdG8gdGhlIG91dHB1dC4KZnVuY3Rpb24gdXRmOEVuZChidWYpIHsKICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7CiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1x1ZmZmZCcucmVwZWF0KHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7CiAgcmV0dXJuIHI7Cn0KCi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuCi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoCi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0bwovLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LgpmdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7CiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7CiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpOwogICAgaWYgKHIpIHsKICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTsKICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7CiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7CiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0OwogICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdOwogICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdOwogICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHI7CiAgfQogIHRoaXMubGFzdE5lZWQgPSAxOwogIHRoaXMubGFzdFRvdGFsID0gMjsKICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTsKICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpOwp9CgovLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZQovLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC4KZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7CiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnOwogIGlmICh0aGlzLmxhc3ROZWVkKSB7CiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkOwogICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTsKICB9CiAgcmV0dXJuIHI7Cn0KCmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7CiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMzsKICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7CiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuOwogIHRoaXMubGFzdFRvdGFsID0gMzsKICBpZiAobiA9PT0gMSkgewogICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07CiAgfSBlbHNlIHsKICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdOwogICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07CiAgfQogIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTsKfQoKZnVuY3Rpb24gYmFzZTY0RW5kKGJ1ZikgewogIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJzsKICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7CiAgcmV0dXJuIHI7Cn0KCi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleCkKZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7CiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTsKfQoKZnVuY3Rpb24gc2ltcGxlRW5kKGJ1ZikgewogIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnOwp9Cn0seyJzYWZlLWJ1ZmZlciI6MTI5fV0sMTMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2gKCn0seyIuL3JlYWRhYmxlIjoxMzJ9XSwxMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7CmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0czsKZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7CmV4cG9ydHMuV3JpdGFibGUgPSBfZGVyZXFfKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7CmV4cG9ydHMuRHVwbGV4ID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTsKZXhwb3J0cy5UcmFuc2Zvcm0gPSBfZGVyZXFfKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpOwpleHBvcnRzLlBhc3NUaHJvdWdoID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpOwoKfSx7Ii4vbGliL19zdHJlYW1fZHVwbGV4LmpzIjoxMjEsIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiOjEyMiwiLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyI6MTIzLCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyI6MTI0LCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIjoxMjV9XSwxMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm0KCn0seyIuL3JlYWRhYmxlIjoxMzJ9XSwxMzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTsKCn0seyIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIjoxMjV9XSwxMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgptb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTsKCnZhciBFRSA9IF9kZXJlcV8oJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjsKdmFyIGluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTsKCmluaGVyaXRzKFN0cmVhbSwgRUUpOwpTdHJlYW0uUmVhZGFibGUgPSBfZGVyZXFfKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTsKU3RyZWFtLldyaXRhYmxlID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7ClN0cmVhbS5EdXBsZXggPSBfZGVyZXFfKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7ClN0cmVhbS5UcmFuc2Zvcm0gPSBfZGVyZXFfKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7ClN0cmVhbS5QYXNzVGhyb3VnaCA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpOwoKLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LngKU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTsKCgoKLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudAovLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLgoKZnVuY3Rpb24gU3RyZWFtKCkgewogIEVFLmNhbGwodGhpcyk7Cn0KClN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHsKICB2YXIgc291cmNlID0gdGhpczsKCiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7CiAgICBpZiAoZGVzdC53cml0YWJsZSkgewogICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkgewogICAgICAgIHNvdXJjZS5wYXVzZSgpOwogICAgICB9CiAgICB9CiAgfQoKICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpOwoKICBmdW5jdGlvbiBvbmRyYWluKCkgewogICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7CiAgICAgIHNvdXJjZS5yZXN1bWUoKTsKICAgIH0KICB9CgogIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7CgogIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW4KICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS4KICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHsKICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpOwogICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpOwogIH0KCiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7CiAgZnVuY3Rpb24gb25lbmQoKSB7CiAgICBpZiAoZGlkT25FbmQpIHJldHVybjsKICAgIGRpZE9uRW5kID0gdHJ1ZTsKCiAgICBkZXN0LmVuZCgpOwogIH0KCgogIGZ1bmN0aW9uIG9uY2xvc2UoKSB7CiAgICBpZiAoZGlkT25FbmQpIHJldHVybjsKICAgIGRpZE9uRW5kID0gdHJ1ZTsKCiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7CiAgfQoKICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuCiAgZnVuY3Rpb24gb25lcnJvcihlcikgewogICAgY2xlYW51cCgpOwogICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHsKICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS4KICAgIH0KICB9CgogIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTsKICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpOwoKICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLgogIGZ1bmN0aW9uIGNsZWFudXAoKSB7CiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpOwogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTsKCiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTsKICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTsKCiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7CiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpOwoKICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7CiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7CgogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTsKICB9CgogIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7CiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApOwoKICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApOwoKICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpOwoKICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKQogIHJldHVybiBkZXN0Owp9OwoKfSx7ImV2ZW50cyI6MTAyLCJpbmhlcml0cyI6MTA0LCJyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIjoxMjAsInJlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyI6MTMxLCJyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiOjEzMiwicmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyI6MTMzLCJyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMiOjEzNH1dLDEzNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAoZ2xvYmFsKXsKCi8qKgogKiBNb2R1bGUgZXhwb3J0cy4KICovCgptb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTsKCi8qKgogKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLgogKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LgogKgogKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC4KICoKICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zCiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLgogKgogKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnMKICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC4KICoKICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlCiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgImRlcHJlY2F0ZWQiIHZlcnNpb24gb2YgYGZuYAogKiBAYXBpIHB1YmxpYwogKi8KCmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykgewogIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkgewogICAgcmV0dXJuIGZuOwogIH0KCiAgdmFyIHdhcm5lZCA9IGZhbHNlOwogIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7CiAgICBpZiAoIXdhcm5lZCkgewogICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTsKICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkgewogICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zb2xlLndhcm4obXNnKTsKICAgICAgfQogICAgICB3YXJuZWQgPSB0cnVlOwogICAgfQogICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgfQoKICByZXR1cm4gZGVwcmVjYXRlZDsKfQoKLyoqCiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuCiAqCiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lCiAqIEByZXR1cm5zIHtCb29sZWFufQogKiBAYXBpIHByaXZhdGUKICovCgpmdW5jdGlvbiBjb25maWcgKG5hbWUpIHsKICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lcwogIHRyeSB7CiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTsKICB9IGNhdGNoIChfKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQogIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdOwogIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlOwogIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7Cn0KCn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHt9KQp9LHt9XSwxMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewphcmd1bWVudHNbNF1bMTA0XVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykKfSx7ImR1cCI6MTA0fV0sMTM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHsKICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnCiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbicKICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJwogICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7Cn0KfSx7fV0sMTM5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nOwpleHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHsKICBpZiAoIWlzU3RyaW5nKGYpKSB7CiAgICB2YXIgb2JqZWN0cyA9IFtdOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsKICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7CiAgICB9CiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7CiAgfQoKICB2YXIgaSA9IDE7CiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7CiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoOwogIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHsKICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnOwogICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDsKICAgIHN3aXRjaCAoeCkgewogICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTsKICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7CiAgICAgIGNhc2UgJyVqJzoKICAgICAgICB0cnkgewogICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7CiAgICAgICAgfSBjYXRjaCAoXykgewogICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJzsKICAgICAgICB9CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgcmV0dXJuIHg7CiAgICB9CiAgfSk7CiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHsKICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7CiAgICAgIHN0ciArPSAnICcgKyB4OwogICAgfSBlbHNlIHsKICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7CiAgICB9CiAgfQogIHJldHVybiBzdHI7Cn07CgoKLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC4KLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC4KLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC4KZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7CiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC4KICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7CiAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfTsKICB9CgogIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHsKICAgIHJldHVybiBmbjsKICB9CgogIHZhciB3YXJuZWQgPSBmYWxzZTsKICBmdW5jdGlvbiBkZXByZWNhdGVkKCkgewogICAgaWYgKCF3YXJuZWQpIHsKICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikgewogICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpOwogICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikgewogICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7CiAgICAgIH0KICAgICAgd2FybmVkID0gdHJ1ZTsKICAgIH0KICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogIH0KCiAgcmV0dXJuIGRlcHJlY2F0ZWQ7Cn07CgoKdmFyIGRlYnVncyA9IHt9Owp2YXIgZGVidWdFbnZpcm9uOwpleHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7CiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpCiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnOwogIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpOwogIGlmICghZGVidWdzW3NldF0pIHsKICAgIGlmIChuZXcgUmVnRXhwKCdcXGInICsgc2V0ICsgJ1xcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7CiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDsKICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHsKICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTsKICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTsKICAgICAgfTsKICAgIH0gZWxzZSB7CiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTsKICAgIH0KICB9CiAgcmV0dXJuIGRlYnVnc1tzZXRdOwp9OwoKCi8qKgogKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0CiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLgogKgogKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LgogKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LgogKi8KLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqLwpmdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykgewogIC8vIGRlZmF1bHQgb3B0aW9ucwogIHZhciBjdHggPSB7CiAgICBzZWVuOiBbXSwKICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yCiAgfTsKICAvLyBsZWdhY3kuLi4KICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07CiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTsKICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7CiAgICAvLyBsZWdhY3kuLi4KICAgIGN0eC5zaG93SGlkZGVuID0gb3B0czsKICB9IGVsc2UgaWYgKG9wdHMpIHsKICAgIC8vIGdvdCBhbiAib3B0aW9ucyIgb2JqZWN0CiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTsKICB9CiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9ucwogIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7CiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7CiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7CiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlOwogIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7CiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpOwp9CmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7CgoKLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzCmluc3BlY3QuY29sb3JzID0gewogICdib2xkJyA6IFsxLCAyMl0sCiAgJ2l0YWxpYycgOiBbMywgMjNdLAogICd1bmRlcmxpbmUnIDogWzQsIDI0XSwKICAnaW52ZXJzZScgOiBbNywgMjddLAogICd3aGl0ZScgOiBbMzcsIDM5XSwKICAnZ3JleScgOiBbOTAsIDM5XSwKICAnYmxhY2snIDogWzMwLCAzOV0sCiAgJ2JsdWUnIDogWzM0LCAzOV0sCiAgJ2N5YW4nIDogWzM2LCAzOV0sCiAgJ2dyZWVuJyA6IFszMiwgMzldLAogICdtYWdlbnRhJyA6IFszNSwgMzldLAogICdyZWQnIDogWzMxLCAzOV0sCiAgJ3llbGxvdycgOiBbMzMsIDM5XQp9OwoKLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlCmluc3BlY3Quc3R5bGVzID0gewogICdzcGVjaWFsJzogJ2N5YW4nLAogICdudW1iZXInOiAneWVsbG93JywKICAnYm9vbGVhbic6ICd5ZWxsb3cnLAogICd1bmRlZmluZWQnOiAnZ3JleScsCiAgJ251bGwnOiAnYm9sZCcsCiAgJ3N0cmluZyc6ICdncmVlbicsCiAgJ2RhdGUnOiAnbWFnZW50YScsCiAgLy8gIm5hbWUiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nCiAgJ3JlZ2V4cCc6ICdyZWQnCn07CgoKZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkgewogIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07CgogIGlmIChzdHlsZSkgewogICAgcmV0dXJuICdcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArCiAgICAgICAgICAgJ1x1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nOwogIH0gZWxzZSB7CiAgICByZXR1cm4gc3RyOwogIH0KfQoKCmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7CiAgcmV0dXJuIHN0cjsKfQoKCmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7CiAgdmFyIGhhc2ggPSB7fTsKCiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkgewogICAgaGFzaFt2YWxdID0gdHJ1ZTsKICB9KTsKCiAgcmV0dXJuIGhhc2g7Cn0KCgpmdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHsKICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuCiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0CiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmCiAgICAgIHZhbHVlICYmCiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiYKICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsCiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJgogICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay4KICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkgewogICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpOwogICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7CiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpOwogICAgfQogICAgcmV0dXJuIHJldDsKICB9CgogIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzCiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTsKICBpZiAocHJpbWl0aXZlKSB7CiAgICByZXR1cm4gcHJpbWl0aXZlOwogIH0KCiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LgogIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpOwogIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpOwoKICBpZiAoY3R4LnNob3dIaWRkZW4pIHsKICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7CiAgfQoKICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlCiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHgKICBpZiAoaXNFcnJvcih2YWx1ZSkKICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7CiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpOwogIH0KCiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLgogIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkgewogICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7CiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7CiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7CiAgICB9CiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7CiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7CiAgICB9CiAgICBpZiAoaXNEYXRlKHZhbHVlKSkgewogICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7CiAgICB9CiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHsKICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTsKICAgIH0KICB9CgogIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107CgogIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXkKICBpZiAoaXNBcnJheSh2YWx1ZSkpIHsKICAgIGFycmF5ID0gdHJ1ZTsKICAgIGJyYWNlcyA9IFsnWycsICddJ107CiAgfQoKICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnMKICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHsKICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7CiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJzsKICB9CgogIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzCiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkgewogICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7CiAgfQoKICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGUKICBpZiAoaXNEYXRlKHZhbHVlKSkgewogICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpOwogIH0KCiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvcgogIGlmIChpc0Vycm9yKHZhbHVlKSkgewogICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTsKICB9CgogIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkgewogICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07CiAgfQoKICBpZiAocmVjdXJzZVRpbWVzIDwgMCkgewogICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkgewogICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7CiAgICB9CiAgfQoKICBjdHguc2Vlbi5wdXNoKHZhbHVlKTsKCiAgdmFyIG91dHB1dDsKICBpZiAoYXJyYXkpIHsKICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpOwogIH0gZWxzZSB7CiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHsKICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpOwogICAgfSk7CiAgfQoKICBjdHguc2Vlbi5wb3AoKTsKCiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTsKfQoKCmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7CiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkKICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpOwogIGlmIChpc1N0cmluZyh2YWx1ZSkpIHsKICAgIHZhciBzaW1wbGUgPSAnXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL14ifCIkL2csICcnKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCAiXFwnIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcIi9nLCAnIicpICsgJ1wnJzsKICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTsKICB9CiAgaWYgKGlzTnVtYmVyKHZhbHVlKSkKICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7CiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpCiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTsKICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgIm9iamVjdCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLgogIGlmIChpc051bGwodmFsdWUpKQogICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTsKfQoKCmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7CiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJzsKfQoKCmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHsKICB2YXIgb3V0cHV0ID0gW107CiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHsKICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkgewogICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLAogICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7CiAgICB9IGVsc2UgewogICAgICBvdXRwdXQucHVzaCgnJyk7CiAgICB9CiAgfQogIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHsKICAgIGlmICgha2V5Lm1hdGNoKC9eXGQrJC8pKSB7CiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsCiAgICAgICAgICBrZXksIHRydWUpKTsKICAgIH0KICB9KTsKICByZXR1cm4gb3V0cHV0Owp9CgoKZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkgewogIHZhciBuYW1lLCBzdHIsIGRlc2M7CiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9OwogIGlmIChkZXNjLmdldCkgewogICAgaWYgKGRlc2Muc2V0KSB7CiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpOwogICAgfSBlbHNlIHsKICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTsKICAgIH0KICB9IGVsc2UgewogICAgaWYgKGRlc2Muc2V0KSB7CiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7CiAgICB9CiAgfQogIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHsKICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7CiAgfQogIGlmICghc3RyKSB7CiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHsKICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7CiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpOwogICAgICB9CiAgICAgIGlmIChzdHIuaW5kZXhPZignXG4nKSA+IC0xKSB7CiAgICAgICAgaWYgKGFycmF5KSB7CiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHsKICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lOwogICAgICAgICAgfSkuam9pbignXG4nKS5zdWJzdHIoMik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN0ciA9ICdcbicgKyBzdHIuc3BsaXQoJ1xuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHsKICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTsKICAgICAgICAgIH0pLmpvaW4oJ1xuJyk7CiAgICAgICAgfQogICAgICB9CiAgICB9IGVsc2UgewogICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7CiAgICB9CiAgfQogIGlmIChpc1VuZGVmaW5lZChuYW1lKSkgewogICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxkKyQvKSkgewogICAgICByZXR1cm4gc3RyOwogICAgfQogICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTsKICAgIGlmIChuYW1lLm1hdGNoKC9eIihbYS16QS1aX11bYS16QS1aXzAtOV0qKSIkLykpIHsKICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7CiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpOwogICAgfSBlbHNlIHsKICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCAiXFwnIikKICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwiL2csICciJykKICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF4ifCIkKS9nLCAiJyIpOwogICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpOwogICAgfQogIH0KCiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyOwp9CgoKZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHsKICB2YXIgbnVtTGluZXNFc3QgPSAwOwogIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikgewogICAgbnVtTGluZXNFc3QrKzsKICAgIGlmIChjdXIuaW5kZXhPZignXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrOwogICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXHUwMDFiXFtcZFxkP20vZywgJycpLmxlbmd0aCArIDE7CiAgfSwgMCk7CgogIGlmIChsZW5ndGggPiA2MCkgewogICAgcmV0dXJuIGJyYWNlc1swXSArCiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xuICcpICsKICAgICAgICAgICAnICcgKwogICAgICAgICAgIG91dHB1dC5qb2luKCcsXG4gICcpICsKICAgICAgICAgICAnICcgKwogICAgICAgICAgIGJyYWNlc1sxXTsKICB9CgogIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07Cn0KCgovLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmAKLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuCmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHsKICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7Cn0KZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTsKCmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nOwp9CmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuOwoKZnVuY3Rpb24gaXNOdWxsKGFyZykgewogIHJldHVybiBhcmcgPT09IG51bGw7Cn0KZXhwb3J0cy5pc051bGwgPSBpc051bGw7CgpmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHsKICByZXR1cm4gYXJnID09IG51bGw7Cn0KZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkOwoKZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInOwp9CmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjsKCmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJzsKfQpleHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7CgpmdW5jdGlvbiBpc1N5bWJvbChhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7Cn0KZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sOwoKZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwOwp9CmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDsKCmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7CiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nOwp9CmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDsKCmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7Cn0KZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0OwoKZnVuY3Rpb24gaXNEYXRlKGQpIHsKICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJzsKfQpleHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTsKCmZ1bmN0aW9uIGlzRXJyb3IoZSkgewogIHJldHVybiBpc09iamVjdChlKSAmJgogICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTsKfQpleHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yOwoKZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJzsKfQpleHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uOwoKZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2wKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7Cn0KZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlOwoKZXhwb3J0cy5pc0J1ZmZlciA9IF9kZXJlcV8oJy4vc3VwcG9ydC9pc0J1ZmZlcicpOwoKZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykgewogIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7Cn0KCgpmdW5jdGlvbiBwYWQobikgewogIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApOwp9CgoKdmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLAogICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddOwoKLy8gMjYgRmViIDE2OjE5OjM0CmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHsKICB2YXIgZCA9IG5ldyBEYXRlKCk7CiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksCiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSwKICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7CiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTsKfQoKCi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXAKZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHsKICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTsKfTsKCgovKioKICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLgogKgogKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lCiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZAogKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZQogKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXMKICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuCiAqCiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGUKICogICAgIHByb3RvdHlwZS4KICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uCiAqLwpleHBvcnRzLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTsKCmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7CiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdAogIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luOwoKICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7CiAgdmFyIGkgPSBrZXlzLmxlbmd0aDsKICB3aGlsZSAoaS0tKSB7CiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07CiAgfQogIHJldHVybiBvcmlnaW47Cn07CgpmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHsKICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7Cn0KCn0pLmNhbGwodGhpcyxfZGVyZXFfKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiID8gd2luZG93IDoge30pCn0seyIuL3N1cHBvcnQvaXNCdWZmZXIiOjEzOCwiX3Byb2Nlc3MiOjk5LCJpbmhlcml0cyI6MTM3fV0sMTQwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChnbG9iYWwsQnVmZmVyKXsKX2RlcmVxXz1mdW5jdGlvbiB0KGUsbixyKXtmdW5jdGlvbiBvKGEscyl7aWYoIW5bYV0pe2lmKCFlW2FdKXt2YXIgYz0iZnVuY3Rpb24iPT10eXBlb2YgX2RlcmVxXyYmX2RlcmVxXztpZighcyYmYylyZXR1cm4gYyhhLCEwKTtpZihpKXJldHVybiBpKGEsITApO3ZhciB1PW5ldyBFcnJvcigiQ2Fubm90IGZpbmQgbW9kdWxlICciK2ErIiciKTt0aHJvdyB1LmNvZGU9Ik1PRFVMRV9OT1RfRk9VTkQiLHV9dmFyIGY9blthXT17ZXhwb3J0czp7fX07ZVthXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbih0KXt2YXIgbj1lW2FdWzFdW3RdO3JldHVybiBvKG58fHQpfSxmLGYuZXhwb3J0cyx0LGUsbixyKX1yZXR1cm4gblthXS5leHBvcnRzfWZvcih2YXIgaT0iZnVuY3Rpb24iPT10eXBlb2YgX2RlcmVxXyYmX2RlcmVxXyxhPTA7YTxyLmxlbmd0aDthKyspbyhyW2FdKTtyZXR1cm4gb30oezE6W2Z1bmN0aW9uKHQsZSxuKXtlLmV4cG9ydHM9W3tjb25zdGFudDohMCxpbnB1dHM6W3tuYW1lOiJfb3duZXIiLHR5cGU6ImFkZHJlc3MifV0sbmFtZToibmFtZSIsb3V0cHV0czpbe25hbWU6Im9fbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMCxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJvd25lciIsb3V0cHV0czpbe25hbWU6IiIsdHlwZToiYWRkcmVzcyJ9XSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMCxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJjb250ZW50IixvdXRwdXRzOlt7bmFtZToiIix0eXBlOiJieXRlczMyIn1dLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiEwLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6ImFkZHIiLG91dHB1dHM6W3tuYW1lOiIiLHR5cGU6ImFkZHJlc3MifV0sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToicmVzZXJ2ZSIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMCxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJzdWJSZWdpc3RyYXIiLG91dHB1dHM6W3tuYW1lOiIiLHR5cGU6ImFkZHJlc3MifV0sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToiX25ld093bmVyIix0eXBlOiJhZGRyZXNzIn1dLG5hbWU6InRyYW5zZmVyIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn0se25hbWU6Il9yZWdpc3RyYXIiLHR5cGU6ImFkZHJlc3MifV0sbmFtZToic2V0U3ViUmVnaXN0cmFyIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbXSxuYW1lOiJSZWdpc3RyYXIiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToiX2EiLHR5cGU6ImFkZHJlc3MifSx7bmFtZToiX3ByaW1hcnkiLHR5cGU6ImJvb2wifV0sbmFtZToic2V0QWRkcmVzcyIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtuYW1lOiJfY29udGVudCIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJzZXRDb250ZW50IixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6ImRpc293biIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtpbmRleGVkOiExLG5hbWU6Il93aW5uZXIiLHR5cGU6ImFkZHJlc3MifV0sbmFtZToiQXVjdGlvbkVuZGVkIix0eXBlOiJldmVudCJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtpbmRleGVkOiExLG5hbWU6Il9iaWRkZXIiLHR5cGU6ImFkZHJlc3MifSx7aW5kZXhlZDohMSxuYW1lOiJfdmFsdWUiLHR5cGU6InVpbnQyNTYifV0sbmFtZToiTmV3QmlkIix0eXBlOiJldmVudCJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJuYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6IkNoYW5nZWQiLHR5cGU6ImV2ZW50In0se2Fub255bW91czohMSxpbnB1dHM6W3tpbmRleGVkOiEwLG5hbWU6Im5hbWUiLHR5cGU6ImJ5dGVzMzIifSx7aW5kZXhlZDohMCxuYW1lOiJhZGRyIix0eXBlOiJhZGRyZXNzIn1dLG5hbWU6IlByaW1hcnlDaGFuZ2VkIix0eXBlOiJldmVudCJ9XX0se31dLDI6W2Z1bmN0aW9uKHQsZSxuKXtlLmV4cG9ydHM9W3tjb25zdGFudDohMCxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJvd25lciIsb3V0cHV0czpbe25hbWU6IiIsdHlwZToiYWRkcmVzcyJ9XSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtuYW1lOiJfcmVmdW5kIix0eXBlOiJhZGRyZXNzIn1dLG5hbWU6ImRpc293biIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMCxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJhZGRyIixvdXRwdXRzOlt7bmFtZToiIix0eXBlOiJhZGRyZXNzIn1dLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6InJlc2VydmUiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToiX25ld093bmVyIix0eXBlOiJhZGRyZXNzIn1dLG5hbWU6InRyYW5zZmVyIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn0se25hbWU6Il9hIix0eXBlOiJhZGRyZXNzIn1dLG5hbWU6InNldEFkZHIiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7YW5vbnltb3VzOiExLGlucHV0czpbe2luZGV4ZWQ6ITAsbmFtZToibmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJDaGFuZ2VkIix0eXBlOiJldmVudCJ9XX0se31dLDM6W2Z1bmN0aW9uKHQsZSxuKXtlLmV4cG9ydHM9W3tjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJmcm9tIix0eXBlOiJieXRlczMyIn0se25hbWU6InRvIix0eXBlOiJhZGRyZXNzIn0se25hbWU6InZhbHVlIix0eXBlOiJ1aW50MjU2In1dLG5hbWU6InRyYW5zZmVyIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6ImZyb20iLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToidG8iLHR5cGU6ImFkZHJlc3MifSx7bmFtZToiaW5kaXJlY3RJZCIsdHlwZToiYnl0ZXMzMiJ9LHtuYW1lOiJ2YWx1ZSIsdHlwZToidWludDI1NiJ9XSxuYW1lOiJpY2FwVHJhbnNmZXIiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToidG8iLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToiZGVwb3NpdCIsb3V0cHV0czpbXSxwYXlhYmxlOiEwLHR5cGU6ImZ1bmN0aW9uIn0se2Fub255bW91czohMSxpbnB1dHM6W3tpbmRleGVkOiEwLG5hbWU6ImZyb20iLHR5cGU6ImFkZHJlc3MifSx7aW5kZXhlZDohMSxuYW1lOiJ2YWx1ZSIsdHlwZToidWludDI1NiJ9XSxuYW1lOiJBbm9ueW1vdXNEZXBvc2l0Iix0eXBlOiJldmVudCJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJmcm9tIix0eXBlOiJhZGRyZXNzIn0se2luZGV4ZWQ6ITAsbmFtZToidG8iLHR5cGU6ImJ5dGVzMzIifSx7aW5kZXhlZDohMSxuYW1lOiJ2YWx1ZSIsdHlwZToidWludDI1NiJ9XSxuYW1lOiJEZXBvc2l0Iix0eXBlOiJldmVudCJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJmcm9tIix0eXBlOiJieXRlczMyIn0se2luZGV4ZWQ6ITAsbmFtZToidG8iLHR5cGU6ImFkZHJlc3MifSx7aW5kZXhlZDohMSxuYW1lOiJ2YWx1ZSIsdHlwZToidWludDI1NiJ9XSxuYW1lOiJUcmFuc2ZlciIsdHlwZToiZXZlbnQifSx7YW5vbnltb3VzOiExLGlucHV0czpbe2luZGV4ZWQ6ITAsbmFtZToiZnJvbSIsdHlwZToiYnl0ZXMzMiJ9LHtpbmRleGVkOiEwLG5hbWU6InRvIix0eXBlOiJhZGRyZXNzIn0se2luZGV4ZWQ6ITEsbmFtZToiaW5kaXJlY3RJZCIsdHlwZToiYnl0ZXMzMiJ9LHtpbmRleGVkOiExLG5hbWU6InZhbHVlIix0eXBlOiJ1aW50MjU2In1dLG5hbWU6IkljYXBUcmFuc2ZlciIsdHlwZToiZXZlbnQifV19LHt9XSw0OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL3R5cGUiKSxpPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9ci5mb3JtYXRJbnB1dEludCx0aGlzLl9vdXRwdXRGb3JtYXR0ZXI9ci5mb3JtYXRPdXRwdXRBZGRyZXNzfTsoaS5wcm90b3R5cGU9bmV3IG8oe30pKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4hIXQubWF0Y2goL2FkZHJlc3MoXFsoWzAtOV0qKVxdKT8vKX0sZS5leHBvcnRzPWl9LHsiLi9mb3JtYXR0ZXJzIjo5LCIuL3R5cGUiOjE0fV0sNTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi90eXBlIiksaT1mdW5jdGlvbigpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPXIuZm9ybWF0SW5wdXRCb29sLHRoaXMuX291dHB1dEZvcm1hdHRlcj1yLmZvcm1hdE91dHB1dEJvb2x9OyhpLnByb3RvdHlwZT1uZXcgbyh7fSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUuaXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiEhdC5tYXRjaCgvXmJvb2woXFsoWzAtOV0qKVxdKSokLyl9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi90eXBlIjoxNH1dLDY6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vdHlwZSIpLGk9ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEZvcm1hdHRlcj1yLmZvcm1hdElucHV0Qnl0ZXMsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPXIuZm9ybWF0T3V0cHV0Qnl0ZXN9OyhpLnByb3RvdHlwZT1uZXcgbyh7fSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUuaXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiEhdC5tYXRjaCgvXmJ5dGVzKFswLTldezEsfSkoXFsoWzAtOV0qKVxdKSokLyl9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi90eXBlIjoxNH1dLDc6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vYWRkcmVzcyIpLGk9dCgiLi9ib29sIiksYT10KCIuL2ludCIpLHM9dCgiLi91aW50IiksYz10KCIuL2R5bmFtaWNieXRlcyIpLHU9dCgiLi9zdHJpbmciKSxmPXQoIi4vcmVhbCIpLGw9dCgiLi91cmVhbCIpLHA9dCgiLi9ieXRlcyIpLGg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5pc0R5bmFtaWNUeXBlKGUpfHx0LmlzRHluYW1pY0FycmF5KGUpfSxkPWZ1bmN0aW9uKHQpe3RoaXMuX3R5cGVzPXR9O2QucHJvdG90eXBlLl9yZXF1aXJlVHlwZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl90eXBlcy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaXNUeXBlKHQpfSlbMF07aWYoIWUpdGhyb3cgRXJyb3IoImludmFsaWQgc29saWRpdHkgdHlwZSE6ICIrdCk7cmV0dXJuIGV9LGQucHJvdG90eXBlLmVuY29kZVBhcmFtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlUGFyYW1zKFt0XSxbZV0pfSxkLnByb3RvdHlwZS5lbmNvZGVQYXJhbXM9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldFNvbGlkaXR5VHlwZXModCkscj1uLm1hcChmdW5jdGlvbihuLHIpe3JldHVybiBuLmVuY29kZShlW3JdLHRbcl0pfSksbz1uLnJlZHVjZShmdW5jdGlvbihlLHIsbyl7dmFyIGk9ci5zdGF0aWNQYXJ0TGVuZ3RoKHRbb10pLGE9MzIqTWF0aC5mbG9vcigoaSszMSkvMzIpO3JldHVybiBlKyhoKG5bb10sdFtvXSk/MzI6YSl9LDApO3JldHVybiB0aGlzLmVuY29kZU11bHRpV2l0aE9mZnNldCh0LG4scixvKX0sZC5wcm90b3R5cGUuZW5jb2RlTXVsdGlXaXRoT2Zmc2V0PWZ1bmN0aW9uKHQsZSxuLG8pe3ZhciBpPSIiLGE9dGhpcztyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHMsYyl7aWYoaChlW2NdLHRbY10pKXtpKz1yLmZvcm1hdElucHV0SW50KG8pLmVuY29kZSgpO3ZhciB1PWEuZW5jb2RlV2l0aE9mZnNldCh0W2NdLGVbY10sbltjXSxvKTtvKz11Lmxlbmd0aC8yfWVsc2UgaSs9YS5lbmNvZGVXaXRoT2Zmc2V0KHRbY10sZVtjXSxuW2NdLG8pfSksdC5mb3JFYWNoKGZ1bmN0aW9uKHIscyl7aWYoaChlW3NdLHRbc10pKXt2YXIgYz1hLmVuY29kZVdpdGhPZmZzZXQodFtzXSxlW3NdLG5bc10sbyk7bys9Yy5sZW5ndGgvMixpKz1jfX0pLGl9LGQucHJvdG90eXBlLmVuY29kZVdpdGhPZmZzZXQ9ZnVuY3Rpb24odCxlLG4sbyl7dmFyIGk9MSxhPTIscz0zLGM9ZS5pc0R5bmFtaWNBcnJheSh0KT9pOmUuaXNTdGF0aWNBcnJheSh0KT9hOnM7aWYoYyE9PXMpe3ZhciB1PWUubmVzdGVkTmFtZSh0KSxmPWUuc3RhdGljUGFydExlbmd0aCh1KSxsPWM9PT1pP25bMF06IiI7aWYoZS5pc0R5bmFtaWNBcnJheSh1KSlmb3IodmFyIHA9Yz09PWk/MjowLGg9MDtoPG4ubGVuZ3RoO2grKyljPT09aT9wKz0rbltoLTFdWzBdfHwwOmM9PT1hJiYocCs9KyhuW2gtMV18fFtdKVswXXx8MCksbCs9ci5mb3JtYXRJbnB1dEludChvK2gqZiszMipwKS5lbmNvZGUoKTtmb3IodmFyIGQ9Yz09PWk/bi5sZW5ndGgtMTpuLmxlbmd0aCxtPTA7bTxkO20rKyl7dmFyIHk9bC8yO2M9PT1pP2wrPXRoaXMuZW5jb2RlV2l0aE9mZnNldCh1LGUsblttKzFdLG8reSk6Yz09PWEmJihsKz10aGlzLmVuY29kZVdpdGhPZmZzZXQodSxlLG5bbV0sbyt5KSl9cmV0dXJuIGx9cmV0dXJuIG59LGQucHJvdG90eXBlLmRlY29kZVBhcmFtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZGVjb2RlUGFyYW1zKFt0XSxlKVswXX0sZC5wcm90b3R5cGUuZGVjb2RlUGFyYW1zPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRTb2xpZGl0eVR5cGVzKHQpLHI9dGhpcy5nZXRPZmZzZXRzKHQsbik7cmV0dXJuIG4ubWFwKGZ1bmN0aW9uKG4sbyl7cmV0dXJuIG4uZGVjb2RlKGUscltvXSx0W29dLG8pfSl9LGQucHJvdG90eXBlLmdldE9mZnNldHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5tYXAoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZS5zdGF0aWNQYXJ0TGVuZ3RoKHRbbl0pfSkscj0xO3I8bi5sZW5ndGg7cisrKW5bcl0rPW5bci0xXTtyZXR1cm4gbi5tYXAoZnVuY3Rpb24obixyKXtyZXR1cm4gbi1lW3JdLnN0YXRpY1BhcnRMZW5ndGgodFtyXSl9KX0sZC5wcm90b3R5cGUuZ2V0U29saWRpdHlUeXBlcz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5fcmVxdWlyZVR5cGUodCl9KX07dmFyIG09bmV3IGQoW25ldyBvLG5ldyBpLG5ldyBhLG5ldyBzLG5ldyBjLG5ldyBwLG5ldyB1LG5ldyBmLG5ldyBsXSk7ZS5leHBvcnRzPW19LHsiLi9hZGRyZXNzIjo0LCIuL2Jvb2wiOjUsIi4vYnl0ZXMiOjYsIi4vZHluYW1pY2J5dGVzIjo4LCIuL2Zvcm1hdHRlcnMiOjksIi4vaW50IjoxMCwiLi9yZWFsIjoxMiwiLi9zdHJpbmciOjEzLCIuL3VpbnQiOjE1LCIuL3VyZWFsIjoxNn1dLDg6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vdHlwZSIpLGk9ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEZvcm1hdHRlcj1yLmZvcm1hdElucHV0RHluYW1pY0J5dGVzLHRoaXMuX291dHB1dEZvcm1hdHRlcj1yLmZvcm1hdE91dHB1dER5bmFtaWNCeXRlc307KGkucHJvdG90eXBlPW5ldyBvKHt9KSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5pc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuISF0Lm1hdGNoKC9eYnl0ZXMoXFsoWzAtOV0qKVxdKSokLyl9LGkucHJvdG90eXBlLmlzRHluYW1pY1R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZS5leHBvcnRzPWl9LHsiLi9mb3JtYXR0ZXJzIjo5LCIuL3R5cGUiOjE0fV0sOTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoImJpZ251bWJlci5qcyIpLG89dCgiLi4vdXRpbHMvdXRpbHMiKSxpPXQoIi4uL3V0aWxzL2NvbmZpZyIpLGE9dCgiLi9wYXJhbSIpLHM9ZnVuY3Rpb24odCl7ci5jb25maWcoaS5FVEhfQklHTlVNQkVSX1JPVU5ESU5HX01PREUpO3ZhciBlPW8ucGFkTGVmdChvLnRvVHdvc0NvbXBsZW1lbnQodCkudG9TdHJpbmcoMTYpLDY0KTtyZXR1cm4gbmV3IGEoZSl9LGM9ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0aWNQYXJ0KCl8fCIwIjtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIjEiPT09bmV3IHIodC5zdWJzdHIoMCwxKSwxNikudG9TdHJpbmcoMikuc3Vic3RyKDAsMSl9KGUpP25ldyByKGUsMTYpLm1pbnVzKG5ldyByKCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmIiwxNikpLm1pbnVzKDEpOm5ldyByKGUsMTYpfSx1PWZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGljUGFydCgpfHwiMCI7cmV0dXJuIG5ldyByKGUsMTYpfTtlLmV4cG9ydHM9e2Zvcm1hdElucHV0SW50OnMsZm9ybWF0SW5wdXRCeXRlczpmdW5jdGlvbih0KXt2YXIgZT1vLnRvSGV4KHQpLnN1YnN0cigyKSxuPU1hdGguZmxvb3IoKGUubGVuZ3RoKzYzKS82NCk7cmV0dXJuIGU9by5wYWRSaWdodChlLDY0Km4pLG5ldyBhKGUpfSxmb3JtYXRJbnB1dER5bmFtaWNCeXRlczpmdW5jdGlvbih0KXt2YXIgZT1vLnRvSGV4KHQpLnN1YnN0cigyKSxuPWUubGVuZ3RoLzIscj1NYXRoLmZsb29yKChlLmxlbmd0aCs2MykvNjQpO3JldHVybiBlPW8ucGFkUmlnaHQoZSw2NCpyKSxuZXcgYShzKG4pLnZhbHVlK2UpfSxmb3JtYXRJbnB1dFN0cmluZzpmdW5jdGlvbih0KXt2YXIgZT1vLmZyb21VdGY4KHQpLnN1YnN0cigyKSxuPWUubGVuZ3RoLzIscj1NYXRoLmZsb29yKChlLmxlbmd0aCs2MykvNjQpO3JldHVybiBlPW8ucGFkUmlnaHQoZSw2NCpyKSxuZXcgYShzKG4pLnZhbHVlK2UpfSxmb3JtYXRJbnB1dEJvb2w6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBhKCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiKyh0PyIxIjoiMCIpKX0sZm9ybWF0SW5wdXRSZWFsOmZ1bmN0aW9uKHQpe3JldHVybiBzKG5ldyByKHQpLnRpbWVzKG5ldyByKDIpLnBvdygxMjgpKSl9LGZvcm1hdE91dHB1dEludDpjLGZvcm1hdE91dHB1dFVJbnQ6dSxmb3JtYXRPdXRwdXRSZWFsOmZ1bmN0aW9uKHQpe3JldHVybiBjKHQpLmRpdmlkZWRCeShuZXcgcigyKS5wb3coMTI4KSl9LGZvcm1hdE91dHB1dFVSZWFsOmZ1bmN0aW9uKHQpe3JldHVybiB1KHQpLmRpdmlkZWRCeShuZXcgcigyKS5wb3coMTI4KSl9LGZvcm1hdE91dHB1dEJvb2w6ZnVuY3Rpb24odCl7cmV0dXJuIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEiPT09dC5zdGF0aWNQYXJ0KCl9LGZvcm1hdE91dHB1dEJ5dGVzOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5tYXRjaCgvXmJ5dGVzKFswLTldKikvKSxyPXBhcnNlSW50KG5bMV0pO3JldHVybiIweCIrdC5zdGF0aWNQYXJ0KCkuc2xpY2UoMCwyKnIpfSxmb3JtYXRPdXRwdXREeW5hbWljQnl0ZXM6ZnVuY3Rpb24odCl7dmFyIGU9MipuZXcgcih0LmR5bmFtaWNQYXJ0KCkuc2xpY2UoMCw2NCksMTYpLnRvTnVtYmVyKCk7cmV0dXJuIjB4Iit0LmR5bmFtaWNQYXJ0KCkuc3Vic3RyKDY0LGUpfSxmb3JtYXRPdXRwdXRTdHJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9MipuZXcgcih0LmR5bmFtaWNQYXJ0KCkuc2xpY2UoMCw2NCksMTYpLnRvTnVtYmVyKCk7cmV0dXJuIG8udG9VdGY4KHQuZHluYW1pY1BhcnQoKS5zdWJzdHIoNjQsZSkpfSxmb3JtYXRPdXRwdXRBZGRyZXNzOmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGljUGFydCgpO3JldHVybiIweCIrZS5zbGljZShlLmxlbmd0aC00MCxlLmxlbmd0aCl9fX0seyIuLi91dGlscy9jb25maWciOjE4LCIuLi91dGlscy91dGlscyI6MjAsIi4vcGFyYW0iOjExLCJiaWdudW1iZXIuanMiOiJiaWdudW1iZXIuanMifV0sMTA6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vdHlwZSIpLGk9ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEZvcm1hdHRlcj1yLmZvcm1hdElucHV0SW50LHRoaXMuX291dHB1dEZvcm1hdHRlcj1yLmZvcm1hdE91dHB1dEludH07KGkucHJvdG90eXBlPW5ldyBvKHt9KSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5pc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuISF0Lm1hdGNoKC9eaW50KFswLTldKik/KFxbKFswLTldKilcXSkqJC8pfSxlLmV4cG9ydHM9aX0seyIuL2Zvcm1hdHRlcnMiOjksIi4vdHlwZSI6MTR9XSwxMTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL3V0aWxzL3V0aWxzIiksbz1mdW5jdGlvbih0LGUpe3RoaXMudmFsdWU9dHx8IiIsdGhpcy5vZmZzZXQ9ZX07by5wcm90b3R5cGUuZHluYW1pY1BhcnRMZW5ndGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5keW5hbWljUGFydCgpLmxlbmd0aC8yfSxvLnByb3RvdHlwZS53aXRoT2Zmc2V0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbyh0aGlzLnZhbHVlLHQpfSxvLnByb3RvdHlwZS5jb21iaW5lPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbyh0aGlzLnZhbHVlK3QudmFsdWUpfSxvLnByb3RvdHlwZS5pc0R5bmFtaWM9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5vZmZzZXR9LG8ucHJvdG90eXBlLm9mZnNldEFzQnl0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0R5bmFtaWMoKT9yLnBhZExlZnQoci50b1R3b3NDb21wbGVtZW50KHRoaXMub2Zmc2V0KS50b1N0cmluZygxNiksNjQpOiIifSxvLnByb3RvdHlwZS5zdGF0aWNQYXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNEeW5hbWljKCk/dGhpcy5vZmZzZXRBc0J5dGVzKCk6dGhpcy52YWx1ZX0sby5wcm90b3R5cGUuZHluYW1pY1BhcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0R5bmFtaWMoKT90aGlzLnZhbHVlOiIifSxvLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0aWNQYXJ0KCkrdGhpcy5keW5hbWljUGFydCgpfSxvLmVuY29kZUxpc3Q9ZnVuY3Rpb24odCl7dmFyIGU9MzIqdC5sZW5ndGgsbj10Lm1hcChmdW5jdGlvbih0KXtpZighdC5pc0R5bmFtaWMoKSlyZXR1cm4gdDt2YXIgbj1lO3JldHVybiBlKz10LmR5bmFtaWNQYXJ0TGVuZ3RoKCksdC53aXRoT2Zmc2V0KG4pfSk7cmV0dXJuIG4ucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZS5keW5hbWljUGFydCgpfSxuLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0K2Uuc3RhdGljUGFydCgpfSwiIikpfSxlLmV4cG9ydHM9b30seyIuLi91dGlscy91dGlscyI6MjB9XSwxMjpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi90eXBlIiksaT1mdW5jdGlvbigpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPXIuZm9ybWF0SW5wdXRSZWFsLHRoaXMuX291dHB1dEZvcm1hdHRlcj1yLmZvcm1hdE91dHB1dFJlYWx9OyhpLnByb3RvdHlwZT1uZXcgbyh7fSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUuaXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiEhdC5tYXRjaCgvcmVhbChbMC05XSopPyhcWyhbMC05XSopXF0pPy8pfSxlLmV4cG9ydHM9aX0seyIuL2Zvcm1hdHRlcnMiOjksIi4vdHlwZSI6MTR9XSwxMzpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi90eXBlIiksaT1mdW5jdGlvbigpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPXIuZm9ybWF0SW5wdXRTdHJpbmcsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPXIuZm9ybWF0T3V0cHV0U3RyaW5nfTsoaS5wcm90b3R5cGU9bmV3IG8oe30pKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4hIXQubWF0Y2goL15zdHJpbmcoXFsoWzAtOV0qKVxdKSokLyl9LGkucHJvdG90eXBlLmlzRHluYW1pY1R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZS5leHBvcnRzPWl9LHsiLi9mb3JtYXR0ZXJzIjo5LCIuL3R5cGUiOjE0fV0sMTQ6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vcGFyYW0iKSxpPWZ1bmN0aW9uKHQpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPXQuaW5wdXRGb3JtYXR0ZXIsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPXQub3V0cHV0Rm9ybWF0dGVyfTtpLnByb3RvdHlwZS5pc1R5cGU9ZnVuY3Rpb24odCl7dGhyb3cidGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyd3JpdHRlbiBmb3IgdHlwZSAiK3R9LGkucHJvdG90eXBlLnN0YXRpY1BhcnRMZW5ndGg9ZnVuY3Rpb24odCl7cmV0dXJuKHRoaXMubmVzdGVkVHlwZXModCl8fFsiWzFdIl0pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gcGFyc2VJbnQodC5zbGljZSgxLC0xKSwxMCl8fDF9KS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSwzMil9LGkucHJvdG90eXBlLmlzRHluYW1pY0FycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubmVzdGVkVHlwZXModCk7cmV0dXJuISFlJiYhZVtlLmxlbmd0aC0xXS5tYXRjaCgvWzAtOV17MSx9L2cpfSxpLnByb3RvdHlwZS5pc1N0YXRpY0FycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubmVzdGVkVHlwZXModCk7cmV0dXJuISFlJiYhIWVbZS5sZW5ndGgtMV0ubWF0Y2goL1swLTldezEsfS9nKX0saS5wcm90b3R5cGUuc3RhdGljQXJyYXlMZW5ndGg9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5uZXN0ZWRUeXBlcyh0KTtyZXR1cm4gZT9wYXJzZUludChlW2UubGVuZ3RoLTFdLm1hdGNoKC9bMC05XXsxLH0vZyl8fDEpOjF9LGkucHJvdG90eXBlLm5lc3RlZE5hbWU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5uZXN0ZWRUeXBlcyh0KTtyZXR1cm4gZT90LnN1YnN0cigwLHQubGVuZ3RoLWVbZS5sZW5ndGgtMV0ubGVuZ3RoKTp0fSxpLnByb3RvdHlwZS5pc0R5bmFtaWNUeXBlPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGkucHJvdG90eXBlLm5lc3RlZFR5cGVzPWZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hdGNoKC8oXFtbMC05XSpcXSkvZyl9LGkucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIHRoaXMuaXNEeW5hbWljQXJyYXkoZSk/ZnVuY3Rpb24oKXt2YXIgbz10Lmxlbmd0aCxpPW4ubmVzdGVkTmFtZShlKSxhPVtdO3JldHVybiBhLnB1c2goci5mb3JtYXRJbnB1dEludChvKS5lbmNvZGUoKSksdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2EucHVzaChuLmVuY29kZSh0LGkpKX0pLGF9KCk6dGhpcy5pc1N0YXRpY0FycmF5KGUpP2Z1bmN0aW9uKCl7Zm9yKHZhciByPW4uc3RhdGljQXJyYXlMZW5ndGgoZSksbz1uLm5lc3RlZE5hbWUoZSksaT1bXSxhPTA7YTxyO2ErKylpLnB1c2gobi5lbmNvZGUodFthXSxvKSk7cmV0dXJuIGl9KCk6dGhpcy5faW5wdXRGb3JtYXR0ZXIodCxlKS5lbmNvZGUoKX0saS5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzO2lmKHRoaXMuaXNEeW5hbWljQXJyYXkobikpcmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciBvPXBhcnNlSW50KCIweCIrdC5zdWJzdHIoMiplLDY0KSksaT1wYXJzZUludCgiMHgiK3Quc3Vic3RyKDIqbyw2NCkpLGE9byszMixzPXIubmVzdGVkTmFtZShuKSxjPXIuc3RhdGljUGFydExlbmd0aChzKSx1PTMyKk1hdGguZmxvb3IoKGMrMzEpLzMyKSxmPVtdLGw9MDtsPGkqdTtsKz11KWYucHVzaChyLmRlY29kZSh0LGErbCxzKSk7cmV0dXJuIGZ9KCk7aWYodGhpcy5pc1N0YXRpY0FycmF5KG4pKXJldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgbz1yLnN0YXRpY0FycmF5TGVuZ3RoKG4pLGk9ZSxhPXIubmVzdGVkTmFtZShuKSxzPXIuc3RhdGljUGFydExlbmd0aChhKSxjPTMyKk1hdGguZmxvb3IoKHMrMzEpLzMyKSx1PVtdLGY9MDtmPG8qYztmKz1jKXUucHVzaChyLmRlY29kZSh0LGkrZixhKSk7cmV0dXJuIHV9KCk7aWYodGhpcy5pc0R5bmFtaWNUeXBlKG4pKXJldHVybiBmdW5jdGlvbigpe3ZhciBpPXBhcnNlSW50KCIweCIrdC5zdWJzdHIoMiplLDY0KSksYT1wYXJzZUludCgiMHgiK3Quc3Vic3RyKDIqaSw2NCkpLHM9TWF0aC5mbG9vcigoYSszMSkvMzIpLGM9bmV3IG8odC5zdWJzdHIoMippLDY0KigxK3MpKSwwKTtyZXR1cm4gci5fb3V0cHV0Rm9ybWF0dGVyKGMsbil9KCk7dmFyIGk9dGhpcy5zdGF0aWNQYXJ0TGVuZ3RoKG4pLGE9bmV3IG8odC5zdWJzdHIoMiplLDIqaSkpO3JldHVybiB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIoYSxuKX0sZS5leHBvcnRzPWl9LHsiLi9mb3JtYXR0ZXJzIjo5LCIuL3BhcmFtIjoxMX1dLDE1OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL3R5cGUiKSxpPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9ci5mb3JtYXRJbnB1dEludCx0aGlzLl9vdXRwdXRGb3JtYXR0ZXI9ci5mb3JtYXRPdXRwdXRVSW50fTsoaS5wcm90b3R5cGU9bmV3IG8oe30pKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4hIXQubWF0Y2goL151aW50KFswLTldKik/KFxbKFswLTldKilcXSkqJC8pfSxlLmV4cG9ydHM9aX0seyIuL2Zvcm1hdHRlcnMiOjksIi4vdHlwZSI6MTR9XSwxNjpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi90eXBlIiksaT1mdW5jdGlvbigpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPXIuZm9ybWF0SW5wdXRSZWFsLHRoaXMuX291dHB1dEZvcm1hdHRlcj1yLmZvcm1hdE91dHB1dFVSZWFsfTsoaS5wcm90b3R5cGU9bmV3IG8oe30pKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4hIXQubWF0Y2goL151cmVhbChbMC05XSopPyhcWyhbMC05XSopXF0pKiQvKX0sZS5leHBvcnRzPWl9LHsiLi9mb3JtYXR0ZXJzIjo5LCIuL3R5cGUiOjE0fV0sMTc6W2Z1bmN0aW9uKHQsZSxuKXsidXNlIHN0cmljdCI7InVuZGVmaW5lZCI9PXR5cGVvZiBYTUxIdHRwUmVxdWVzdD9uLlhNTEh0dHBSZXF1ZXN0PXt9Om4uWE1MSHR0cFJlcXVlc3Q9WE1MSHR0cFJlcXVlc3R9LHt9XSwxODpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoImJpZ251bWJlci5qcyIpO2UuZXhwb3J0cz17RVRIX1BBRERJTkc6MzIsRVRIX1NJR05BVFVSRV9MRU5HVEg6NCxFVEhfVU5JVFM6WyJ3ZWkiLCJrd2VpIiwiTXdlaSIsIkd3ZWkiLCJzemFibyIsImZpbm5leSIsImZlbXRvZXRoZXIiLCJwaWNvZXRoZXIiLCJuYW5vZXRoZXIiLCJtaWNyb2V0aGVyIiwibWlsbGlldGhlciIsIm5hbm8iLCJtaWNybyIsIm1pbGxpIiwiZXRoZXIiLCJncmFuZCIsIk1ldGhlciIsIkdldGhlciIsIlRldGhlciIsIlBldGhlciIsIkVldGhlciIsIlpldGhlciIsIllldGhlciIsIk5ldGhlciIsIkRldGhlciIsIlZldGhlciIsIlVldGhlciJdLEVUSF9CSUdOVU1CRVJfUk9VTkRJTkdfTU9ERTp7Uk9VTkRJTkdfTU9ERTpyLlJPVU5EX0RPV059LEVUSF9QT0xMSU5HX1RJTUVPVVQ6NTAwLGRlZmF1bHRCbG9jazoibGF0ZXN0IixkZWZhdWx0QWNjb3VudDp2b2lkIDB9fSx7ImJpZ251bWJlci5qcyI6ImJpZ251bWJlci5qcyJ9XSwxOTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoImNyeXB0by1qcyIpLG89dCgiY3J5cHRvLWpzL3NoYTMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZSYmImhleCI9PT1lLmVuY29kaW5nJiYodC5sZW5ndGg+MiYmIjB4Ij09PXQuc3Vic3RyKDAsMikmJih0PXQuc3Vic3RyKDIpKSx0PXIuZW5jLkhleC5wYXJzZSh0KSksbyh0LHtvdXRwdXRMZW5ndGg6MjU2fSkudG9TdHJpbmcoKX19LHsiY3J5cHRvLWpzIjo1OCwiY3J5cHRvLWpzL3NoYTMiOjc5fV0sMjA6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCJiaWdudW1iZXIuanMiKSxvPXQoIi4vc2hhMy5qcyIpLGk9dCgidXRmOCIpLGE9e25vZXRoZXI6IjAiLHdlaToiMSIsa3dlaToiMTAwMCIsS3dlaToiMTAwMCIsYmFiYmFnZToiMTAwMCIsZmVtdG9ldGhlcjoiMTAwMCIsbXdlaToiMTAwMDAwMCIsTXdlaToiMTAwMDAwMCIsbG92ZWxhY2U6IjEwMDAwMDAiLHBpY29ldGhlcjoiMTAwMDAwMCIsZ3dlaToiMTAwMDAwMDAwMCIsR3dlaToiMTAwMDAwMDAwMCIsc2hhbm5vbjoiMTAwMDAwMDAwMCIsbmFub2V0aGVyOiIxMDAwMDAwMDAwIixuYW5vOiIxMDAwMDAwMDAwIixzemFibzoiMTAwMDAwMDAwMDAwMCIsbWljcm9ldGhlcjoiMTAwMDAwMDAwMDAwMCIsbWljcm86IjEwMDAwMDAwMDAwMDAiLGZpbm5leToiMTAwMDAwMDAwMDAwMDAwMCIsbWlsbGlldGhlcjoiMTAwMDAwMDAwMDAwMDAwMCIsbWlsbGk6IjEwMDAwMDAwMDAwMDAwMDAiLGV0aGVyOiIxMDAwMDAwMDAwMDAwMDAwMDAwIixrZXRoZXI6IjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAiLGdyYW5kOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwIixtZXRoZXI6IjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiLGdldGhlcjoiMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsdGV0aGVyOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIn0scz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIG5ldyBBcnJheShlLXQubGVuZ3RoKzEpLmpvaW4obnx8IjAiKSt0fSxjPWZ1bmN0aW9uKHQpe3Q9aS5lbmNvZGUodCk7Zm9yKHZhciBlPSIiLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dC5jaGFyQ29kZUF0KG4pO2lmKDA9PT1yKWJyZWFrO3ZhciBvPXIudG9TdHJpbmcoMTYpO2UrPW8ubGVuZ3RoPDI/IjAiK286b31yZXR1cm4iMHgiK2V9LHU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSIiLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dC5jaGFyQ29kZUF0KG4pLnRvU3RyaW5nKDE2KTtlKz1yLmxlbmd0aDwyPyIwIityOnJ9cmV0dXJuIjB4IitlfSxmPWZ1bmN0aW9uKHQpe3ZhciBlPWgodCksbj1lLnRvU3RyaW5nKDE2KTtyZXR1cm4gZS5sZXNzVGhhbigwKT8iLTB4IituLnN1YnN0cigxKToiMHgiK259LGw9ZnVuY3Rpb24odCl7aWYodih0KSlyZXR1cm4gZigrdCk7aWYoeSh0KSlyZXR1cm4gZih0KTtpZigib2JqZWN0Ij09dHlwZW9mIHQpcmV0dXJuIGMoSlNPTi5zdHJpbmdpZnkodCkpO2lmKGcodCkpe2lmKDA9PT10LmluZGV4T2YoIi0weCIpKXJldHVybiBmKHQpO2lmKDA9PT10LmluZGV4T2YoIjB4IikpcmV0dXJuIHQ7aWYoIWlzRmluaXRlKHQpKXJldHVybiB1KHQpfXJldHVybiBmKHQpfSxwPWZ1bmN0aW9uKHQpe3Q9dD90LnRvTG93ZXJDYXNlKCk6ImV0aGVyIjt2YXIgZT1hW3RdO2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IEVycm9yKCJUaGlzIHVuaXQgZG9lc24ndCBleGlzdHMsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzIitKU09OLnN0cmluZ2lmeShhLG51bGwsMikpO3JldHVybiBuZXcgcihlLDEwKX0saD1mdW5jdGlvbih0KXtyZXR1cm4gdD10fHwwLHkodCk/dDohZyh0KXx8MCE9PXQuaW5kZXhPZigiMHgiKSYmMCE9PXQuaW5kZXhPZigiLTB4Iik/bmV3IHIodC50b1N0cmluZygxMCksMTApOm5ldyByKHQucmVwbGFjZSgiMHgiLCIiKSwxNil9LGQ9ZnVuY3Rpb24odCl7cmV0dXJuL14weFswLTlhLWZdezQwfSQvaS50ZXN0KHQpfSxtPWZ1bmN0aW9uKHQpe3Q9dC5yZXBsYWNlKCIweCIsIiIpO2Zvcih2YXIgZT1vKHQudG9Mb3dlckNhc2UoKSksbj0wO248NDA7bisrKWlmKHBhcnNlSW50KGVbbl0sMTYpPjcmJnRbbl0udG9VcHBlckNhc2UoKSE9PXRbbl18fHBhcnNlSW50KGVbbl0sMTYpPD03JiZ0W25dLnRvTG93ZXJDYXNlKCkhPT10W25dKXJldHVybiExO3JldHVybiEwfSx5PWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygcnx8dCYmdC5jb25zdHJ1Y3RvciYmIkJpZ051bWJlciI9PT10LmNvbnN0cnVjdG9yLm5hbWV9LGc9ZnVuY3Rpb24odCl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0fHx0JiZ0LmNvbnN0cnVjdG9yJiYiU3RyaW5nIj09PXQuY29uc3RydWN0b3IubmFtZX0sdj1mdW5jdGlvbih0KXtyZXR1cm4iYm9vbGVhbiI9PXR5cGVvZiB0fTtlLmV4cG9ydHM9e3BhZExlZnQ6cyxwYWRSaWdodDpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHQrbmV3IEFycmF5KGUtdC5sZW5ndGgrMSkuam9pbihufHwiMCIpfSx0b0hleDpsLHRvRGVjaW1hbDpmdW5jdGlvbih0KXtyZXR1cm4gaCh0KS50b051bWJlcigpfSxmcm9tRGVjaW1hbDpmLHRvVXRmODpmdW5jdGlvbih0KXt2YXIgZT0iIixuPTAscj10Lmxlbmd0aDtmb3IoIjB4Ij09PXQuc3Vic3RyaW5nKDAsMikmJihuPTIpO248cjtuKz0yKXt2YXIgbz1wYXJzZUludCh0LnN1YnN0cihuLDIpLDE2KTtpZigwPT09bylicmVhaztlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pfXJldHVybiBpLmRlY29kZShlKX0sdG9Bc2NpaTpmdW5jdGlvbih0KXt2YXIgZT0iIixuPTAscj10Lmxlbmd0aDtmb3IoIjB4Ij09PXQuc3Vic3RyaW5nKDAsMikmJihuPTIpO248cjtuKz0yKXt2YXIgbz1wYXJzZUludCh0LnN1YnN0cihuLDIpLDE2KTtlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pfXJldHVybiBlfSxmcm9tVXRmODpjLGZyb21Bc2NpaTp1LHRyYW5zZm9ybVRvRnVsbE5hbWU6ZnVuY3Rpb24odCl7aWYoLTEhPT10Lm5hbWUuaW5kZXhPZigiKCIpKXJldHVybiB0Lm5hbWU7dmFyIGU9dC5pbnB1dHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGV9KS5qb2luKCk7cmV0dXJuIHQubmFtZSsiKCIrZSsiKSJ9LGV4dHJhY3REaXNwbGF5TmFtZTpmdW5jdGlvbih0KXt2YXIgZT10LmluZGV4T2YoIigiKTtyZXR1cm4tMSE9PWU/dC5zdWJzdHIoMCxlKTp0fSxleHRyYWN0VHlwZU5hbWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbmRleE9mKCIoIik7cmV0dXJuLTEhPT1lP3Quc3Vic3RyKGUrMSx0Lmxlbmd0aC0xLShlKzEpKS5yZXBsYWNlKCIgIiwiIik6IiJ9LHRvV2VpOmZ1bmN0aW9uKHQsZSl7dmFyIG49aCh0KS50aW1lcyhwKGUpKTtyZXR1cm4geSh0KT9uOm4udG9TdHJpbmcoMTApfSxmcm9tV2VpOmZ1bmN0aW9uKHQsZSl7dmFyIG49aCh0KS5kaXZpZGVkQnkocChlKSk7cmV0dXJuIHkodCk/bjpuLnRvU3RyaW5nKDEwKX0sdG9CaWdOdW1iZXI6aCx0b1R3b3NDb21wbGVtZW50OmZ1bmN0aW9uKHQpe3ZhciBlPWgodCkucm91bmQoKTtyZXR1cm4gZS5sZXNzVGhhbigwKT9uZXcgcigiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZiIsMTYpLnBsdXMoZSkucGx1cygxKTplfSx0b0FkZHJlc3M6ZnVuY3Rpb24odCl7cmV0dXJuIGQodCk/dDovXlswLTlhLWZdezQwfSQvLnRlc3QodCk/IjB4Iit0OiIweCIrcyhsKHQpLnN1YnN0cigyKSw0MCl9LGlzQmlnTnVtYmVyOnksaXNTdHJpY3RBZGRyZXNzOmQsaXNBZGRyZXNzOmZ1bmN0aW9uKHQpe3JldHVybiEhL14oMHgpP1swLTlhLWZdezQwfSQvaS50ZXN0KHQpJiYoISghL14oMHgpP1swLTlhLWZdezQwfSQvLnRlc3QodCkmJiEvXigweCk/WzAtOUEtRl17NDB9JC8udGVzdCh0KSl8fG0odCkpfSxpc0NoZWNrc3VtQWRkcmVzczptLHRvQ2hlY2tzdW1BZGRyZXNzOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIiI7dD10LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgiMHgiLCIiKTtmb3IodmFyIGU9byh0KSxuPSIweCIscj0wO3I8dC5sZW5ndGg7cisrKXBhcnNlSW50KGVbcl0sMTYpPjc/bis9dFtyXS50b1VwcGVyQ2FzZSgpOm4rPXRbcl07cmV0dXJuIG59LGlzRnVuY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHR9LGlzU3RyaW5nOmcsaXNPYmplY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10JiYhQXJyYXkuaXNBcnJheSh0KSYmIm9iamVjdCI9PXR5cGVvZiB0fSxpc0Jvb2xlYW46dixpc0FycmF5OmZ1bmN0aW9uKHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpfSxpc0pzb246ZnVuY3Rpb24odCl7dHJ5e3JldHVybiEhSlNPTi5wYXJzZSh0KX1jYXRjaCh0KXtyZXR1cm4hMX19LGlzQmxvb206ZnVuY3Rpb24odCl7cmV0dXJuISghL14oMHgpP1swLTlhLWZdezUxMn0kL2kudGVzdCh0KXx8IS9eKDB4KT9bMC05YS1mXXs1MTJ9JC8udGVzdCh0KSYmIS9eKDB4KT9bMC05QS1GXXs1MTJ9JC8udGVzdCh0KSl9LGlzVG9waWM6ZnVuY3Rpb24odCl7cmV0dXJuISghL14oMHgpP1swLTlhLWZdezY0fSQvaS50ZXN0KHQpfHwhL14oMHgpP1swLTlhLWZdezY0fSQvLnRlc3QodCkmJiEvXigweCk/WzAtOUEtRl17NjR9JC8udGVzdCh0KSl9fX0seyIuL3NoYTMuanMiOjE5LCJiaWdudW1iZXIuanMiOiJiaWdudW1iZXIuanMiLHV0Zjg6ODR9XSwyMTpbZnVuY3Rpb24odCxlLG4pe2UuZXhwb3J0cz17dmVyc2lvbjoiMC4yMC40In19LHt9XSwyMjpbZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dGhpcy5fcmVxdWVzdE1hbmFnZXI9bmV3IG8odCksdGhpcy5jdXJyZW50UHJvdmlkZXI9dCx0aGlzLmV0aD1uZXcgYSh0aGlzKSx0aGlzLmRiPW5ldyBzKHRoaXMpLHRoaXMuc2hoPW5ldyBjKHRoaXMpLHRoaXMubmV0PW5ldyB1KHRoaXMpLHRoaXMucGVyc29uYWw9bmV3IGYodGhpcyksdGhpcy5ieno9bmV3IGwodGhpcyksdGhpcy5zZXR0aW5ncz1uZXcgcCx0aGlzLnZlcnNpb249e2FwaTpoLnZlcnNpb259LHRoaXMucHJvdmlkZXJzPXtIdHRwUHJvdmlkZXI6YixJcGNQcm92aWRlcjpffSx0aGlzLl9leHRlbmQ9eSh0aGlzKSx0aGlzLl9leHRlbmQoe3Byb3BlcnRpZXM6eCgpfSl9dmFyIG89dCgiLi93ZWIzL3JlcXVlc3RtYW5hZ2VyIiksaT10KCIuL3dlYjMvaWJhbiIpLGE9dCgiLi93ZWIzL21ldGhvZHMvZXRoIikscz10KCIuL3dlYjMvbWV0aG9kcy9kYiIpLGM9dCgiLi93ZWIzL21ldGhvZHMvc2hoIiksdT10KCIuL3dlYjMvbWV0aG9kcy9uZXQiKSxmPXQoIi4vd2ViMy9tZXRob2RzL3BlcnNvbmFsIiksbD10KCIuL3dlYjMvbWV0aG9kcy9zd2FybSIpLHA9dCgiLi93ZWIzL3NldHRpbmdzIiksaD10KCIuL3ZlcnNpb24uanNvbiIpLGQ9dCgiLi91dGlscy91dGlscyIpLG09dCgiLi91dGlscy9zaGEzIikseT10KCIuL3dlYjMvZXh0ZW5kIiksZz10KCIuL3dlYjMvYmF0Y2giKSx2PXQoIi4vd2ViMy9wcm9wZXJ0eSIpLGI9dCgiLi93ZWIzL2h0dHBwcm92aWRlciIpLF89dCgiLi93ZWIzL2lwY3Byb3ZpZGVyIiksdz10KCJiaWdudW1iZXIuanMiKTtyLnByb3ZpZGVycz17SHR0cFByb3ZpZGVyOmIsSXBjUHJvdmlkZXI6X30sci5wcm90b3R5cGUuc2V0UHJvdmlkZXI9ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXIuc2V0UHJvdmlkZXIodCksdGhpcy5jdXJyZW50UHJvdmlkZXI9dH0sci5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXIucmVzZXQodCksdGhpcy5zZXR0aW5ncz1uZXcgcH0sci5wcm90b3R5cGUuQmlnTnVtYmVyPXcsci5wcm90b3R5cGUudG9IZXg9ZC50b0hleCxyLnByb3RvdHlwZS50b0FzY2lpPWQudG9Bc2NpaSxyLnByb3RvdHlwZS50b1V0Zjg9ZC50b1V0Zjgsci5wcm90b3R5cGUuZnJvbUFzY2lpPWQuZnJvbUFzY2lpLHIucHJvdG90eXBlLmZyb21VdGY4PWQuZnJvbVV0Zjgsci5wcm90b3R5cGUudG9EZWNpbWFsPWQudG9EZWNpbWFsLHIucHJvdG90eXBlLmZyb21EZWNpbWFsPWQuZnJvbURlY2ltYWwsci5wcm90b3R5cGUudG9CaWdOdW1iZXI9ZC50b0JpZ051bWJlcixyLnByb3RvdHlwZS50b1dlaT1kLnRvV2VpLHIucHJvdG90eXBlLmZyb21XZWk9ZC5mcm9tV2VpLHIucHJvdG90eXBlLmlzQWRkcmVzcz1kLmlzQWRkcmVzcyxyLnByb3RvdHlwZS5pc0NoZWNrc3VtQWRkcmVzcz1kLmlzQ2hlY2tzdW1BZGRyZXNzLHIucHJvdG90eXBlLnRvQ2hlY2tzdW1BZGRyZXNzPWQudG9DaGVja3N1bUFkZHJlc3Msci5wcm90b3R5cGUuaXNJQkFOPWQuaXNJQkFOLHIucHJvdG90eXBlLnBhZExlZnQ9ZC5wYWRMZWZ0LHIucHJvdG90eXBlLnBhZFJpZ2h0PWQucGFkUmlnaHQsci5wcm90b3R5cGUuc2hhMz1mdW5jdGlvbih0LGUpe3JldHVybiIweCIrbSh0LGUpfSxyLnByb3RvdHlwZS5mcm9tSUNBUD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkodCkuYWRkcmVzcygpfTt2YXIgeD1mdW5jdGlvbigpe3JldHVybltuZXcgdih7bmFtZToidmVyc2lvbi5ub2RlIixnZXR0ZXI6IndlYjNfY2xpZW50VmVyc2lvbiJ9KSxuZXcgdih7bmFtZToidmVyc2lvbi5uZXR3b3JrIixnZXR0ZXI6Im5ldF92ZXJzaW9uIixpbnB1dEZvcm1hdHRlcjpkLnRvRGVjaW1hbH0pLG5ldyB2KHtuYW1lOiJ2ZXJzaW9uLmV0aGVyZXVtIixnZXR0ZXI6ImV0aF9wcm90b2NvbFZlcnNpb24iLGlucHV0Rm9ybWF0dGVyOmQudG9EZWNpbWFsfSksbmV3IHYoe25hbWU6InZlcnNpb24ud2hpc3BlciIsZ2V0dGVyOiJzaGhfdmVyc2lvbiIsaW5wdXRGb3JtYXR0ZXI6ZC50b0RlY2ltYWx9KV19O3IucHJvdG90eXBlLmlzQ29ubmVjdGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3VycmVudFByb3ZpZGVyJiZ0aGlzLmN1cnJlbnRQcm92aWRlci5pc0Nvbm5lY3RlZCgpfSxyLnByb3RvdHlwZS5jcmVhdGVCYXRjaD1mdW5jdGlvbigpe3JldHVybiBuZXcgZyh0aGlzKX0sZS5leHBvcnRzPXJ9LHsiLi91dGlscy9zaGEzIjoxOSwiLi91dGlscy91dGlscyI6MjAsIi4vdmVyc2lvbi5qc29uIjoyMSwiLi93ZWIzL2JhdGNoIjoyNCwiLi93ZWIzL2V4dGVuZCI6MjgsIi4vd2ViMy9odHRwcHJvdmlkZXIiOjMyLCIuL3dlYjMvaWJhbiI6MzMsIi4vd2ViMy9pcGNwcm92aWRlciI6MzQsIi4vd2ViMy9tZXRob2RzL2RiIjozNywiLi93ZWIzL21ldGhvZHMvZXRoIjozOCwiLi93ZWIzL21ldGhvZHMvbmV0IjozOSwiLi93ZWIzL21ldGhvZHMvcGVyc29uYWwiOjQwLCIuL3dlYjMvbWV0aG9kcy9zaGgiOjQxLCIuL3dlYjMvbWV0aG9kcy9zd2FybSI6NDIsIi4vd2ViMy9wcm9wZXJ0eSI6NDUsIi4vd2ViMy9yZXF1ZXN0bWFuYWdlciI6NDYsIi4vd2ViMy9zZXR0aW5ncyI6NDcsImJpZ251bWJlci5qcyI6ImJpZ251bWJlci5qcyJ9XSwyMzpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL3V0aWxzL3NoYTMiKSxvPXQoIi4vZXZlbnQiKSxpPXQoIi4vZm9ybWF0dGVycyIpLGE9dCgiLi4vdXRpbHMvdXRpbHMiKSxzPXQoIi4vZmlsdGVyIiksYz10KCIuL21ldGhvZHMvd2F0Y2hlcyIpLHU9ZnVuY3Rpb24odCxlLG4pe3RoaXMuX3JlcXVlc3RNYW5hZ2VyPXQsdGhpcy5fanNvbj1lLHRoaXMuX2FkZHJlc3M9bn07dS5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKHQpe3Q9dHx8e307dmFyIGU9e307cmV0dXJuWyJmcm9tQmxvY2siLCJ0b0Jsb2NrIl0uZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT10W2VdfSkuZm9yRWFjaChmdW5jdGlvbihuKXtlW25dPWkuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcih0W25dKX0pLGUuYWRkcmVzcz10aGlzLl9hZGRyZXNzLGV9LHUucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbih0KXt0LmRhdGE9dC5kYXRhfHwiIix0LnRvcGljcz10LnRvcGljc3x8W107dmFyIGU9dC50b3BpY3NbMF0uc2xpY2UoMiksbj10aGlzLl9qc29uLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gZT09PXIoYS50cmFuc2Zvcm1Ub0Z1bGxOYW1lKHQpKX0pWzBdO2lmKCFuKXJldHVybiBjb25zb2xlLndhcm4oImNhbm5vdCBmaW5kIGV2ZW50IGZvciBsb2ciKSx0O3JldHVybiBuZXcgbyh0aGlzLl9yZXF1ZXN0TWFuYWdlcixuLHRoaXMuX2FkZHJlc3MpLmRlY29kZSh0KX0sdS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbih0LGUpe2EuaXNGdW5jdGlvbihhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aC0xXSkmJihlPWFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdLDE9PT1hcmd1bWVudHMubGVuZ3RoJiYodD1udWxsKSk7dmFyIG49dGhpcy5lbmNvZGUodCkscj10aGlzLmRlY29kZS5iaW5kKHRoaXMpO3JldHVybiBuZXcgcyhuLCJldGgiLHRoaXMuX3JlcXVlc3RNYW5hZ2VyLGMuZXRoKCkscixlKX0sdS5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmV4ZWN1dGUuYmluZCh0aGlzKTt0LmFsbEV2ZW50cz1lfSxlLmV4cG9ydHM9dX0seyIuLi91dGlscy9zaGEzIjoxOSwiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2V2ZW50IjoyNywiLi9maWx0ZXIiOjI5LCIuL2Zvcm1hdHRlcnMiOjMwLCIuL21ldGhvZHMvd2F0Y2hlcyI6NDN9XSwyNDpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vanNvbnJwYyIpLG89dCgiLi9lcnJvcnMiKSxpPWZ1bmN0aW9uKHQpe3RoaXMucmVxdWVzdE1hbmFnZXI9dC5fcmVxdWVzdE1hbmFnZXIsdGhpcy5yZXF1ZXN0cz1bXX07aS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3RoaXMucmVxdWVzdHMucHVzaCh0KX0saS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMucmVxdWVzdHM7dGhpcy5yZXF1ZXN0TWFuYWdlci5zZW5kQmF0Y2godCxmdW5jdGlvbihlLG4pe249bnx8W10sdC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gbltlXXx8e319KS5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7aWYodFtuXS5jYWxsYmFjayl7aWYoIXIuaXNWYWxpZFJlc3BvbnNlKGUpKXJldHVybiB0W25dLmNhbGxiYWNrKG8uSW52YWxpZFJlc3BvbnNlKGUpKTt0W25dLmNhbGxiYWNrKG51bGwsdFtuXS5mb3JtYXQ/dFtuXS5mb3JtYXQoZS5yZXN1bHQpOmUucmVzdWx0KX19KX0pfSxlLmV4cG9ydHM9aX0seyIuL2Vycm9ycyI6MjYsIi4vanNvbnJwYyI6MzV9XSwyNTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL3V0aWxzL3V0aWxzIiksbz10KCIuLi9zb2xpZGl0eS9jb2RlciIpLGk9dCgiLi9ldmVudCIpLGE9dCgiLi9mdW5jdGlvbiIpLHM9dCgiLi9hbGxldmVudHMiKSxjPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiJjb25zdHJ1Y3RvciI9PT10LnR5cGUmJnQuaW5wdXRzLmxlbmd0aD09PWUubGVuZ3RofSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlucHV0cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZX0pfSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBvLmVuY29kZVBhcmFtcyh0LGUpfSlbMF18fCIifSx1PWZ1bmN0aW9uKHQpe3QuYWJpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4iZnVuY3Rpb24iPT09dC50eXBlfSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgYSh0Ll9ldGgsZSx0LmFkZHJlc3MpfSkuZm9yRWFjaChmdW5jdGlvbihlKXtlLmF0dGFjaFRvQ29udHJhY3QodCl9KX0sZj1mdW5jdGlvbih0KXt2YXIgZT10LmFiaS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuImV2ZW50Ij09PXQudHlwZX0pO25ldyBzKHQuX2V0aC5fcmVxdWVzdE1hbmFnZXIsZSx0LmFkZHJlc3MpLmF0dGFjaFRvQ29udHJhY3QodCksZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBpKHQuX2V0aC5fcmVxdWVzdE1hbmFnZXIsZSx0LmFkZHJlc3MpfSkuZm9yRWFjaChmdW5jdGlvbihlKXtlLmF0dGFjaFRvQ29udHJhY3QodCl9KX0sbD1mdW5jdGlvbih0LGUpe3ZhciBuPTAscj0hMSxvPXQuX2V0aC5maWx0ZXIoImxhdGVzdCIsZnVuY3Rpb24oaSl7aWYoIWkmJiFyKWlmKCsrbj41MCl7aWYoby5zdG9wV2F0Y2hpbmcoZnVuY3Rpb24oKXt9KSxyPSEwLCFlKXRocm93IG5ldyBFcnJvcigiQ29udHJhY3QgdHJhbnNhY3Rpb24gY291bGRuJ3QgYmUgZm91bmQgYWZ0ZXIgNTAgYmxvY2tzIik7ZShuZXcgRXJyb3IoIkNvbnRyYWN0IHRyYW5zYWN0aW9uIGNvdWxkbid0IGJlIGZvdW5kIGFmdGVyIDUwIGJsb2NrcyIpKX1lbHNlIHQuX2V0aC5nZXRUcmFuc2FjdGlvblJlY2VpcHQodC50cmFuc2FjdGlvbkhhc2gsZnVuY3Rpb24obixpKXtpJiZpLmJsb2NrSGFzaCYmIXImJnQuX2V0aC5nZXRDb2RlKGkuY29udHJhY3RBZGRyZXNzLGZ1bmN0aW9uKG4sYSl7aWYoIXImJmEpaWYoby5zdG9wV2F0Y2hpbmcoZnVuY3Rpb24oKXt9KSxyPSEwLGEubGVuZ3RoPjMpdC5hZGRyZXNzPWkuY29udHJhY3RBZGRyZXNzLHUodCksZih0KSxlJiZlKG51bGwsdCk7ZWxzZXtpZighZSl0aHJvdyBuZXcgRXJyb3IoIlRoZSBjb250cmFjdCBjb2RlIGNvdWxkbid0IGJlIHN0b3JlZCwgcGxlYXNlIGNoZWNrIHlvdXIgZ2FzIGFtb3VudC4iKTtlKG5ldyBFcnJvcigiVGhlIGNvbnRyYWN0IGNvZGUgY291bGRuJ3QgYmUgc3RvcmVkLCBwbGVhc2UgY2hlY2sgeW91ciBnYXMgYW1vdW50LiIpKX19KX0pfSl9LHA9ZnVuY3Rpb24odCxlKXt0aGlzLmV0aD10LHRoaXMuYWJpPWUsdGhpcy5uZXc9ZnVuY3Rpb24oKXt2YXIgdCxuPW5ldyBoKHRoaXMuZXRoLHRoaXMuYWJpKSxvPXt9LGk9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtyLmlzRnVuY3Rpb24oaVtpLmxlbmd0aC0xXSkmJih0PWkucG9wKCkpO3ZhciBhPWlbaS5sZW5ndGgtMV07aWYoci5pc09iamVjdChhKSYmIXIuaXNBcnJheShhKSYmKG89aS5wb3AoKSksby52YWx1ZT4wKXtpZighKGUuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiJjb25zdHJ1Y3RvciI9PT10LnR5cGUmJnQuaW5wdXRzLmxlbmd0aD09PWkubGVuZ3RofSlbMF18fHt9KS5wYXlhYmxlKXRocm93IG5ldyBFcnJvcigiQ2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgY29uc3RydWN0b3IiKX12YXIgcz1jKHRoaXMuYWJpLGkpO2lmKG8uZGF0YSs9cyx0KXRoaXMuZXRoLnNlbmRUcmFuc2FjdGlvbihvLGZ1bmN0aW9uKGUscil7ZT90KGUpOihuLnRyYW5zYWN0aW9uSGFzaD1yLHQobnVsbCxuKSxsKG4sdCkpfSk7ZWxzZXt2YXIgdT10aGlzLmV0aC5zZW5kVHJhbnNhY3Rpb24obyk7bi50cmFuc2FjdGlvbkhhc2g9dSxsKG4pfXJldHVybiBufSx0aGlzLm5ldy5nZXREYXRhPXRoaXMuZ2V0RGF0YS5iaW5kKHRoaXMpfTtwLnByb3RvdHlwZS5hdD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBoKHRoaXMuZXRoLHRoaXMuYWJpLHQpO3JldHVybiB1KG4pLGYobiksZSYmZShudWxsLG4pLG59LHAucHJvdG90eXBlLmdldERhdGE9ZnVuY3Rpb24oKXt2YXIgdD17fSxlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksbj1lW2UubGVuZ3RoLTFdO3IuaXNPYmplY3QobikmJiFyLmlzQXJyYXkobikmJih0PWUucG9wKCkpO3ZhciBvPWModGhpcy5hYmksZSk7cmV0dXJuIHQuZGF0YSs9byx0LmRhdGF9O3ZhciBoPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLl9ldGg9dCx0aGlzLnRyYW5zYWN0aW9uSGFzaD1udWxsLHRoaXMuYWRkcmVzcz1uLHRoaXMuYWJpPWV9O2UuZXhwb3J0cz1wfSx7Ii4uL3NvbGlkaXR5L2NvZGVyIjo3LCIuLi91dGlscy91dGlscyI6MjAsIi4vYWxsZXZlbnRzIjoyMywiLi9ldmVudCI6MjcsIi4vZnVuY3Rpb24iOjMxfV0sMjY6W2Z1bmN0aW9uKHQsZSxuKXtlLmV4cG9ydHM9e0ludmFsaWROdW1iZXJPZlNvbGlkaXR5QXJnczpmdW5jdGlvbigpe3JldHVybiBuZXcgRXJyb3IoIkludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBTb2xpZGl0eSBmdW5jdGlvbiIpfSxJbnZhbGlkTnVtYmVyT2ZSUENQYXJhbXM6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEVycm9yKCJJbnZhbGlkIG51bWJlciBvZiBpbnB1dCBwYXJhbWV0ZXJzIHRvIFJQQyBtZXRob2QiKX0sSW52YWxpZENvbm5lY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBFcnJvcigiQ09OTkVDVElPTiBFUlJPUjogQ291bGRuJ3QgY29ubmVjdCB0byBub2RlICIrdCsiLiIpfSxJbnZhbGlkUHJvdmlkZXI6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEVycm9yKCJQcm92aWRlciBub3Qgc2V0IG9yIGludmFsaWQiKX0sSW52YWxpZFJlc3BvbnNlOmZ1bmN0aW9uKHQpe3ZhciBlPXQmJnQuZXJyb3ImJnQuZXJyb3IubWVzc2FnZT90LmVycm9yLm1lc3NhZ2U6IkludmFsaWQgSlNPTiBSUEMgcmVzcG9uc2U6ICIrSlNPTi5zdHJpbmdpZnkodCk7cmV0dXJuIG5ldyBFcnJvcihlKX0sQ29ubmVjdGlvblRpbWVvdXQ6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBFcnJvcigiQ09OTkVDVElPTiBUSU1FT1VUOiB0aW1lb3V0IG9mICIrdCsiIG1zIGFjaGl2ZWQiKX19fSx7fV0sMjc6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuLi91dGlscy91dGlscyIpLG89dCgiLi4vc29saWRpdHkvY29kZXIiKSxpPXQoIi4vZm9ybWF0dGVycyIpLGE9dCgiLi4vdXRpbHMvc2hhMyIpLHM9dCgiLi9maWx0ZXIiKSxjPXQoIi4vbWV0aG9kcy93YXRjaGVzIiksdT1mdW5jdGlvbih0LGUsbil7dGhpcy5fcmVxdWVzdE1hbmFnZXI9dCx0aGlzLl9wYXJhbXM9ZS5pbnB1dHMsdGhpcy5fbmFtZT1yLnRyYW5zZm9ybVRvRnVsbE5hbWUoZSksdGhpcy5fYWRkcmVzcz1uLHRoaXMuX2Fub255bW91cz1lLmFub255bW91c307dS5wcm90b3R5cGUudHlwZXM9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX3BhcmFtcy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaW5kZXhlZD09PXR9KS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZX0pfSx1LnByb3RvdHlwZS5kaXNwbGF5TmFtZT1mdW5jdGlvbigpe3JldHVybiByLmV4dHJhY3REaXNwbGF5TmFtZSh0aGlzLl9uYW1lKX0sdS5wcm90b3R5cGUudHlwZU5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gci5leHRyYWN0VHlwZU5hbWUodGhpcy5fbmFtZSl9LHUucHJvdG90eXBlLnNpZ25hdHVyZT1mdW5jdGlvbigpe3JldHVybiBhKHRoaXMuX25hbWUpfSx1LnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24odCxlKXt0PXR8fHt9LGU9ZXx8e307dmFyIG49e307WyJmcm9tQmxvY2siLCJ0b0Jsb2NrIl0uZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT1lW3RdfSkuZm9yRWFjaChmdW5jdGlvbih0KXtuW3RdPWkuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcihlW3RdKX0pLG4udG9waWNzPVtdLG4uYWRkcmVzcz10aGlzLl9hZGRyZXNzLHRoaXMuX2Fub255bW91c3x8bi50b3BpY3MucHVzaCgiMHgiK3RoaXMuc2lnbmF0dXJlKCkpO3ZhciBhPXRoaXMuX3BhcmFtcy5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuITA9PT10LmluZGV4ZWR9KS5tYXAoZnVuY3Rpb24oZSl7dmFyIG49dFtlLm5hbWVdO3JldHVybiB2b2lkIDA9PT1ufHxudWxsPT09bj9udWxsOnIuaXNBcnJheShuKT9uLm1hcChmdW5jdGlvbih0KXtyZXR1cm4iMHgiK28uZW5jb2RlUGFyYW0oZS50eXBlLHQpfSk6IjB4IitvLmVuY29kZVBhcmFtKGUudHlwZSxuKX0pO3JldHVybiBuLnRvcGljcz1uLnRvcGljcy5jb25jYXQoYSksbn0sdS5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKHQpe3QuZGF0YT10LmRhdGF8fCIiLHQudG9waWNzPXQudG9waWNzfHxbXTt2YXIgZT0odGhpcy5fYW5vbnltb3VzP3QudG9waWNzOnQudG9waWNzLnNsaWNlKDEpKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQuc2xpY2UoMil9KS5qb2luKCIiKSxuPW8uZGVjb2RlUGFyYW1zKHRoaXMudHlwZXMoITApLGUpLHI9dC5kYXRhLnNsaWNlKDIpLGE9by5kZWNvZGVQYXJhbXModGhpcy50eXBlcyghMSkscikscz1pLm91dHB1dExvZ0Zvcm1hdHRlcih0KTtyZXR1cm4gcy5ldmVudD10aGlzLmRpc3BsYXlOYW1lKCkscy5hZGRyZXNzPXQuYWRkcmVzcyxzLmFyZ3M9dGhpcy5fcGFyYW1zLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0W2UubmFtZV09ZS5pbmRleGVkP24uc2hpZnQoKTphLnNoaWZ0KCksdH0se30pLGRlbGV0ZSBzLmRhdGEsZGVsZXRlIHMudG9waWNzLHN9LHUucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24odCxlLG4pe3IuaXNGdW5jdGlvbihhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aC0xXSkmJihuPWFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdLDI9PT1hcmd1bWVudHMubGVuZ3RoJiYoZT1udWxsKSwxPT09YXJndW1lbnRzLmxlbmd0aCYmKGU9bnVsbCx0PXt9KSk7dmFyIG89dGhpcy5lbmNvZGUodCxlKSxpPXRoaXMuZGVjb2RlLmJpbmQodGhpcyk7cmV0dXJuIG5ldyBzKG8sImV0aCIsdGhpcy5fcmVxdWVzdE1hbmFnZXIsYy5ldGgoKSxpLG4pfSx1LnByb3RvdHlwZS5hdHRhY2hUb0NvbnRyYWN0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZXhlY3V0ZS5iaW5kKHRoaXMpLG49dGhpcy5kaXNwbGF5TmFtZSgpO3Rbbl18fCh0W25dPWUpLHRbbl1bdGhpcy50eXBlTmFtZSgpXT10aGlzLmV4ZWN1dGUuYmluZCh0aGlzLHQpfSxlLmV4cG9ydHM9dX0seyIuLi9zb2xpZGl0eS9jb2RlciI6NywiLi4vdXRpbHMvc2hhMyI6MTksIi4uL3V0aWxzL3V0aWxzIjoyMCwiLi9maWx0ZXIiOjI5LCIuL2Zvcm1hdHRlcnMiOjMwLCIuL21ldGhvZHMvd2F0Y2hlcyI6NDN9XSwyODpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi8uLi91dGlscy91dGlscyIpLGk9dCgiLi9tZXRob2QiKSxhPXQoIi4vcHJvcGVydHkiKTtlLmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oZSl7dmFyIG47ZS5wcm9wZXJ0eT8odFtlLnByb3BlcnR5XXx8KHRbZS5wcm9wZXJ0eV09e30pLG49dFtlLnByb3BlcnR5XSk6bj10LGUubWV0aG9kcyYmZS5tZXRob2RzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5hdHRhY2hUb09iamVjdChuKSxlLnNldFJlcXVlc3RNYW5hZ2VyKHQuX3JlcXVlc3RNYW5hZ2VyKX0pLGUucHJvcGVydGllcyYmZS5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5hdHRhY2hUb09iamVjdChuKSxlLnNldFJlcXVlc3RNYW5hZ2VyKHQuX3JlcXVlc3RNYW5hZ2VyKX0pfTtyZXR1cm4gZS5mb3JtYXR0ZXJzPXIsZS51dGlscz1vLGUuTWV0aG9kPWksZS5Qcm9wZXJ0eT1hLGV9fSx7Ii4vLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2Zvcm1hdHRlcnMiOjMwLCIuL21ldGhvZCI6MzYsIi4vcHJvcGVydHkiOjQ1fV0sMjk6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4uL3V0aWxzL3V0aWxzIiksaT1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09PXR8fHZvaWQgMD09PXQ/bnVsbDowPT09KHQ9U3RyaW5nKHQpKS5pbmRleE9mKCIweCIpP3Q6by5mcm9tVXRmOCh0KX0sYT1mdW5jdGlvbih0LGUpe28uaXNTdHJpbmcodC5vcHRpb25zKXx8dC5nZXQoZnVuY3Rpb24odCxuKXt0JiZlKHQpLG8uaXNBcnJheShuKSYmbi5mb3JFYWNoKGZ1bmN0aW9uKHQpe2UobnVsbCx0KX0pfSl9LHM9ZnVuY3Rpb24odCl7dC5yZXF1ZXN0TWFuYWdlci5zdGFydFBvbGxpbmcoe21ldGhvZDp0LmltcGxlbWVudGF0aW9uLnBvbGwuY2FsbCxwYXJhbXM6W3QuZmlsdGVySWRdfSx0LmZpbHRlcklkLGZ1bmN0aW9uKGUsbil7aWYoZSlyZXR1cm4gdC5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbih0KXt0KGUpfSk7by5pc0FycmF5KG4pJiZuLmZvckVhY2goZnVuY3Rpb24oZSl7ZT10LmZvcm1hdHRlcj90LmZvcm1hdHRlcihlKTplLHQuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24odCl7dChudWxsLGUpfSl9KX0sdC5zdG9wV2F0Y2hpbmcuYmluZCh0KSl9LGM9ZnVuY3Rpb24odCxlLG4sYyx1LGYsbCl7dmFyIHA9dGhpcyxoPXt9O3JldHVybiBjLmZvckVhY2goZnVuY3Rpb24odCl7dC5zZXRSZXF1ZXN0TWFuYWdlcihuKSx0LmF0dGFjaFRvT2JqZWN0KGgpfSksdGhpcy5yZXF1ZXN0TWFuYWdlcj1uLHRoaXMub3B0aW9ucz1mdW5jdGlvbih0LGUpe2lmKG8uaXNTdHJpbmcodCkpcmV0dXJuIHQ7c3dpdGNoKHQ9dHx8e30sZSl7Y2FzZSJldGgiOnJldHVybiB0LnRvcGljcz10LnRvcGljc3x8W10sdC50b3BpY3M9dC50b3BpY3MubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBvLmlzQXJyYXkodCk/dC5tYXAoaSk6aSh0KX0pLHt0b3BpY3M6dC50b3BpY3MsZnJvbTp0LmZyb20sdG86dC50byxhZGRyZXNzOnQuYWRkcmVzcyxmcm9tQmxvY2s6ci5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKHQuZnJvbUJsb2NrKSx0b0Jsb2NrOnIuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcih0LnRvQmxvY2spfTtjYXNlInNoaCI6cmV0dXJuIHR9fSh0LGUpLHRoaXMuaW1wbGVtZW50YXRpb249aCx0aGlzLmZpbHRlcklkPW51bGwsdGhpcy5jYWxsYmFja3M9W10sdGhpcy5nZXRMb2dzQ2FsbGJhY2tzPVtdLHRoaXMucG9sbEZpbHRlcnM9W10sdGhpcy5mb3JtYXR0ZXI9dSx0aGlzLmltcGxlbWVudGF0aW9uLm5ld0ZpbHRlcih0aGlzLm9wdGlvbnMsZnVuY3Rpb24odCxlKXtpZih0KXAuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24oZSl7ZSh0KX0pLCJmdW5jdGlvbiI9PXR5cGVvZiBsJiZsKHQpO2Vsc2UgaWYocC5maWx0ZXJJZD1lLHAuZ2V0TG9nc0NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3AuZ2V0KHQpfSkscC5nZXRMb2dzQ2FsbGJhY2tzPVtdLHAuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24odCl7YShwLHQpfSkscC5jYWxsYmFja3MubGVuZ3RoPjAmJnMocCksImZ1bmN0aW9uIj09dHlwZW9mIGYpcmV0dXJuIHAud2F0Y2goZil9KSx0aGlzfTtjLnByb3RvdHlwZS53YXRjaD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jYWxsYmFja3MucHVzaCh0KSx0aGlzLmZpbHRlcklkJiYoYSh0aGlzLHQpLHModGhpcykpLHRoaXN9LGMucHJvdG90eXBlLnN0b3BXYXRjaGluZz1mdW5jdGlvbih0KXtpZih0aGlzLnJlcXVlc3RNYW5hZ2VyLnN0b3BQb2xsaW5nKHRoaXMuZmlsdGVySWQpLHRoaXMuY2FsbGJhY2tzPVtdLCF0KXJldHVybiB0aGlzLmltcGxlbWVudGF0aW9uLnVuaW5zdGFsbEZpbHRlcih0aGlzLmZpbHRlcklkKTt0aGlzLmltcGxlbWVudGF0aW9uLnVuaW5zdGFsbEZpbHRlcih0aGlzLmZpbHRlcklkLHQpfSxjLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcztpZighby5pc0Z1bmN0aW9uKHQpKXtpZihudWxsPT09dGhpcy5maWx0ZXJJZCl0aHJvdyBuZXcgRXJyb3IoIkZpbHRlciBJRCBFcnJvcjogZmlsdGVyKCkuZ2V0KCkgY2FuJ3QgYmUgY2hhaW5lZCBzeW5jaHJvbm91cywgcGxlYXNlIHByb3ZpZGUgYSBjYWxsYmFjayBmb3IgdGhlIGdldCgpIG1ldGhvZC4iKTtyZXR1cm4gdGhpcy5pbXBsZW1lbnRhdGlvbi5nZXRMb2dzKHRoaXMuZmlsdGVySWQpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5mb3JtYXR0ZXI/ZS5mb3JtYXR0ZXIodCk6dH0pfXJldHVybiBudWxsPT09dGhpcy5maWx0ZXJJZD90aGlzLmdldExvZ3NDYWxsYmFja3MucHVzaCh0KTp0aGlzLmltcGxlbWVudGF0aW9uLmdldExvZ3ModGhpcy5maWx0ZXJJZCxmdW5jdGlvbihuLHIpe24/dChuKTp0KG51bGwsci5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGUuZm9ybWF0dGVyP2UuZm9ybWF0dGVyKHQpOnR9KSl9KSx0aGlzfSxlLmV4cG9ydHM9Y30seyIuLi91dGlscy91dGlscyI6MjAsIi4vZm9ybWF0dGVycyI6MzB9XSwzMDpbZnVuY3Rpb24odCxlLG4peyJ1c2Ugc3RyaWN0Ijt2YXIgcj10KCIuLi91dGlscy91dGlscyIpLG89dCgiLi4vdXRpbHMvY29uZmlnIiksaT10KCIuL2liYW4iKSxhPWZ1bmN0aW9uKHQpe2lmKHZvaWQgMCE9PXQpcmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiJsYXRlc3QiPT09dHx8InBlbmRpbmciPT09dHx8ImVhcmxpZXN0Ij09PXR9KHQpP3Q6ci50b0hleCh0KX0scz1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbCE9PXQuYmxvY2tOdW1iZXImJih0LmJsb2NrTnVtYmVyPXIudG9EZWNpbWFsKHQuYmxvY2tOdW1iZXIpKSxudWxsIT09dC50cmFuc2FjdGlvbkluZGV4JiYodC50cmFuc2FjdGlvbkluZGV4PXIudG9EZWNpbWFsKHQudHJhbnNhY3Rpb25JbmRleCkpLHQubm9uY2U9ci50b0RlY2ltYWwodC5ub25jZSksdC5nYXM9ci50b0RlY2ltYWwodC5nYXMpLHQuZ2FzUHJpY2U9ci50b0JpZ051bWJlcih0Lmdhc1ByaWNlKSx0LnZhbHVlPXIudG9CaWdOdW1iZXIodC52YWx1ZSksdH0sYz1mdW5jdGlvbih0KXtyZXR1cm4gdC5ibG9ja051bWJlciYmKHQuYmxvY2tOdW1iZXI9ci50b0RlY2ltYWwodC5ibG9ja051bWJlcikpLHQudHJhbnNhY3Rpb25JbmRleCYmKHQudHJhbnNhY3Rpb25JbmRleD1yLnRvRGVjaW1hbCh0LnRyYW5zYWN0aW9uSW5kZXgpKSx0LmxvZ0luZGV4JiYodC5sb2dJbmRleD1yLnRvRGVjaW1hbCh0LmxvZ0luZGV4KSksdH0sdT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgaSh0KTtpZihlLmlzVmFsaWQoKSYmZS5pc0RpcmVjdCgpKXJldHVybiIweCIrZS5hZGRyZXNzKCk7aWYoci5pc1N0cmljdEFkZHJlc3ModCkpcmV0dXJuIHQ7aWYoci5pc0FkZHJlc3ModCkpcmV0dXJuIjB4Iit0O3Rocm93IG5ldyBFcnJvcigiaW52YWxpZCBhZGRyZXNzIil9O2UuZXhwb3J0cz17aW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMD09PXQ/by5kZWZhdWx0QmxvY2s6YSh0KX0saW5wdXRCbG9ja051bWJlckZvcm1hdHRlcjphLGlucHV0Q2FsbEZvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdC5mcm9tPXQuZnJvbXx8by5kZWZhdWx0QWNjb3VudCx0LmZyb20mJih0LmZyb209dSh0LmZyb20pKSx0LnRvJiYodC50bz11KHQudG8pKSxbImdhc1ByaWNlIiwiZ2FzIiwidmFsdWUiLCJub25jZSJdLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gdm9pZCAwIT09dFtlXX0pLmZvckVhY2goZnVuY3Rpb24oZSl7dFtlXT1yLmZyb21EZWNpbWFsKHRbZV0pfSksdH0saW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdC5mcm9tPXQuZnJvbXx8by5kZWZhdWx0QWNjb3VudCx0LmZyb209dSh0LmZyb20pLHQudG8mJih0LnRvPXUodC50bykpLFsiZ2FzUHJpY2UiLCJnYXMiLCJ2YWx1ZSIsIm5vbmNlIl0uZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT10W2VdfSkuZm9yRWFjaChmdW5jdGlvbihlKXt0W2VdPXIuZnJvbURlY2ltYWwodFtlXSl9KSx0fSxpbnB1dEFkZHJlc3NGb3JtYXR0ZXI6dSxpbnB1dFBvc3RGb3JtYXR0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHQudHRsPXIuZnJvbURlY2ltYWwodC50dGwpLHQud29ya1RvUHJvdmU9ci5mcm9tRGVjaW1hbCh0LndvcmtUb1Byb3ZlKSx0LnByaW9yaXR5PXIuZnJvbURlY2ltYWwodC5wcmlvcml0eSksci5pc0FycmF5KHQudG9waWNzKXx8KHQudG9waWNzPXQudG9waWNzP1t0LnRvcGljc106W10pLHQudG9waWNzPXQudG9waWNzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQuaW5kZXhPZigiMHgiKT90OnIuZnJvbVV0ZjgodCl9KSx0fSxvdXRwdXRCaWdOdW1iZXJGb3JtYXR0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHIudG9CaWdOdW1iZXIodCl9LG91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyOnMsb3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT09dC5ibG9ja051bWJlciYmKHQuYmxvY2tOdW1iZXI9ci50b0RlY2ltYWwodC5ibG9ja051bWJlcikpLG51bGwhPT10LnRyYW5zYWN0aW9uSW5kZXgmJih0LnRyYW5zYWN0aW9uSW5kZXg9ci50b0RlY2ltYWwodC50cmFuc2FjdGlvbkluZGV4KSksdC5jdW11bGF0aXZlR2FzVXNlZD1yLnRvRGVjaW1hbCh0LmN1bXVsYXRpdmVHYXNVc2VkKSx0Lmdhc1VzZWQ9ci50b0RlY2ltYWwodC5nYXNVc2VkKSxyLmlzQXJyYXkodC5sb2dzKSYmKHQubG9ncz10LmxvZ3MubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBjKHQpfSkpLHR9LG91dHB1dEJsb2NrRm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3JldHVybiB0Lmdhc0xpbWl0PXIudG9EZWNpbWFsKHQuZ2FzTGltaXQpLHQuZ2FzVXNlZD1yLnRvRGVjaW1hbCh0Lmdhc1VzZWQpLHQuc2l6ZT1yLnRvRGVjaW1hbCh0LnNpemUpLHQudGltZXN0YW1wPXIudG9EZWNpbWFsKHQudGltZXN0YW1wKSxudWxsIT09dC5udW1iZXImJih0Lm51bWJlcj1yLnRvRGVjaW1hbCh0Lm51bWJlcikpLHQuZGlmZmljdWx0eT1yLnRvQmlnTnVtYmVyKHQuZGlmZmljdWx0eSksdC50b3RhbERpZmZpY3VsdHk9ci50b0JpZ051bWJlcih0LnRvdGFsRGlmZmljdWx0eSksci5pc0FycmF5KHQudHJhbnNhY3Rpb25zKSYmdC50cmFuc2FjdGlvbnMuZm9yRWFjaChmdW5jdGlvbih0KXtpZighci5pc1N0cmluZyh0KSlyZXR1cm4gcyh0KX0pLHR9LG91dHB1dExvZ0Zvcm1hdHRlcjpjLG91dHB1dFBvc3RGb3JtYXR0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZXhwaXJ5PXIudG9EZWNpbWFsKHQuZXhwaXJ5KSx0LnNlbnQ9ci50b0RlY2ltYWwodC5zZW50KSx0LnR0bD1yLnRvRGVjaW1hbCh0LnR0bCksdC53b3JrUHJvdmVkPXIudG9EZWNpbWFsKHQud29ya1Byb3ZlZCksdC50b3BpY3N8fCh0LnRvcGljcz1bXSksdC50b3BpY3M9dC50b3BpY3MubWFwKGZ1bmN0aW9uKHQpe3JldHVybiByLnRvQXNjaWkodCl9KSx0fSxvdXRwdXRTeW5jaW5nRm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3JldHVybiB0Pyh0LnN0YXJ0aW5nQmxvY2s9ci50b0RlY2ltYWwodC5zdGFydGluZ0Jsb2NrKSx0LmN1cnJlbnRCbG9jaz1yLnRvRGVjaW1hbCh0LmN1cnJlbnRCbG9jayksdC5oaWdoZXN0QmxvY2s9ci50b0RlY2ltYWwodC5oaWdoZXN0QmxvY2spLHQua25vd25TdGF0ZXMmJih0Lmtub3duU3RhdGVzPXIudG9EZWNpbWFsKHQua25vd25TdGF0ZXMpLHQucHVsbGVkU3RhdGVzPXIudG9EZWNpbWFsKHQucHVsbGVkU3RhdGVzKSksdCk6dH19fSx7Ii4uL3V0aWxzL2NvbmZpZyI6MTgsIi4uL3V0aWxzL3V0aWxzIjoyMCwiLi9pYmFuIjozM31dLDMxOltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi4vc29saWRpdHkvY29kZXIiKSxvPXQoIi4uL3V0aWxzL3V0aWxzIiksaT10KCIuL2Vycm9ycyIpLGE9dCgiLi9mb3JtYXR0ZXJzIikscz10KCIuLi91dGlscy9zaGEzIiksYz1mdW5jdGlvbih0LGUsbil7dGhpcy5fZXRoPXQsdGhpcy5faW5wdXRUeXBlcz1lLmlucHV0cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZX0pLHRoaXMuX291dHB1dFR5cGVzPWUub3V0cHV0cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZX0pLHRoaXMuX2NvbnN0YW50PWUuY29uc3RhbnQsdGhpcy5fcGF5YWJsZT1lLnBheWFibGUsdGhpcy5fbmFtZT1vLnRyYW5zZm9ybVRvRnVsbE5hbWUoZSksdGhpcy5fYWRkcmVzcz1ufTtjLnByb3RvdHlwZS5leHRyYWN0Q2FsbGJhY2s9ZnVuY3Rpb24odCl7aWYoby5pc0Z1bmN0aW9uKHRbdC5sZW5ndGgtMV0pKXJldHVybiB0LnBvcCgpfSxjLnByb3RvdHlwZS5leHRyYWN0RGVmYXVsdEJsb2NrPWZ1bmN0aW9uKHQpe2lmKHQubGVuZ3RoPnRoaXMuX2lucHV0VHlwZXMubGVuZ3RoJiYhby5pc09iamVjdCh0W3QubGVuZ3RoLTFdKSlyZXR1cm4gYS5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcih0LnBvcCgpKX0sYy5wcm90b3R5cGUudmFsaWRhdGVBcmdzPWZ1bmN0aW9uKHQpe2lmKHQuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiEoITA9PT1vLmlzT2JqZWN0KHQpJiYhMT09PW8uaXNBcnJheSh0KSYmITE9PT1vLmlzQmlnTnVtYmVyKHQpKX0pLmxlbmd0aCE9PXRoaXMuX2lucHV0VHlwZXMubGVuZ3RoKXRocm93IGkuSW52YWxpZE51bWJlck9mU29saWRpdHlBcmdzKCl9LGMucHJvdG90eXBlLnRvUGF5bG9hZD1mdW5jdGlvbih0KXt2YXIgZT17fTtyZXR1cm4gdC5sZW5ndGg+dGhpcy5faW5wdXRUeXBlcy5sZW5ndGgmJm8uaXNPYmplY3QodFt0Lmxlbmd0aC0xXSkmJihlPXRbdC5sZW5ndGgtMV0pLHRoaXMudmFsaWRhdGVBcmdzKHQpLGUudG89dGhpcy5fYWRkcmVzcyxlLmRhdGE9IjB4Iit0aGlzLnNpZ25hdHVyZSgpK3IuZW5jb2RlUGFyYW1zKHRoaXMuX2lucHV0VHlwZXMsdCksZX0sYy5wcm90b3R5cGUuc2lnbmF0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIHModGhpcy5fbmFtZSkuc2xpY2UoMCw4KX0sYy5wcm90b3R5cGUudW5wYWNrT3V0cHV0PWZ1bmN0aW9uKHQpe2lmKHQpe3Q9dC5sZW5ndGg+PTI/dC5zbGljZSgyKTp0O3ZhciBlPXIuZGVjb2RlUGFyYW1zKHRoaXMuX291dHB1dFR5cGVzLHQpO3JldHVybiAxPT09ZS5sZW5ndGg/ZVswXTplfX0sYy5wcm90b3R5cGUuY2FsbD1mdW5jdGlvbigpe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10fSksZT10aGlzLmV4dHJhY3RDYWxsYmFjayh0KSxuPXRoaXMuZXh0cmFjdERlZmF1bHRCbG9jayh0KSxyPXRoaXMudG9QYXlsb2FkKHQpO2lmKCFlKXt2YXIgbz10aGlzLl9ldGguY2FsbChyLG4pO3JldHVybiB0aGlzLnVucGFja091dHB1dChvKX12YXIgaT10aGlzO3RoaXMuX2V0aC5jYWxsKHIsbixmdW5jdGlvbih0LG4pe2lmKHQpcmV0dXJuIGUodCxudWxsKTt2YXIgcj1udWxsO3RyeXtyPWkudW5wYWNrT3V0cHV0KG4pfWNhdGNoKGUpe3Q9ZX1lKHQscil9KX0sYy5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uPWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9KSxlPXRoaXMuZXh0cmFjdENhbGxiYWNrKHQpLG49dGhpcy50b1BheWxvYWQodCk7aWYobi52YWx1ZT4wJiYhdGhpcy5fcGF5YWJsZSl0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZ1bmN0aW9uIik7aWYoIWUpcmV0dXJuIHRoaXMuX2V0aC5zZW5kVHJhbnNhY3Rpb24obik7dGhpcy5fZXRoLnNlbmRUcmFuc2FjdGlvbihuLGUpfSxjLnByb3RvdHlwZS5lc3RpbWF0ZUdhcz1mdW5jdGlvbigpe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksZT10aGlzLmV4dHJhY3RDYWxsYmFjayh0KSxuPXRoaXMudG9QYXlsb2FkKHQpO2lmKCFlKXJldHVybiB0aGlzLl9ldGguZXN0aW1hdGVHYXMobik7dGhpcy5fZXRoLmVzdGltYXRlR2FzKG4sZSl9LGMucHJvdG90eXBlLmdldERhdGE9ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO3JldHVybiB0aGlzLnRvUGF5bG9hZCh0KS5kYXRhfSxjLnByb3RvdHlwZS5kaXNwbGF5TmFtZT1mdW5jdGlvbigpe3JldHVybiBvLmV4dHJhY3REaXNwbGF5TmFtZSh0aGlzLl9uYW1lKX0sYy5wcm90b3R5cGUudHlwZU5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gby5leHRyYWN0VHlwZU5hbWUodGhpcy5fbmFtZSl9LGMucHJvdG90eXBlLnJlcXVlc3Q9ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLGU9dGhpcy5leHRyYWN0Q2FsbGJhY2sodCksbj10aGlzLnRvUGF5bG9hZCh0KSxyPXRoaXMudW5wYWNrT3V0cHV0LmJpbmQodGhpcyk7cmV0dXJue21ldGhvZDp0aGlzLl9jb25zdGFudD8iZXRoX2NhbGwiOiJldGhfc2VuZFRyYW5zYWN0aW9uIixjYWxsYmFjazplLHBhcmFtczpbbl0sZm9ybWF0OnJ9fSxjLnByb3RvdHlwZS5leGVjdXRlPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuX2NvbnN0YW50P3RoaXMuc2VuZFRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk6dGhpcy5jYWxsLmFwcGx5KHRoaXMsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSl9LGMucHJvdG90eXBlLmF0dGFjaFRvQ29udHJhY3Q9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5leGVjdXRlLmJpbmQodGhpcyk7ZS5yZXF1ZXN0PXRoaXMucmVxdWVzdC5iaW5kKHRoaXMpLGUuY2FsbD10aGlzLmNhbGwuYmluZCh0aGlzKSxlLnNlbmRUcmFuc2FjdGlvbj10aGlzLnNlbmRUcmFuc2FjdGlvbi5iaW5kKHRoaXMpLGUuZXN0aW1hdGVHYXM9dGhpcy5lc3RpbWF0ZUdhcy5iaW5kKHRoaXMpLGUuZ2V0RGF0YT10aGlzLmdldERhdGEuYmluZCh0aGlzKTt2YXIgbj10aGlzLmRpc3BsYXlOYW1lKCk7dFtuXXx8KHRbbl09ZSksdFtuXVt0aGlzLnR5cGVOYW1lKCldPWV9LGUuZXhwb3J0cz1jfSx7Ii4uL3NvbGlkaXR5L2NvZGVyIjo3LCIuLi91dGlscy9zaGEzIjoxOSwiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2Vycm9ycyI6MjYsIi4vZm9ybWF0dGVycyI6MzB9XSwzMjpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZXJyb3JzIik7InVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5YTUxIdHRwUmVxdWVzdD9YTUxIdHRwUmVxdWVzdD13aW5kb3cuWE1MSHR0cFJlcXVlc3Q6WE1MSHR0cFJlcXVlc3Q9dCgieG1saHR0cHJlcXVlc3QiKS5YTUxIdHRwUmVxdWVzdDt2YXIgbz10KCJ4aHIyIiksaT1mdW5jdGlvbih0LGUsbixyLG8pe3RoaXMuaG9zdD10fHwiaHR0cDovL2xvY2FsaG9zdDo4NTQ1Iix0aGlzLnRpbWVvdXQ9ZXx8MCx0aGlzLnVzZXI9bix0aGlzLnBhc3N3b3JkPXIsdGhpcy5oZWFkZXJzPW99O2kucHJvdG90eXBlLnByZXBhcmVSZXF1ZXN0PWZ1bmN0aW9uKHQpe3ZhciBlO2lmKHQ/KGU9bmV3IG8pLnRpbWVvdXQ9dGhpcy50aW1lb3V0OmU9bmV3IFhNTEh0dHBSZXF1ZXN0LGUub3BlbigiUE9TVCIsdGhpcy5ob3N0LHQpLHRoaXMudXNlciYmdGhpcy5wYXNzd29yZCl7dmFyIG49IkJhc2ljICIrbmV3IEJ1ZmZlcih0aGlzLnVzZXIrIjoiK3RoaXMucGFzc3dvcmQpLnRvU3RyaW5nKCJiYXNlNjQiKTtlLnNldFJlcXVlc3RIZWFkZXIoIkF1dGhvcml6YXRpb24iLG4pfXJldHVybiBlLnNldFJlcXVlc3RIZWFkZXIoIkNvbnRlbnQtVHlwZSIsImFwcGxpY2F0aW9uL2pzb24iKSx0aGlzLmhlYWRlcnMmJnRoaXMuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHQpe2Uuc2V0UmVxdWVzdEhlYWRlcih0Lm5hbWUsdC52YWx1ZSl9KSxlfSxpLnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucHJlcGFyZVJlcXVlc3QoITEpO3RyeXtlLnNlbmQoSlNPTi5zdHJpbmdpZnkodCkpfWNhdGNoKHQpe3Rocm93IHIuSW52YWxpZENvbm5lY3Rpb24odGhpcy5ob3N0KX12YXIgbj1lLnJlc3BvbnNlVGV4dDt0cnl7bj1KU09OLnBhcnNlKG4pfWNhdGNoKHQpe3Rocm93IHIuSW52YWxpZFJlc3BvbnNlKGUucmVzcG9uc2VUZXh0KX1yZXR1cm4gbn0saS5wcm90b3R5cGUuc2VuZEFzeW5jPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5wcmVwYXJlUmVxdWVzdCghMCk7bi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZig0PT09bi5yZWFkeVN0YXRlJiYxIT09bi50aW1lb3V0KXt2YXIgdD1uLnJlc3BvbnNlVGV4dCxvPW51bGw7dHJ5e3Q9SlNPTi5wYXJzZSh0KX1jYXRjaCh0KXtvPXIuSW52YWxpZFJlc3BvbnNlKG4ucmVzcG9uc2VUZXh0KX1lKG8sdCl9fSxuLm9udGltZW91dD1mdW5jdGlvbigpe2Uoci5Db25uZWN0aW9uVGltZW91dCh0aGlzLnRpbWVvdXQpKX07dHJ5e24uc2VuZChKU09OLnN0cmluZ2lmeSh0KSl9Y2F0Y2godCl7ZShyLkludmFsaWRDb25uZWN0aW9uKHRoaXMuaG9zdCkpfX0saS5wcm90b3R5cGUuaXNDb25uZWN0ZWQ9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIHRoaXMuc2VuZCh7aWQ6OTk5OTk5OTk5OSxqc29ucnBjOiIyLjAiLG1ldGhvZDoibmV0X2xpc3RlbmluZyIscGFyYW1zOltdfSksITB9Y2F0Y2godCl7cmV0dXJuITF9fSxlLmV4cG9ydHM9aX0seyIuL2Vycm9ycyI6MjYseGhyMjo4NSx4bWxodHRwcmVxdWVzdDoxN31dLDMzOltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiYmlnbnVtYmVyLmpzIiksbz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10O24ubGVuZ3RoPDIqZTspbj0iMCIrbjtyZXR1cm4gbn0saT1mdW5jdGlvbih0KXt2YXIgZT0iQSIuY2hhckNvZGVBdCgwKSxuPSJaIi5jaGFyQ29kZUF0KDApO3JldHVybiB0PXQudG9VcHBlckNhc2UoKSwodD10LnN1YnN0cig0KSt0LnN1YnN0cigwLDQpKS5zcGxpdCgiIikubWFwKGZ1bmN0aW9uKHQpe3ZhciByPXQuY2hhckNvZGVBdCgwKTtyZXR1cm4gcj49ZSYmcjw9bj9yLWUrMTA6dH0pLmpvaW4oIiIpfSxhPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxuPXQ7bi5sZW5ndGg+MjspZT1uLnNsaWNlKDAsOSksbj1wYXJzZUludChlLDEwKSU5NytuLnNsaWNlKGUubGVuZ3RoKTtyZXR1cm4gcGFyc2VJbnQobiwxMCklOTd9LHM9ZnVuY3Rpb24odCl7dGhpcy5faWJhbj10fTtzLmZyb21BZGRyZXNzPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyByKHQsMTYpLnRvU3RyaW5nKDM2KSxuPW8oZSwxNSk7cmV0dXJuIHMuZnJvbUJiYW4obi50b1VwcGVyQ2FzZSgpKX0scy5mcm9tQmJhbj1mdW5jdGlvbih0KXt2YXIgZT0oIjAiKyg5OC1hKGkoIlhFMDAiK3QpKSkpLnNsaWNlKC0yKTtyZXR1cm4gbmV3IHMoIlhFIitlK3QpfSxzLmNyZWF0ZUluZGlyZWN0PWZ1bmN0aW9uKHQpe3JldHVybiBzLmZyb21CYmFuKCJFVEgiK3QuaW5zdGl0dXRpb24rdC5pZGVudGlmaWVyKX0scy5pc1ZhbGlkPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgcyh0KS5pc1ZhbGlkKCl9LHMucHJvdG90eXBlLmlzVmFsaWQ9ZnVuY3Rpb24oKXtyZXR1cm4vXlhFWzAtOV17Mn0oRVRIWzAtOUEtWl17MTN9fFswLTlBLVpdezMwLDMxfSkkLy50ZXN0KHRoaXMuX2liYW4pJiYxPT09YShpKHRoaXMuX2liYW4pKX0scy5wcm90b3R5cGUuaXNEaXJlY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gMzQ9PT10aGlzLl9pYmFuLmxlbmd0aHx8MzU9PT10aGlzLl9pYmFuLmxlbmd0aH0scy5wcm90b3R5cGUuaXNJbmRpcmVjdD1mdW5jdGlvbigpe3JldHVybiAyMD09PXRoaXMuX2liYW4ubGVuZ3RofSxzLnByb3RvdHlwZS5jaGVja3N1bT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9pYmFuLnN1YnN0cigyLDIpfSxzLnByb3RvdHlwZS5pbnN0aXR1dGlvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzSW5kaXJlY3QoKT90aGlzLl9pYmFuLnN1YnN0cig3LDQpOiIifSxzLnByb3RvdHlwZS5jbGllbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0luZGlyZWN0KCk/dGhpcy5faWJhbi5zdWJzdHIoMTEpOiIifSxzLnByb3RvdHlwZS5hZGRyZXNzPWZ1bmN0aW9uKCl7aWYodGhpcy5pc0RpcmVjdCgpKXt2YXIgdD10aGlzLl9pYmFuLnN1YnN0cig0KSxlPW5ldyByKHQsMzYpO3JldHVybiBvKGUudG9TdHJpbmcoMTYpLDIwKX1yZXR1cm4iIn0scy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faWJhbn0sZS5leHBvcnRzPXN9LHsiYmlnbnVtYmVyLmpzIjoiYmlnbnVtYmVyLmpzIn1dLDM0OltmdW5jdGlvbih0LGUsbil7InVzZSBzdHJpY3QiO3ZhciByPXQoIi4uL3V0aWxzL3V0aWxzIiksbz10KCIuL2Vycm9ycyIpLGk9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzO3RoaXMucmVzcG9uc2VDYWxsYmFja3M9e30sdGhpcy5wYXRoPXQsdGhpcy5jb25uZWN0aW9uPWUuY29ubmVjdCh7cGF0aDp0aGlzLnBhdGh9KSx0aGlzLmNvbm5lY3Rpb24ub24oImVycm9yIixmdW5jdGlvbih0KXtjb25zb2xlLmVycm9yKCJJUEMgQ29ubmVjdGlvbiBFcnJvciIsdCksbi5fdGltZW91dCgpfSksdGhpcy5jb25uZWN0aW9uLm9uKCJlbmQiLGZ1bmN0aW9uKCl7bi5fdGltZW91dCgpfSksdGhpcy5jb25uZWN0aW9uLm9uKCJkYXRhIixmdW5jdGlvbih0KXtuLl9wYXJzZVJlc3BvbnNlKHQudG9TdHJpbmcoKSkuZm9yRWFjaChmdW5jdGlvbih0KXt2YXIgZT1udWxsO3IuaXNBcnJheSh0KT90LmZvckVhY2goZnVuY3Rpb24odCl7bi5yZXNwb25zZUNhbGxiYWNrc1t0LmlkXSYmKGU9dC5pZCl9KTplPXQuaWQsbi5yZXNwb25zZUNhbGxiYWNrc1tlXSYmKG4ucmVzcG9uc2VDYWxsYmFja3NbZV0obnVsbCx0KSxkZWxldGUgbi5yZXNwb25zZUNhbGxiYWNrc1tlXSl9KX0pfTtpLnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLG49W107cmV0dXJuIHQucmVwbGFjZSgvXH1bXG5ccl0/XHsvZywifXwtLXx7IikucmVwbGFjZSgvXH1cXVtcblxyXT9cW1x7L2csIn1dfC0tfFt7IikucmVwbGFjZSgvXH1bXG5ccl0/XFtcey9nLCJ9fC0tfFt7IikucmVwbGFjZSgvXH1cXVtcblxyXT9cey9nLCJ9XXwtLXx7Iikuc3BsaXQoInwtLXwiKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2UubGFzdENodW5rJiYodD1lLmxhc3RDaHVuayt0KTt2YXIgcj1udWxsO3RyeXtyPUpTT04ucGFyc2UodCl9Y2F0Y2gobil7cmV0dXJuIGUubGFzdENodW5rPXQsY2xlYXJUaW1lb3V0KGUubGFzdENodW5rVGltZW91dCksdm9pZChlLmxhc3RDaHVua1RpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGUuX3RpbWVvdXQoKSxvLkludmFsaWRSZXNwb25zZSh0KX0sMTVlMykpfWNsZWFyVGltZW91dChlLmxhc3RDaHVua1RpbWVvdXQpLGUubGFzdENodW5rPW51bGwsciYmbi5wdXNoKHIpfSksbn0saS5wcm90b3R5cGUuX2FkZFJlc3BvbnNlQ2FsbGJhY2s9ZnVuY3Rpb24odCxlKXt2YXIgbj10LmlkfHx0WzBdLmlkLHI9dC5tZXRob2R8fHRbMF0ubWV0aG9kO3RoaXMucmVzcG9uc2VDYWxsYmFja3Nbbl09ZSx0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW25dLm1ldGhvZD1yfSxpLnByb3RvdHlwZS5fdGltZW91dD1mdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzKXRoaXMucmVzcG9uc2VDYWxsYmFja3MuaGFzT3duUHJvcGVydHkodCkmJih0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW3RdKG8uSW52YWxpZENvbm5lY3Rpb24oIm9uIElQQyIpKSxkZWxldGUgdGhpcy5yZXNwb25zZUNhbGxiYWNrc1t0XSl9LGkucHJvdG90eXBlLmlzQ29ubmVjdGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29ubmVjdGlvbi53cml0YWJsZXx8dGhpcy5jb25uZWN0aW9uLmNvbm5lY3Qoe3BhdGg6dGhpcy5wYXRofSksISF0aGlzLmNvbm5lY3Rpb24ud3JpdGFibGV9LGkucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24odCl7aWYodGhpcy5jb25uZWN0aW9uLndyaXRlU3luYyl7dmFyIGU7dGhpcy5jb25uZWN0aW9uLndyaXRhYmxlfHx0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCh7cGF0aDp0aGlzLnBhdGh9KTt2YXIgbj10aGlzLmNvbm5lY3Rpb24ud3JpdGVTeW5jKEpTT04uc3RyaW5naWZ5KHQpKTt0cnl7ZT1KU09OLnBhcnNlKG4pfWNhdGNoKHQpe3Rocm93IG8uSW52YWxpZFJlc3BvbnNlKG4pfXJldHVybiBlfXRocm93IG5ldyBFcnJvcignWW91IHRyaWVkIHRvIHNlbmQgIicrdC5tZXRob2QrJyIgc3luY2hyb25vdXNseS4gU3luY2hyb25vdXMgcmVxdWVzdHMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIElQQyBwcm92aWRlci4nKX0saS5wcm90b3R5cGUuc2VuZEFzeW5jPWZ1bmN0aW9uKHQsZSl7dGhpcy5jb25uZWN0aW9uLndyaXRhYmxlfHx0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCh7cGF0aDp0aGlzLnBhdGh9KSx0aGlzLmNvbm5lY3Rpb24ud3JpdGUoSlNPTi5zdHJpbmdpZnkodCkpLHRoaXMuX2FkZFJlc3BvbnNlQ2FsbGJhY2sodCxlKX0sZS5leHBvcnRzPWl9LHsiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2Vycm9ycyI6MjZ9XSwzNTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXttZXNzYWdlSWQ6MH07ci50b1BheWxvYWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdHx8Y29uc29sZS5lcnJvcigianNvbnJwYyBtZXRob2Qgc2hvdWxkIGJlIHNwZWNpZmllZCEiKSxyLm1lc3NhZ2VJZCsrLHtqc29ucnBjOiIyLjAiLGlkOnIubWVzc2FnZUlkLG1ldGhvZDp0LHBhcmFtczplfHxbXX19LHIuaXNWYWxpZFJlc3BvbnNlPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cmV0dXJuISF0JiYhdC5lcnJvciYmIjIuMCI9PT10Lmpzb25ycGMmJiJudW1iZXIiPT10eXBlb2YgdC5pZCYmdm9pZCAwIT09dC5yZXN1bHR9cmV0dXJuIEFycmF5LmlzQXJyYXkodCk/dC5ldmVyeShlKTplKHQpfSxyLnRvQmF0Y2hQYXlsb2FkPWZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gci50b1BheWxvYWQodC5tZXRob2QsdC5wYXJhbXMpfSl9LGUuZXhwb3J0cz1yfSx7fV0sMzY6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuLi91dGlscy91dGlscyIpLG89dCgiLi9lcnJvcnMiKSxpPWZ1bmN0aW9uKHQpe3RoaXMubmFtZT10Lm5hbWUsdGhpcy5jYWxsPXQuY2FsbCx0aGlzLnBhcmFtcz10LnBhcmFtc3x8MCx0aGlzLmlucHV0Rm9ybWF0dGVyPXQuaW5wdXRGb3JtYXR0ZXIsdGhpcy5vdXRwdXRGb3JtYXR0ZXI9dC5vdXRwdXRGb3JtYXR0ZXIsdGhpcy5yZXF1ZXN0TWFuYWdlcj1udWxsfTtpLnByb3RvdHlwZS5zZXRSZXF1ZXN0TWFuYWdlcj1mdW5jdGlvbih0KXt0aGlzLnJlcXVlc3RNYW5hZ2VyPXR9LGkucHJvdG90eXBlLmdldENhbGw9ZnVuY3Rpb24odCl7cmV0dXJuIHIuaXNGdW5jdGlvbih0aGlzLmNhbGwpP3RoaXMuY2FsbCh0KTp0aGlzLmNhbGx9LGkucHJvdG90eXBlLmV4dHJhY3RDYWxsYmFjaz1mdW5jdGlvbih0KXtpZihyLmlzRnVuY3Rpb24odFt0Lmxlbmd0aC0xXSkpcmV0dXJuIHQucG9wKCl9LGkucHJvdG90eXBlLnZhbGlkYXRlQXJncz1mdW5jdGlvbih0KXtpZih0Lmxlbmd0aCE9PXRoaXMucGFyYW1zKXRocm93IG8uSW52YWxpZE51bWJlck9mUlBDUGFyYW1zKCl9LGkucHJvdG90eXBlLmZvcm1hdElucHV0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlucHV0Rm9ybWF0dGVyP3RoaXMuaW5wdXRGb3JtYXR0ZXIubWFwKGZ1bmN0aW9uKGUsbil7cmV0dXJuIGU/ZSh0W25dKTp0W25dfSk6dH0saS5wcm90b3R5cGUuZm9ybWF0T3V0cHV0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm91dHB1dEZvcm1hdHRlciYmdD90aGlzLm91dHB1dEZvcm1hdHRlcih0KTp0fSxpLnByb3RvdHlwZS50b1BheWxvYWQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRDYWxsKHQpLG49dGhpcy5leHRyYWN0Q2FsbGJhY2sodCkscj10aGlzLmZvcm1hdElucHV0KHQpO3JldHVybiB0aGlzLnZhbGlkYXRlQXJncyhyKSx7bWV0aG9kOmUscGFyYW1zOnIsY2FsbGJhY2s6bn19LGkucHJvdG90eXBlLmF0dGFjaFRvT2JqZWN0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuYnVpbGRDYWxsKCk7ZS5jYWxsPXRoaXMuY2FsbDt2YXIgbj10aGlzLm5hbWUuc3BsaXQoIi4iKTtuLmxlbmd0aD4xPyh0W25bMF1dPXRbblswXV18fHt9LHRbblswXV1bblsxXV09ZSk6dFtuWzBdXT1lfSxpLnByb3RvdHlwZS5idWlsZENhbGw9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9ZnVuY3Rpb24oKXt2YXIgZT10LnRvUGF5bG9hZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtyZXR1cm4gZS5jYWxsYmFjaz90LnJlcXVlc3RNYW5hZ2VyLnNlbmRBc3luYyhlLGZ1bmN0aW9uKG4scil7ZS5jYWxsYmFjayhuLHQuZm9ybWF0T3V0cHV0KHIpKX0pOnQuZm9ybWF0T3V0cHV0KHQucmVxdWVzdE1hbmFnZXIuc2VuZChlKSl9O3JldHVybiBlLnJlcXVlc3Q9dGhpcy5yZXF1ZXN0LmJpbmQodGhpcyksZX0saS5wcm90b3R5cGUucmVxdWVzdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMudG9QYXlsb2FkKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO3JldHVybiB0LmZvcm1hdD10aGlzLmZvcm1hdE91dHB1dC5iaW5kKHRoaXMpLHR9LGUuZXhwb3J0cz1pfSx7Ii4uL3V0aWxzL3V0aWxzIjoyMCwiLi9lcnJvcnMiOjI2fV0sMzc6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuLi9tZXRob2QiKSxvPWZ1bmN0aW9uKCl7cmV0dXJuW25ldyByKHtuYW1lOiJwdXRTdHJpbmciLGNhbGw6ImRiX3B1dFN0cmluZyIscGFyYW1zOjN9KSxuZXcgcih7bmFtZToiZ2V0U3RyaW5nIixjYWxsOiJkYl9nZXRTdHJpbmciLHBhcmFtczoyfSksbmV3IHIoe25hbWU6InB1dEhleCIsY2FsbDoiZGJfcHV0SGV4IixwYXJhbXM6M30pLG5ldyByKHtuYW1lOiJnZXRIZXgiLGNhbGw6ImRiX2dldEhleCIscGFyYW1zOjJ9KV19O2UuZXhwb3J0cz1mdW5jdGlvbih0KXt0aGlzLl9yZXF1ZXN0TWFuYWdlcj10Ll9yZXF1ZXN0TWFuYWdlcjt2YXIgZT10aGlzO28oKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe24uYXR0YWNoVG9PYmplY3QoZSksbi5zZXRSZXF1ZXN0TWFuYWdlcih0Ll9yZXF1ZXN0TWFuYWdlcil9KX19LHsiLi4vbWV0aG9kIjozNn1dLDM4OltmdW5jdGlvbih0LGUsbil7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHIodCl7dGhpcy5fcmVxdWVzdE1hbmFnZXI9dC5fcmVxdWVzdE1hbmFnZXI7dmFyIGU9dGhpczt3KCkuZm9yRWFjaChmdW5jdGlvbih0KXt0LmF0dGFjaFRvT2JqZWN0KGUpLHQuc2V0UmVxdWVzdE1hbmFnZXIoZS5fcmVxdWVzdE1hbmFnZXIpfSkseCgpLmZvckVhY2goZnVuY3Rpb24odCl7dC5hdHRhY2hUb09iamVjdChlKSx0LnNldFJlcXVlc3RNYW5hZ2VyKGUuX3JlcXVlc3RNYW5hZ2VyKX0pLHRoaXMuaWJhbj1kLHRoaXMuc2VuZElCQU5UcmFuc2FjdGlvbj1tLmJpbmQobnVsbCx0aGlzKX12YXIgbz10KCIuLi9mb3JtYXR0ZXJzIiksaT10KCIuLi8uLi91dGlscy91dGlscyIpLGE9dCgiLi4vbWV0aG9kIikscz10KCIuLi9wcm9wZXJ0eSIpLGM9dCgiLi4vLi4vdXRpbHMvY29uZmlnIiksdT10KCIuLi9jb250cmFjdCIpLGY9dCgiLi93YXRjaGVzIiksbD10KCIuLi9maWx0ZXIiKSxwPXQoIi4uL3N5bmNpbmciKSxoPXQoIi4uL25hbWVyZWciKSxkPXQoIi4uL2liYW4iKSxtPXQoIi4uL3RyYW5zZmVyIikseT1mdW5jdGlvbih0KXtyZXR1cm4gaS5pc1N0cmluZyh0WzBdKSYmMD09PXRbMF0uaW5kZXhPZigiMHgiKT8iZXRoX2dldEJsb2NrQnlIYXNoIjoiZXRoX2dldEJsb2NrQnlOdW1iZXIifSxnPWZ1bmN0aW9uKHQpe3JldHVybiBpLmlzU3RyaW5nKHRbMF0pJiYwPT09dFswXS5pbmRleE9mKCIweCIpPyJldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSGFzaEFuZEluZGV4IjoiZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4In0sdj1mdW5jdGlvbih0KXtyZXR1cm4gaS5pc1N0cmluZyh0WzBdKSYmMD09PXRbMF0uaW5kZXhPZigiMHgiKT8iZXRoX2dldFVuY2xlQnlCbG9ja0hhc2hBbmRJbmRleCI6ImV0aF9nZXRVbmNsZUJ5QmxvY2tOdW1iZXJBbmRJbmRleCJ9LGI9ZnVuY3Rpb24odCl7cmV0dXJuIGkuaXNTdHJpbmcodFswXSkmJjA9PT10WzBdLmluZGV4T2YoIjB4Iik/ImV0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeUhhc2giOiJldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlOdW1iZXIifSxfPWZ1bmN0aW9uKHQpe3JldHVybiBpLmlzU3RyaW5nKHRbMF0pJiYwPT09dFswXS5pbmRleE9mKCIweCIpPyJldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tIYXNoIjoiZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrTnVtYmVyIn07T2JqZWN0LmRlZmluZVByb3BlcnR5KHIucHJvdG90eXBlLCJkZWZhdWx0QmxvY2siLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWZhdWx0QmxvY2t9LHNldDpmdW5jdGlvbih0KXtyZXR1cm4gYy5kZWZhdWx0QmxvY2s9dCx0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLnByb3RvdHlwZSwiZGVmYXVsdEFjY291bnQiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5kZWZhdWx0QWNjb3VudH0sc2V0OmZ1bmN0aW9uKHQpe3JldHVybiBjLmRlZmF1bHRBY2NvdW50PXQsdH19KTt2YXIgdz1mdW5jdGlvbigpe3ZhciB0PW5ldyBhKHtuYW1lOiJnZXRCYWxhbmNlIixjYWxsOiJldGhfZ2V0QmFsYW5jZSIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W28uaW5wdXRBZGRyZXNzRm9ybWF0dGVyLG8uaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLG91dHB1dEZvcm1hdHRlcjpvLm91dHB1dEJpZ051bWJlckZvcm1hdHRlcn0pLGU9bmV3IGEoe25hbWU6ImdldFN0b3JhZ2VBdCIsY2FsbDoiZXRoX2dldFN0b3JhZ2VBdCIscGFyYW1zOjMsaW5wdXRGb3JtYXR0ZXI6W251bGwsaS50b0hleCxvLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXX0pLG49bmV3IGEoe25hbWU6ImdldENvZGUiLGNhbGw6ImV0aF9nZXRDb2RlIixwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbby5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsby5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl19KSxyPW5ldyBhKHtuYW1lOiJnZXRCbG9jayIsY2FsbDp5LHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltvLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsZnVuY3Rpb24odCl7cmV0dXJuISF0fV0sb3V0cHV0Rm9ybWF0dGVyOm8ub3V0cHV0QmxvY2tGb3JtYXR0ZXJ9KSxzPW5ldyBhKHtuYW1lOiJnZXRVbmNsZSIsY2FsbDp2LHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltvLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsaS50b0hleF0sb3V0cHV0Rm9ybWF0dGVyOm8ub3V0cHV0QmxvY2tGb3JtYXR0ZXJ9KSxjPW5ldyBhKHtuYW1lOiJnZXRDb21waWxlcnMiLGNhbGw6ImV0aF9nZXRDb21waWxlcnMiLHBhcmFtczowfSksdT1uZXcgYSh7bmFtZToiZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50IixjYWxsOmIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W28uaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcl0sb3V0cHV0Rm9ybWF0dGVyOmkudG9EZWNpbWFsfSksZj1uZXcgYSh7bmFtZToiZ2V0QmxvY2tVbmNsZUNvdW50IixjYWxsOl8scGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W28uaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcl0sb3V0cHV0Rm9ybWF0dGVyOmkudG9EZWNpbWFsfSksbD1uZXcgYSh7bmFtZToiZ2V0VHJhbnNhY3Rpb24iLGNhbGw6ImV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCIscGFyYW1zOjEsb3V0cHV0Rm9ybWF0dGVyOm8ub3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJ9KSxwPW5ldyBhKHtuYW1lOiJnZXRUcmFuc2FjdGlvbkZyb21CbG9jayIsY2FsbDpnLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltvLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsaS50b0hleF0sb3V0cHV0Rm9ybWF0dGVyOm8ub3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJ9KSxoPW5ldyBhKHtuYW1lOiJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLGNhbGw6ImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQiLHBhcmFtczoxLG91dHB1dEZvcm1hdHRlcjpvLm91dHB1dFRyYW5zYWN0aW9uUmVjZWlwdEZvcm1hdHRlcn0pLGQ9bmV3IGEoe25hbWU6ImdldFRyYW5zYWN0aW9uQ291bnQiLGNhbGw6ImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50IixwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbbnVsbCxvLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXSxvdXRwdXRGb3JtYXR0ZXI6aS50b0RlY2ltYWx9KSxtPW5ldyBhKHtuYW1lOiJzZW5kUmF3VHJhbnNhY3Rpb24iLGNhbGw6ImV0aF9zZW5kUmF3VHJhbnNhY3Rpb24iLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltudWxsXX0pLHc9bmV3IGEoe25hbWU6InNlbmRUcmFuc2FjdGlvbiIsY2FsbDoiZXRoX3NlbmRUcmFuc2FjdGlvbiIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W28uaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcl19KSx4PW5ldyBhKHtuYW1lOiJzaWduVHJhbnNhY3Rpb24iLGNhbGw6ImV0aF9zaWduVHJhbnNhY3Rpb24iLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltvLmlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXJdfSksaz1uZXcgYSh7bmFtZToic2lnbiIsY2FsbDoiZXRoX3NpZ24iLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltvLmlucHV0QWRkcmVzc0Zvcm1hdHRlcixudWxsXX0pO3JldHVyblt0LGUsbixyLHMsYyx1LGYsbCxwLGgsZCxuZXcgYSh7bmFtZToiY2FsbCIsY2FsbDoiZXRoX2NhbGwiLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltvLmlucHV0Q2FsbEZvcm1hdHRlcixvLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXX0pLG5ldyBhKHtuYW1lOiJlc3RpbWF0ZUdhcyIsY2FsbDoiZXRoX2VzdGltYXRlR2FzIixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbby5pbnB1dENhbGxGb3JtYXR0ZXJdLG91dHB1dEZvcm1hdHRlcjppLnRvRGVjaW1hbH0pLG0seCx3LGssbmV3IGEoe25hbWU6ImNvbXBpbGUuc29saWRpdHkiLGNhbGw6ImV0aF9jb21waWxlU29saWRpdHkiLHBhcmFtczoxfSksbmV3IGEoe25hbWU6ImNvbXBpbGUubGxsIixjYWxsOiJldGhfY29tcGlsZUxMTCIscGFyYW1zOjF9KSxuZXcgYSh7bmFtZToiY29tcGlsZS5zZXJwZW50IixjYWxsOiJldGhfY29tcGlsZVNlcnBlbnQiLHBhcmFtczoxfSksbmV3IGEoe25hbWU6InN1Ym1pdFdvcmsiLGNhbGw6ImV0aF9zdWJtaXRXb3JrIixwYXJhbXM6M30pLG5ldyBhKHtuYW1lOiJnZXRXb3JrIixjYWxsOiJldGhfZ2V0V29yayIscGFyYW1zOjB9KV19LHg9ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IHMoe25hbWU6ImNvaW5iYXNlIixnZXR0ZXI6ImV0aF9jb2luYmFzZSJ9KSxuZXcgcyh7bmFtZToibWluaW5nIixnZXR0ZXI6ImV0aF9taW5pbmcifSksbmV3IHMoe25hbWU6Imhhc2hyYXRlIixnZXR0ZXI6ImV0aF9oYXNocmF0ZSIsb3V0cHV0Rm9ybWF0dGVyOmkudG9EZWNpbWFsfSksbmV3IHMoe25hbWU6InN5bmNpbmciLGdldHRlcjoiZXRoX3N5bmNpbmciLG91dHB1dEZvcm1hdHRlcjpvLm91dHB1dFN5bmNpbmdGb3JtYXR0ZXJ9KSxuZXcgcyh7bmFtZToiZ2FzUHJpY2UiLGdldHRlcjoiZXRoX2dhc1ByaWNlIixvdXRwdXRGb3JtYXR0ZXI6by5vdXRwdXRCaWdOdW1iZXJGb3JtYXR0ZXJ9KSxuZXcgcyh7bmFtZToiYWNjb3VudHMiLGdldHRlcjoiZXRoX2FjY291bnRzIn0pLG5ldyBzKHtuYW1lOiJibG9ja051bWJlciIsZ2V0dGVyOiJldGhfYmxvY2tOdW1iZXIiLG91dHB1dEZvcm1hdHRlcjppLnRvRGVjaW1hbH0pLG5ldyBzKHtuYW1lOiJwcm90b2NvbFZlcnNpb24iLGdldHRlcjoiZXRoX3Byb3RvY29sVmVyc2lvbiJ9KV19O3IucHJvdG90eXBlLmNvbnRyYWN0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgdSh0aGlzLHQpfSxyLnByb3RvdHlwZS5maWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBuZXcgbCh0LCJldGgiLHRoaXMuX3JlcXVlc3RNYW5hZ2VyLGYuZXRoKCksby5vdXRwdXRMb2dGb3JtYXR0ZXIsZSxuKX0sci5wcm90b3R5cGUubmFtZXJlZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRyYWN0KGguZ2xvYmFsLmFiaSkuYXQoaC5nbG9iYWwuYWRkcmVzcyl9LHIucHJvdG90eXBlLmljYXBOYW1lcmVnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udHJhY3QoaC5pY2FwLmFiaSkuYXQoaC5pY2FwLmFkZHJlc3MpfSxyLnByb3RvdHlwZS5pc1N5bmNpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBwKHRoaXMuX3JlcXVlc3RNYW5hZ2VyLHQpfSxlLmV4cG9ydHM9cn0seyIuLi8uLi91dGlscy9jb25maWciOjE4LCIuLi8uLi91dGlscy91dGlscyI6MjAsIi4uL2NvbnRyYWN0IjoyNSwiLi4vZmlsdGVyIjoyOSwiLi4vZm9ybWF0dGVycyI6MzAsIi4uL2liYW4iOjMzLCIuLi9tZXRob2QiOjM2LCIuLi9uYW1lcmVnIjo0NCwiLi4vcHJvcGVydHkiOjQ1LCIuLi9zeW5jaW5nIjo0OCwiLi4vdHJhbnNmZXIiOjQ5LCIuL3dhdGNoZXMiOjQzfV0sMzk6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuLi8uLi91dGlscy91dGlscyIpLG89dCgiLi4vcHJvcGVydHkiKSxpPWZ1bmN0aW9uKCl7cmV0dXJuW25ldyBvKHtuYW1lOiJsaXN0ZW5pbmciLGdldHRlcjoibmV0X2xpc3RlbmluZyJ9KSxuZXcgbyh7bmFtZToicGVlckNvdW50IixnZXR0ZXI6Im5ldF9wZWVyQ291bnQiLG91dHB1dEZvcm1hdHRlcjpyLnRvRGVjaW1hbH0pXX07ZS5leHBvcnRzPWZ1bmN0aW9uKHQpe3RoaXMuX3JlcXVlc3RNYW5hZ2VyPXQuX3JlcXVlc3RNYW5hZ2VyO3ZhciBlPXRoaXM7aSgpLmZvckVhY2goZnVuY3Rpb24obil7bi5hdHRhY2hUb09iamVjdChlKSxuLnNldFJlcXVlc3RNYW5hZ2VyKHQuX3JlcXVlc3RNYW5hZ2VyKX0pfX0seyIuLi8uLi91dGlscy91dGlscyI6MjAsIi4uL3Byb3BlcnR5Ijo0NX1dLDQwOltmdW5jdGlvbih0LGUsbil7InVzZSBzdHJpY3QiO3ZhciByPXQoIi4uL21ldGhvZCIpLG89dCgiLi4vcHJvcGVydHkiKSxpPXQoIi4uL2Zvcm1hdHRlcnMiKSxhPWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IHIoe25hbWU6Im5ld0FjY291bnQiLGNhbGw6InBlcnNvbmFsX25ld0FjY291bnQiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltudWxsXX0pLGU9bmV3IHIoe25hbWU6ImltcG9ydFJhd0tleSIsY2FsbDoicGVyc29uYWxfaW1wb3J0UmF3S2V5IixwYXJhbXM6Mn0pLG49bmV3IHIoe25hbWU6InNpZ24iLGNhbGw6InBlcnNvbmFsX3NpZ24iLHBhcmFtczozLGlucHV0Rm9ybWF0dGVyOltudWxsLGkuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLG51bGxdfSksbz1uZXcgcih7bmFtZToiZWNSZWNvdmVyIixjYWxsOiJwZXJzb25hbF9lY1JlY292ZXIiLHBhcmFtczoyfSk7cmV0dXJuW3QsZSxuZXcgcih7bmFtZToidW5sb2NrQWNjb3VudCIsY2FsbDoicGVyc29uYWxfdW5sb2NrQWNjb3VudCIscGFyYW1zOjMsaW5wdXRGb3JtYXR0ZXI6W2kuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLG51bGwsbnVsbF19KSxvLG4sbmV3IHIoe25hbWU6InNlbmRUcmFuc2FjdGlvbiIsY2FsbDoicGVyc29uYWxfc2VuZFRyYW5zYWN0aW9uIixwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbaS5pbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyLG51bGxdfSksbmV3IHIoe25hbWU6ImxvY2tBY2NvdW50IixjYWxsOiJwZXJzb25hbF9sb2NrQWNjb3VudCIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W2kuaW5wdXRBZGRyZXNzRm9ybWF0dGVyXX0pXX0scz1mdW5jdGlvbigpe3JldHVybltuZXcgbyh7bmFtZToibGlzdEFjY291bnRzIixnZXR0ZXI6InBlcnNvbmFsX2xpc3RBY2NvdW50cyJ9KV19O2UuZXhwb3J0cz1mdW5jdGlvbih0KXt0aGlzLl9yZXF1ZXN0TWFuYWdlcj10Ll9yZXF1ZXN0TWFuYWdlcjt2YXIgZT10aGlzO2EoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuYXR0YWNoVG9PYmplY3QoZSksdC5zZXRSZXF1ZXN0TWFuYWdlcihlLl9yZXF1ZXN0TWFuYWdlcil9KSxzKCkuZm9yRWFjaChmdW5jdGlvbih0KXt0LmF0dGFjaFRvT2JqZWN0KGUpLHQuc2V0UmVxdWVzdE1hbmFnZXIoZS5fcmVxdWVzdE1hbmFnZXIpfSl9fSx7Ii4uL2Zvcm1hdHRlcnMiOjMwLCIuLi9tZXRob2QiOjM2LCIuLi9wcm9wZXJ0eSI6NDV9XSw0MTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL21ldGhvZCIpLG89dCgiLi4vZmlsdGVyIiksaT10KCIuL3dhdGNoZXMiKSxhPWZ1bmN0aW9uKHQpe3RoaXMuX3JlcXVlc3RNYW5hZ2VyPXQuX3JlcXVlc3RNYW5hZ2VyO3ZhciBlPXRoaXM7cygpLmZvckVhY2goZnVuY3Rpb24odCl7dC5hdHRhY2hUb09iamVjdChlKSx0LnNldFJlcXVlc3RNYW5hZ2VyKGUuX3JlcXVlc3RNYW5hZ2VyKX0pfTthLnByb3RvdHlwZS5uZXdNZXNzYWdlRmlsdGVyPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gbmV3IG8odCwic2hoIix0aGlzLl9yZXF1ZXN0TWFuYWdlcixpLnNoaCgpLG51bGwsZSxuKX07dmFyIHM9ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IHIoe25hbWU6InZlcnNpb24iLGNhbGw6InNoaF92ZXJzaW9uIixwYXJhbXM6MH0pLG5ldyByKHtuYW1lOiJpbmZvIixjYWxsOiJzaGhfaW5mbyIscGFyYW1zOjB9KSxuZXcgcih7bmFtZToic2V0TWF4TWVzc2FnZVNpemUiLGNhbGw6InNoaF9zZXRNYXhNZXNzYWdlU2l6ZSIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToic2V0TWluUG9XIixjYWxsOiJzaGhfc2V0TWluUG9XIixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJtYXJrVHJ1c3RlZFBlZXIiLGNhbGw6InNoaF9tYXJrVHJ1c3RlZFBlZXIiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6Im5ld0tleVBhaXIiLGNhbGw6InNoaF9uZXdLZXlQYWlyIixwYXJhbXM6MH0pLG5ldyByKHtuYW1lOiJhZGRQcml2YXRlS2V5IixjYWxsOiJzaGhfYWRkUHJpdmF0ZUtleSIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToiZGVsZXRlS2V5UGFpciIsY2FsbDoic2hoX2RlbGV0ZUtleVBhaXIiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6Imhhc0tleVBhaXIiLGNhbGw6InNoaF9oYXNLZXlQYWlyIixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJnZXRQdWJsaWNLZXkiLGNhbGw6InNoaF9nZXRQdWJsaWNLZXkiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6ImdldFByaXZhdGVLZXkiLGNhbGw6InNoaF9nZXRQcml2YXRlS2V5IixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJuZXdTeW1LZXkiLGNhbGw6InNoaF9uZXdTeW1LZXkiLHBhcmFtczowfSksbmV3IHIoe25hbWU6ImFkZFN5bUtleSIsY2FsbDoic2hoX2FkZFN5bUtleSIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToiZ2VuZXJhdGVTeW1LZXlGcm9tUGFzc3dvcmQiLGNhbGw6InNoaF9nZW5lcmF0ZVN5bUtleUZyb21QYXNzd29yZCIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToiaGFzU3ltS2V5IixjYWxsOiJzaGhfaGFzU3ltS2V5IixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJnZXRTeW1LZXkiLGNhbGw6InNoaF9nZXRTeW1LZXkiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6ImRlbGV0ZVN5bUtleSIsY2FsbDoic2hoX2RlbGV0ZVN5bUtleSIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToicG9zdCIsY2FsbDoic2hoX3Bvc3QiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltudWxsXX0pXX07ZS5leHBvcnRzPWF9LHsiLi4vZmlsdGVyIjoyOSwiLi4vbWV0aG9kIjozNiwiLi93YXRjaGVzIjo0M31dLDQyOltmdW5jdGlvbih0LGUsbil7InVzZSBzdHJpY3QiO3ZhciByPXQoIi4uL21ldGhvZCIpLG89dCgiLi4vcHJvcGVydHkiKSxpPWZ1bmN0aW9uKCl7cmV0dXJuW25ldyByKHtuYW1lOiJibG9ja05ldHdvcmtSZWFkIixjYWxsOiJienpfYmxvY2tOZXR3b3JrUmVhZCIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W251bGxdfSksbmV3IHIoe25hbWU6InN5bmNFbmFibGVkIixjYWxsOiJienpfc3luY0VuYWJsZWQiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltudWxsXX0pLG5ldyByKHtuYW1lOiJzd2FwRW5hYmxlZCIsY2FsbDoiYnp6X3N3YXBFbmFibGVkIixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbbnVsbF19KSxuZXcgcih7bmFtZToiZG93bmxvYWQiLGNhbGw6ImJ6el9kb3dubG9hZCIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W251bGwsbnVsbF19KSxuZXcgcih7bmFtZToidXBsb2FkIixjYWxsOiJienpfdXBsb2FkIixwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbbnVsbCxudWxsXX0pLG5ldyByKHtuYW1lOiJyZXRyaWV2ZSIsY2FsbDoiYnp6X3JldHJpZXZlIixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbbnVsbF19KSxuZXcgcih7bmFtZToic3RvcmUiLGNhbGw6ImJ6el9zdG9yZSIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W251bGwsbnVsbF19KSxuZXcgcih7bmFtZToiZ2V0IixjYWxsOiJienpfZ2V0IixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbbnVsbF19KSxuZXcgcih7bmFtZToicHV0IixjYWxsOiJienpfcHV0IixwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbbnVsbCxudWxsXX0pLG5ldyByKHtuYW1lOiJtb2RpZnkiLGNhbGw6ImJ6el9tb2RpZnkiLHBhcmFtczo0LGlucHV0Rm9ybWF0dGVyOltudWxsLG51bGwsbnVsbCxudWxsXX0pXX0sYT1mdW5jdGlvbigpe3JldHVybltuZXcgbyh7bmFtZToiaGl2ZSIsZ2V0dGVyOiJienpfaGl2ZSJ9KSxuZXcgbyh7bmFtZToiaW5mbyIsZ2V0dGVyOiJienpfaW5mbyJ9KV19O2UuZXhwb3J0cz1mdW5jdGlvbih0KXt0aGlzLl9yZXF1ZXN0TWFuYWdlcj10Ll9yZXF1ZXN0TWFuYWdlcjt2YXIgZT10aGlzO2koKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuYXR0YWNoVG9PYmplY3QoZSksdC5zZXRSZXF1ZXN0TWFuYWdlcihlLl9yZXF1ZXN0TWFuYWdlcil9KSxhKCkuZm9yRWFjaChmdW5jdGlvbih0KXt0LmF0dGFjaFRvT2JqZWN0KGUpLHQuc2V0UmVxdWVzdE1hbmFnZXIoZS5fcmVxdWVzdE1hbmFnZXIpfSl9fSx7Ii4uL21ldGhvZCI6MzYsIi4uL3Byb3BlcnR5Ijo0NX1dLDQzOltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi4vbWV0aG9kIik7ZS5leHBvcnRzPXtldGg6ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IHIoe25hbWU6Im5ld0ZpbHRlciIsY2FsbDpmdW5jdGlvbih0KXtzd2l0Y2godFswXSl7Y2FzZSJsYXRlc3QiOnJldHVybiB0LnNoaWZ0KCksdGhpcy5wYXJhbXM9MCwiZXRoX25ld0Jsb2NrRmlsdGVyIjtjYXNlInBlbmRpbmciOnJldHVybiB0LnNoaWZ0KCksdGhpcy5wYXJhbXM9MCwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlciI7ZGVmYXVsdDpyZXR1cm4iZXRoX25ld0ZpbHRlciJ9fSxwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJ1bmluc3RhbGxGaWx0ZXIiLGNhbGw6ImV0aF91bmluc3RhbGxGaWx0ZXIiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6ImdldExvZ3MiLGNhbGw6ImV0aF9nZXRGaWx0ZXJMb2dzIixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJwb2xsIixjYWxsOiJldGhfZ2V0RmlsdGVyQ2hhbmdlcyIscGFyYW1zOjF9KV19LHNoaDpmdW5jdGlvbigpe3JldHVybltuZXcgcih7bmFtZToibmV3RmlsdGVyIixjYWxsOiJzaGhfbmV3TWVzc2FnZUZpbHRlciIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToidW5pbnN0YWxsRmlsdGVyIixjYWxsOiJzaGhfZGVsZXRlTWVzc2FnZUZpbHRlciIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToiZ2V0TG9ncyIsY2FsbDoic2hoX2dldEZpbHRlck1lc3NhZ2VzIixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJwb2xsIixjYWxsOiJzaGhfZ2V0RmlsdGVyTWVzc2FnZXMiLHBhcmFtczoxfSldfX19LHsiLi4vbWV0aG9kIjozNn1dLDQ0OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi4vY29udHJhY3RzL0dsb2JhbFJlZ2lzdHJhci5qc29uIiksbz10KCIuLi9jb250cmFjdHMvSUNBUFJlZ2lzdHJhci5qc29uIik7ZS5leHBvcnRzPXtnbG9iYWw6e2FiaTpyLGFkZHJlc3M6IjB4YzZkOWQyY2Q0NDlhNzU0YzQ5NDI2NGUxODA5YzUwZTM0ZDY0NTYyYiJ9LGljYXA6e2FiaTpvLGFkZHJlc3M6IjB4YTFhMTExYmMwNzRjOWNmYTc4MWYwYzM4ZTYzYmQ1MWM5MWI4YWYwMCJ9fX0seyIuLi9jb250cmFjdHMvR2xvYmFsUmVnaXN0cmFyLmpzb24iOjEsIi4uL2NvbnRyYWN0cy9JQ0FQUmVnaXN0cmFyLmpzb24iOjJ9XSw0NTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL3V0aWxzL3V0aWxzIiksbz1mdW5jdGlvbih0KXt0aGlzLm5hbWU9dC5uYW1lLHRoaXMuZ2V0dGVyPXQuZ2V0dGVyLHRoaXMuc2V0dGVyPXQuc2V0dGVyLHRoaXMub3V0cHV0Rm9ybWF0dGVyPXQub3V0cHV0Rm9ybWF0dGVyLHRoaXMuaW5wdXRGb3JtYXR0ZXI9dC5pbnB1dEZvcm1hdHRlcix0aGlzLnJlcXVlc3RNYW5hZ2VyPW51bGx9O28ucHJvdG90eXBlLnNldFJlcXVlc3RNYW5hZ2VyPWZ1bmN0aW9uKHQpe3RoaXMucmVxdWVzdE1hbmFnZXI9dH0sby5wcm90b3R5cGUuZm9ybWF0SW5wdXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaW5wdXRGb3JtYXR0ZXI/dGhpcy5pbnB1dEZvcm1hdHRlcih0KTp0fSxvLnByb3RvdHlwZS5mb3JtYXRPdXRwdXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3V0cHV0Rm9ybWF0dGVyJiZudWxsIT09dCYmdm9pZCAwIT09dD90aGlzLm91dHB1dEZvcm1hdHRlcih0KTp0fSxvLnByb3RvdHlwZS5leHRyYWN0Q2FsbGJhY2s9ZnVuY3Rpb24odCl7aWYoci5pc0Z1bmN0aW9uKHRbdC5sZW5ndGgtMV0pKXJldHVybiB0LnBvcCgpfSxvLnByb3RvdHlwZS5hdHRhY2hUb09iamVjdD1mdW5jdGlvbih0KXt2YXIgZT17Z2V0OnRoaXMuYnVpbGRHZXQoKSxlbnVtZXJhYmxlOiEwfSxuPXRoaXMubmFtZS5zcGxpdCgiLiIpLHI9blswXTtuLmxlbmd0aD4xJiYodFtuWzBdXT10W25bMF1dfHx7fSx0PXRbblswXV0scj1uWzFdKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxyLGUpLHRbaShyKV09dGhpcy5idWlsZEFzeW5jR2V0KCl9O3ZhciBpPWZ1bmN0aW9uKHQpe3JldHVybiJnZXQiK3QuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKX07by5wcm90b3R5cGUuYnVpbGRHZXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmZvcm1hdE91dHB1dCh0LnJlcXVlc3RNYW5hZ2VyLnNlbmQoe21ldGhvZDp0LmdldHRlcn0pKX19LG8ucHJvdG90eXBlLmJ1aWxkQXN5bmNHZXQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLGU9ZnVuY3Rpb24oZSl7dC5yZXF1ZXN0TWFuYWdlci5zZW5kQXN5bmMoe21ldGhvZDp0LmdldHRlcn0sZnVuY3Rpb24obixyKXtlKG4sdC5mb3JtYXRPdXRwdXQocikpfSl9O3JldHVybiBlLnJlcXVlc3Q9dGhpcy5yZXF1ZXN0LmJpbmQodGhpcyksZX0sby5wcm90b3R5cGUucmVxdWVzdD1mdW5jdGlvbigpe3ZhciB0PXttZXRob2Q6dGhpcy5nZXR0ZXIscGFyYW1zOltdLGNhbGxiYWNrOnRoaXMuZXh0cmFjdENhbGxiYWNrKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpfTtyZXR1cm4gdC5mb3JtYXQ9dGhpcy5mb3JtYXRPdXRwdXQuYmluZCh0aGlzKSx0fSxlLmV4cG9ydHM9b30seyIuLi91dGlscy91dGlscyI6MjB9XSw0NjpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vanNvbnJwYyIpLG89dCgiLi4vdXRpbHMvdXRpbHMiKSxpPXQoIi4uL3V0aWxzL2NvbmZpZyIpLGE9dCgiLi9lcnJvcnMiKSxzPWZ1bmN0aW9uKHQpe3RoaXMucHJvdmlkZXI9dCx0aGlzLnBvbGxzPXt9LHRoaXMudGltZW91dD1udWxsfTtzLnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKHQpe2lmKCF0aGlzLnByb3ZpZGVyKXJldHVybiBjb25zb2xlLmVycm9yKGEuSW52YWxpZFByb3ZpZGVyKCkpLG51bGw7dmFyIGU9ci50b1BheWxvYWQodC5tZXRob2QsdC5wYXJhbXMpLG49dGhpcy5wcm92aWRlci5zZW5kKGUpO2lmKCFyLmlzVmFsaWRSZXNwb25zZShuKSl0aHJvdyBhLkludmFsaWRSZXNwb25zZShuKTtyZXR1cm4gbi5yZXN1bHR9LHMucHJvdG90eXBlLnNlbmRBc3luYz1mdW5jdGlvbih0LGUpe2lmKCF0aGlzLnByb3ZpZGVyKXJldHVybiBlKGEuSW52YWxpZFByb3ZpZGVyKCkpO3ZhciBuPXIudG9QYXlsb2FkKHQubWV0aG9kLHQucGFyYW1zKTt0aGlzLnByb3ZpZGVyLnNlbmRBc3luYyhuLGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQ/ZSh0KTpyLmlzVmFsaWRSZXNwb25zZShuKT92b2lkIGUobnVsbCxuLnJlc3VsdCk6ZShhLkludmFsaWRSZXNwb25zZShuKSl9KX0scy5wcm90b3R5cGUuc2VuZEJhdGNoPWZ1bmN0aW9uKHQsZSl7aWYoIXRoaXMucHJvdmlkZXIpcmV0dXJuIGUoYS5JbnZhbGlkUHJvdmlkZXIoKSk7dmFyIG49ci50b0JhdGNoUGF5bG9hZCh0KTt0aGlzLnByb3ZpZGVyLnNlbmRBc3luYyhuLGZ1bmN0aW9uKHQsbil7cmV0dXJuIHQ/ZSh0KTpvLmlzQXJyYXkobik/dm9pZCBlKHQsbik6ZShhLkludmFsaWRSZXNwb25zZShuKSl9KX0scy5wcm90b3R5cGUuc2V0UHJvdmlkZXI9ZnVuY3Rpb24odCl7dGhpcy5wcm92aWRlcj10fSxzLnByb3RvdHlwZS5zdGFydFBvbGxpbmc9ZnVuY3Rpb24odCxlLG4scil7dGhpcy5wb2xsc1tlXT17ZGF0YTp0LGlkOmUsY2FsbGJhY2s6bix1bmluc3RhbGw6cn0sdGhpcy50aW1lb3V0fHx0aGlzLnBvbGwoKX0scy5wcm90b3R5cGUuc3RvcFBvbGxpbmc9ZnVuY3Rpb24odCl7ZGVsZXRlIHRoaXMucG9sbHNbdF0sMD09PU9iamVjdC5rZXlzKHRoaXMucG9sbHMpLmxlbmd0aCYmdGhpcy50aW1lb3V0JiYoY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCksdGhpcy50aW1lb3V0PW51bGwpfSxzLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gdGhpcy5wb2xscyl0JiYtMSE9PWUuaW5kZXhPZigic3luY1BvbGxfIil8fCh0aGlzLnBvbGxzW2VdLnVuaW5zdGFsbCgpLGRlbGV0ZSB0aGlzLnBvbGxzW2VdKTswPT09T2JqZWN0LmtleXModGhpcy5wb2xscykubGVuZ3RoJiZ0aGlzLnRpbWVvdXQmJihjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KSx0aGlzLnRpbWVvdXQ9bnVsbCl9LHMucHJvdG90eXBlLnBvbGw9ZnVuY3Rpb24oKXtpZih0aGlzLnRpbWVvdXQ9c2V0VGltZW91dCh0aGlzLnBvbGwuYmluZCh0aGlzKSxpLkVUSF9QT0xMSU5HX1RJTUVPVVQpLDAhPT1PYmplY3Qua2V5cyh0aGlzLnBvbGxzKS5sZW5ndGgpaWYodGhpcy5wcm92aWRlcil7dmFyIHQ9W10sZT1bXTtmb3IodmFyIG4gaW4gdGhpcy5wb2xscyl0LnB1c2godGhpcy5wb2xsc1tuXS5kYXRhKSxlLnB1c2gobik7aWYoMCE9PXQubGVuZ3RoKXt2YXIgcz1yLnRvQmF0Y2hQYXlsb2FkKHQpLGM9e307cy5mb3JFYWNoKGZ1bmN0aW9uKHQsbil7Y1t0LmlkXT1lW25dfSk7dmFyIHU9dGhpczt0aGlzLnByb3ZpZGVyLnNlbmRBc3luYyhzLGZ1bmN0aW9uKHQsZSl7aWYoIXQpe2lmKCFvLmlzQXJyYXkoZSkpdGhyb3cgYS5JbnZhbGlkUmVzcG9uc2UoZSk7ZS5tYXAoZnVuY3Rpb24odCl7dmFyIGU9Y1t0LmlkXTtyZXR1cm4hIXUucG9sbHNbZV0mJih0LmNhbGxiYWNrPXUucG9sbHNbZV0uY2FsbGJhY2ssdCl9KS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuISF0fSkuZmlsdGVyKGZ1bmN0aW9uKHQpe3ZhciBlPXIuaXNWYWxpZFJlc3BvbnNlKHQpO3JldHVybiBlfHx0LmNhbGxiYWNrKGEuSW52YWxpZFJlc3BvbnNlKHQpKSxlfSkuZm9yRWFjaChmdW5jdGlvbih0KXt0LmNhbGxiYWNrKG51bGwsdC5yZXN1bHQpfSl9fSl9fWVsc2UgY29uc29sZS5lcnJvcihhLkludmFsaWRQcm92aWRlcigpKX0sZS5leHBvcnRzPXN9LHsiLi4vdXRpbHMvY29uZmlnIjoxOCwiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2Vycm9ycyI6MjYsIi4vanNvbnJwYyI6MzV9XSw0NzpbZnVuY3Rpb24odCxlLG4pe2UuZXhwb3J0cz1mdW5jdGlvbigpe3RoaXMuZGVmYXVsdEJsb2NrPSJsYXRlc3QiLHRoaXMuZGVmYXVsdEFjY291bnQ9dm9pZCAwfX0se31dLDQ4OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuLi91dGlscy91dGlscyIpLGk9MSxhPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMucmVxdWVzdE1hbmFnZXI9dCx0aGlzLnBvbGxJZD0ic3luY1BvbGxfIitpKyssdGhpcy5jYWxsYmFja3M9W10sdGhpcy5hZGRDYWxsYmFjayhlKSx0aGlzLmxhc3RTeW5jU3RhdGU9ITEsZnVuY3Rpb24odCl7dC5yZXF1ZXN0TWFuYWdlci5zdGFydFBvbGxpbmcoe21ldGhvZDoiZXRoX3N5bmNpbmciLHBhcmFtczpbXX0sdC5wb2xsSWQsZnVuY3Rpb24oZSxuKXtpZihlKXJldHVybiB0LmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QoZSl9KTtvLmlzT2JqZWN0KG4pJiZuLnN0YXJ0aW5nQmxvY2smJihuPXIub3V0cHV0U3luY2luZ0Zvcm1hdHRlcihuKSksdC5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihlKXt0Lmxhc3RTeW5jU3RhdGUhPT1uJiYoIXQubGFzdFN5bmNTdGF0ZSYmby5pc09iamVjdChuKSYmZShudWxsLCEwKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZShudWxsLG4pfSwwKSx0Lmxhc3RTeW5jU3RhdGU9bil9KX0sdC5zdG9wV2F0Y2hpbmcuYmluZCh0KSl9KHRoaXMpLHRoaXN9O2EucHJvdG90eXBlLmFkZENhbGxiYWNrPWZ1bmN0aW9uKHQpe3JldHVybiB0JiZ0aGlzLmNhbGxiYWNrcy5wdXNoKHQpLHRoaXN9LGEucHJvdG90eXBlLnN0b3BXYXRjaGluZz1mdW5jdGlvbigpe3RoaXMucmVxdWVzdE1hbmFnZXIuc3RvcFBvbGxpbmcodGhpcy5wb2xsSWQpLHRoaXMuY2FsbGJhY2tzPVtdfSxlLmV4cG9ydHM9YX0seyIuLi91dGlscy91dGlscyI6MjAsIi4vZm9ybWF0dGVycyI6MzB9XSw0OTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vaWJhbiIpLG89dCgiLi4vY29udHJhY3RzL1NtYXJ0RXhjaGFuZ2UuanNvbiIpLGk9ZnVuY3Rpb24odCxlLG4scixvKXtyZXR1cm4gdC5zZW5kVHJhbnNhY3Rpb24oe2FkZHJlc3M6bixmcm9tOmUsdmFsdWU6cn0sbyl9LGE9ZnVuY3Rpb24odCxlLG4scixpLGEpe3ZhciBzPW87cmV0dXJuIHQuY29udHJhY3QocykuYXQobikuZGVwb3NpdChpLHtmcm9tOmUsdmFsdWU6cn0sYSl9O2UuZXhwb3J0cz1mdW5jdGlvbih0LGUsbixvLHMpe3ZhciBjPW5ldyByKG4pO2lmKCFjLmlzVmFsaWQoKSl0aHJvdyBuZXcgRXJyb3IoImludmFsaWQgaWJhbiBhZGRyZXNzIik7aWYoYy5pc0RpcmVjdCgpKXJldHVybiBpKHQsZSxjLmFkZHJlc3MoKSxvLHMpO2lmKCFzKXt2YXIgdT10LmljYXBOYW1lcmVnKCkuYWRkcihjLmluc3RpdHV0aW9uKCkpO3JldHVybiBhKHQsZSx1LG8sYy5jbGllbnQoKSl9dC5pY2FwTmFtZXJlZygpLmFkZHIoYy5pbnN0aXR1dGlvbigpLGZ1bmN0aW9uKG4scil7cmV0dXJuIGEodCxlLHIsbyxjLmNsaWVudCgpLHMpfSl9fSx7Ii4uL2NvbnRyYWN0cy9TbWFydEV4Y2hhbmdlLmpzb24iOjMsIi4vaWJhbiI6MzN9XSw1MDpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9lbmMtYmFzZTY0IiksdCgiLi9tZDUiKSx0KCIuL2V2cGtkZiIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2VuYy1iYXNlNjQiLCIuL21kNSIsIi4vZXZwa2RmIiwiLi9jaXBoZXItY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9dCxuPWUubGliLkJsb2NrQ2lwaGVyLHI9ZS5hbGdvLG89W10saT1bXSxhPVtdLHM9W10sYz1bXSx1PVtdLGY9W10sbD1bXSxwPVtdLGg9W107IWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MDtlPDI1NjtlKyspdFtlXT1lPDEyOD9lPDwxOmU8PDFeMjgzO3ZhciBuPTAscj0wO2ZvcihlPTA7ZTwyNTY7ZSsrKXt2YXIgZD1yXnI8PDFecjw8Ml5yPDwzXnI8PDQ7ZD1kPj4+OF4yNTUmZF45OSxvW25dPWQsaVtkXT1uO3ZhciBtPXRbbl0seT10W21dLGc9dFt5XSx2PTI1Nyp0W2RdXjE2ODQzMDA4KmQ7YVtuXT12PDwyNHx2Pj4+OCxzW25dPXY8PDE2fHY+Pj4xNixjW25dPXY8PDh8dj4+PjI0LHVbbl09djt2PTE2ODQzMDA5KmdeNjU1MzcqeV4yNTcqbV4xNjg0MzAwOCpuO2ZbZF09djw8MjR8dj4+PjgsbFtkXT12PDwxNnx2Pj4+MTYscFtkXT12PDw4fHY+Pj4yNCxoW2RdPXYsbj8obj1tXnRbdFt0W2debV1dXSxyXj10W3Rbcl1dKTpuPXI9MX19KCk7dmFyIGQ9WzAsMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjcsNTRdLG09ci5BRVM9bi5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7aWYoIXRoaXMuX25Sb3VuZHN8fHRoaXMuX2tleVByaW9yUmVzZXQhPT10aGlzLl9rZXkpe2Zvcih2YXIgdD10aGlzLl9rZXlQcmlvclJlc2V0PXRoaXMuX2tleSxlPXQud29yZHMsbj10LnNpZ0J5dGVzLzQscj00KigodGhpcy5fblJvdW5kcz1uKzYpKzEpLGk9dGhpcy5fa2V5U2NoZWR1bGU9W10sYT0wO2E8cjthKyspaWYoYTxuKWlbYV09ZVthXTtlbHNle3ZhciBzPWlbYS0xXTthJW4/bj42JiZhJW49PTQmJihzPW9bcz4+PjI0XTw8MjR8b1tzPj4+MTYmMjU1XTw8MTZ8b1tzPj4+OCYyNTVdPDw4fG9bMjU1JnNdKToocz1vWyhzPXM8PDh8cz4+PjI0KT4+PjI0XTw8MjR8b1tzPj4+MTYmMjU1XTw8MTZ8b1tzPj4+OCYyNTVdPDw4fG9bMjU1JnNdLHNePWRbYS9ufDBdPDwyNCksaVthXT1pW2Etbl1ec31mb3IodmFyIGM9dGhpcy5faW52S2V5U2NoZWR1bGU9W10sdT0wO3U8cjt1Kyspe2E9ci11O2lmKHUlNClzPWlbYV07ZWxzZSBzPWlbYS00XTtjW3VdPXU8NHx8YTw9ND9zOmZbb1tzPj4+MjRdXV5sW29bcz4+PjE2JjI1NV1dXnBbb1tzPj4+OCYyNTVdXV5oW29bMjU1JnNdXX19fSxlbmNyeXB0QmxvY2s6ZnVuY3Rpb24odCxlKXt0aGlzLl9kb0NyeXB0QmxvY2sodCxlLHRoaXMuX2tleVNjaGVkdWxlLGEscyxjLHUsbyl9LGRlY3J5cHRCbG9jazpmdW5jdGlvbih0LGUpe3ZhciBuPXRbZSsxXTt0W2UrMV09dFtlKzNdLHRbZSszXT1uLHRoaXMuX2RvQ3J5cHRCbG9jayh0LGUsdGhpcy5faW52S2V5U2NoZWR1bGUsZixsLHAsaCxpKTtuPXRbZSsxXTt0W2UrMV09dFtlKzNdLHRbZSszXT1ufSxfZG9DcnlwdEJsb2NrOmZ1bmN0aW9uKHQsZSxuLHIsbyxpLGEscyl7Zm9yKHZhciBjPXRoaXMuX25Sb3VuZHMsdT10W2VdXm5bMF0sZj10W2UrMV1eblsxXSxsPXRbZSsyXV5uWzJdLHA9dFtlKzNdXm5bM10saD00LGQ9MTtkPGM7ZCsrKXt2YXIgbT1yW3U+Pj4yNF1eb1tmPj4+MTYmMjU1XV5pW2w+Pj44JjI1NV1eYVsyNTUmcF1ebltoKytdLHk9cltmPj4+MjRdXm9bbD4+PjE2JjI1NV1eaVtwPj4+OCYyNTVdXmFbMjU1JnVdXm5baCsrXSxnPXJbbD4+PjI0XV5vW3A+Pj4xNiYyNTVdXmlbdT4+PjgmMjU1XV5hWzI1NSZmXV5uW2grK10sdj1yW3A+Pj4yNF1eb1t1Pj4+MTYmMjU1XV5pW2Y+Pj44JjI1NV1eYVsyNTUmbF1ebltoKytdO3U9bSxmPXksbD1nLHA9dn1tPShzW3U+Pj4yNF08PDI0fHNbZj4+PjE2JjI1NV08PDE2fHNbbD4+PjgmMjU1XTw8OHxzWzI1NSZwXSlebltoKytdLHk9KHNbZj4+PjI0XTw8MjR8c1tsPj4+MTYmMjU1XTw8MTZ8c1twPj4+OCYyNTVdPDw4fHNbMjU1JnVdKV5uW2grK10sZz0oc1tsPj4+MjRdPDwyNHxzW3A+Pj4xNiYyNTVdPDwxNnxzW3U+Pj44JjI1NV08PDh8c1syNTUmZl0pXm5baCsrXSx2PShzW3A+Pj4yNF08PDI0fHNbdT4+PjE2JjI1NV08PDE2fHNbZj4+PjgmMjU1XTw8OHxzWzI1NSZsXSlebltoKytdO3RbZV09bSx0W2UrMV09eSx0W2UrMl09Zyx0W2UrM109dn0sa2V5U2l6ZTo4fSk7ZS5BRVM9bi5fY3JlYXRlSGVscGVyKG0pfSgpLHQuQUVTfSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTIsIi4vZW5jLWJhc2U2NCI6NTMsIi4vZXZwa2RmIjo1NSwiLi9tZDUiOjYwfV0sNTE6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3QubGliLkNpcGhlcnx8ZnVuY3Rpb24oZSl7dmFyIG49dCxyPW4ubGliLG89ci5CYXNlLGk9ci5Xb3JkQXJyYXksYT1yLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0scz1uLmVuYyxjPShzLlV0Zjgscy5CYXNlNjQpLHU9bi5hbGdvLkV2cEtERixmPXIuQ2lwaGVyPWEuZXh0ZW5kKHtjZmc6by5leHRlbmQoKSxjcmVhdGVFbmNyeXB0b3I6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jcmVhdGUodGhpcy5fRU5DX1hGT1JNX01PREUsdCxlKX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLHQsZSl9LGluaXQ6ZnVuY3Rpb24odCxlLG4pe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChuKSx0aGlzLl94Zm9ybU1vZGU9dCx0aGlzLl9rZXk9ZSx0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7YS5yZXNldC5jYWxsKHRoaXMpLHRoaXMuX2RvUmVzZXQoKX0scHJvY2VzczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fYXBwZW5kKHQpLHRoaXMuX3Byb2Nlc3MoKX0sZmluYWxpemU6ZnVuY3Rpb24odCl7dCYmdGhpcy5fYXBwZW5kKHQpO3JldHVybiB0aGlzLl9kb0ZpbmFsaXplKCl9LGtleVNpemU6NCxpdlNpemU6NCxfRU5DX1hGT1JNX01PREU6MSxfREVDX1hGT1JNX01PREU6MixfY3JlYXRlSGVscGVyOmZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIHQ/YjpnfXJldHVybiBmdW5jdGlvbihlKXtyZXR1cm57ZW5jcnlwdDpmdW5jdGlvbihuLHIsbyl7cmV0dXJuIHQocikuZW5jcnlwdChlLG4scixvKX0sZGVjcnlwdDpmdW5jdGlvbihuLHIsbyl7cmV0dXJuIHQocikuZGVjcnlwdChlLG4scixvKX19fX0oKX0pLGw9KHIuU3RyZWFtQ2lwaGVyPWYuZXh0ZW5kKHtfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcm9jZXNzKCEwKX0sYmxvY2tTaXplOjF9KSxuLm1vZGU9e30pLHA9ci5CbG9ja0NpcGhlck1vZGU9by5leHRlbmQoe2NyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUodCxlKX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZSh0LGUpfSxpbml0OmZ1bmN0aW9uKHQsZSl7dGhpcy5fY2lwaGVyPXQsdGhpcy5faXY9ZX19KSxoPWwuQ0JDPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LG4scil7dmFyIG89dGhpcy5faXY7aWYobyl7dmFyIGk9bzt0aGlzLl9pdj1lfWVsc2UgaT10aGlzLl9wcmV2QmxvY2s7Zm9yKHZhciBhPTA7YTxyO2ErKyl0W24rYV1ePWlbYV19dmFyIG49cC5leHRlbmQoKTtyZXR1cm4gbi5FbmNyeXB0b3I9bi5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLG4pe3ZhciByPXRoaXMuX2NpcGhlcixvPXIuYmxvY2tTaXplO3QuY2FsbCh0aGlzLGUsbixvKSxyLmVuY3J5cHRCbG9jayhlLG4pLHRoaXMuX3ByZXZCbG9jaz1lLnNsaWNlKG4sbitvKX19KSxuLkRlY3J5cHRvcj1uLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGUsbil7dmFyIHI9dGhpcy5fY2lwaGVyLG89ci5ibG9ja1NpemUsaT1lLnNsaWNlKG4sbitvKTtyLmRlY3J5cHRCbG9jayhlLG4pLHQuY2FsbCh0aGlzLGUsbixvKSx0aGlzLl9wcmV2QmxvY2s9aX19KSxufSgpLGQ9KG4ucGFkPXt9KS5Qa2NzNz17cGFkOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTQqZSxyPW4tdC5zaWdCeXRlcyVuLG89cjw8MjR8cjw8MTZ8cjw8OHxyLGE9W10scz0wO3M8cjtzKz00KWEucHVzaChvKTt2YXIgYz1pLmNyZWF0ZShhLHIpO3QuY29uY2F0KGMpfSx1bnBhZDpmdW5jdGlvbih0KXt2YXIgZT0yNTUmdC53b3Jkc1t0LnNpZ0J5dGVzLTE+Pj4yXTt0LnNpZ0J5dGVzLT1lfX0sbT0oci5CbG9ja0NpcGhlcj1mLmV4dGVuZCh7Y2ZnOmYuY2ZnLmV4dGVuZCh7bW9kZTpoLHBhZGRpbmc6ZH0pLHJlc2V0OmZ1bmN0aW9uKCl7Zi5yZXNldC5jYWxsKHRoaXMpO3ZhciB0PXRoaXMuY2ZnLGU9dC5pdixuPXQubW9kZTtpZih0aGlzLl94Zm9ybU1vZGU9PXRoaXMuX0VOQ19YRk9STV9NT0RFKXZhciByPW4uY3JlYXRlRW5jcnlwdG9yO2Vsc2V7cj1uLmNyZWF0ZURlY3J5cHRvcjt0aGlzLl9taW5CdWZmZXJTaXplPTF9dGhpcy5fbW9kZT1yLmNhbGwobix0aGlzLGUmJmUud29yZHMpfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXt0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh0LGUpfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuY2ZnLnBhZGRpbmc7aWYodGhpcy5feGZvcm1Nb2RlPT10aGlzLl9FTkNfWEZPUk1fTU9ERSl7dC5wYWQodGhpcy5fZGF0YSx0aGlzLmJsb2NrU2l6ZSk7dmFyIGU9dGhpcy5fcHJvY2VzcyghMCl9ZWxzZXtlPXRoaXMuX3Byb2Nlc3MoITApO3QudW5wYWQoZSl9cmV0dXJuIGV9LGJsb2NrU2l6ZTo0fSksci5DaXBoZXJQYXJhbXM9by5leHRlbmQoe2luaXQ6ZnVuY3Rpb24odCl7dGhpcy5taXhJbih0KX0sdG9TdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuKHR8fHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyl9fSkpLHk9KG4uZm9ybWF0PXt9KS5PcGVuU1NMPXtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7dmFyIGU9dC5jaXBoZXJ0ZXh0LG49dC5zYWx0O2lmKG4pdmFyIHI9aS5jcmVhdGUoWzEzOTg4OTM2ODQsMTcwMTA3NjgzMV0pLmNvbmNhdChuKS5jb25jYXQoZSk7ZWxzZSByPWU7cmV0dXJuIHIudG9TdHJpbmcoYyl9LHBhcnNlOmZ1bmN0aW9uKHQpe3ZhciBlPWMucGFyc2UodCksbj1lLndvcmRzO2lmKDEzOTg4OTM2ODQ9PW5bMF0mJjE3MDEwNzY4MzE9PW5bMV0pe3ZhciByPWkuY3JlYXRlKG4uc2xpY2UoMiw0KSk7bi5zcGxpY2UoMCw0KSxlLnNpZ0J5dGVzLT0xNn1yZXR1cm4gbS5jcmVhdGUoe2NpcGhlcnRleHQ6ZSxzYWx0OnJ9KX19LGc9ci5TZXJpYWxpemFibGVDaXBoZXI9by5leHRlbmQoe2NmZzpvLmV4dGVuZCh7Zm9ybWF0Onl9KSxlbmNyeXB0OmZ1bmN0aW9uKHQsZSxuLHIpe3I9dGhpcy5jZmcuZXh0ZW5kKHIpO3ZhciBvPXQuY3JlYXRlRW5jcnlwdG9yKG4sciksaT1vLmZpbmFsaXplKGUpLGE9by5jZmc7cmV0dXJuIG0uY3JlYXRlKHtjaXBoZXJ0ZXh0Omksa2V5Om4saXY6YS5pdixhbGdvcml0aG06dCxtb2RlOmEubW9kZSxwYWRkaW5nOmEucGFkZGluZyxibG9ja1NpemU6dC5ibG9ja1NpemUsZm9ybWF0dGVyOnIuZm9ybWF0fSl9LGRlY3J5cHQ6ZnVuY3Rpb24odCxlLG4scil7cj10aGlzLmNmZy5leHRlbmQociksZT10aGlzLl9wYXJzZShlLHIuZm9ybWF0KTtyZXR1cm4gdC5jcmVhdGVEZWNyeXB0b3IobixyKS5maW5hbGl6ZShlLmNpcGhlcnRleHQpfSxfcGFyc2U6ZnVuY3Rpb24odCxlKXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIHQ/ZS5wYXJzZSh0LHRoaXMpOnR9fSksdj0obi5rZGY9e30pLk9wZW5TU0w9e2V4ZWN1dGU6ZnVuY3Rpb24odCxlLG4scil7cnx8KHI9aS5yYW5kb20oOCkpO3ZhciBvPXUuY3JlYXRlKHtrZXlTaXplOmUrbn0pLmNvbXB1dGUodCxyKSxhPWkuY3JlYXRlKG8ud29yZHMuc2xpY2UoZSksNCpuKTtyZXR1cm4gby5zaWdCeXRlcz00KmUsbS5jcmVhdGUoe2tleTpvLGl2OmEsc2FsdDpyfSl9fSxiPXIuUGFzc3dvcmRCYXNlZENpcGhlcj1nLmV4dGVuZCh7Y2ZnOmcuY2ZnLmV4dGVuZCh7a2RmOnZ9KSxlbmNyeXB0OmZ1bmN0aW9uKHQsZSxuLHIpe3ZhciBvPShyPXRoaXMuY2ZnLmV4dGVuZChyKSkua2RmLmV4ZWN1dGUobix0LmtleVNpemUsdC5pdlNpemUpO3IuaXY9by5pdjt2YXIgaT1nLmVuY3J5cHQuY2FsbCh0aGlzLHQsZSxvLmtleSxyKTtyZXR1cm4gaS5taXhJbihvKSxpfSxkZWNyeXB0OmZ1bmN0aW9uKHQsZSxuLHIpe3I9dGhpcy5jZmcuZXh0ZW5kKHIpLGU9dGhpcy5fcGFyc2UoZSxyLmZvcm1hdCk7dmFyIG89ci5rZGYuZXhlY3V0ZShuLHQua2V5U2l6ZSx0Lml2U2l6ZSxlLnNhbHQpO3IuaXY9by5pdjtyZXR1cm4gZy5kZWNyeXB0LmNhbGwodGhpcyx0LGUsby5rZXkscil9fSl9KCl9KX0seyIuL2NvcmUiOjUyfV0sNTI6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24odCxyKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49cigpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHIpOnQuQ3J5cHRvSlM9cigpfSh0aGlzLGZ1bmN0aW9uKCl7dmFyIHQ9dHx8ZnVuY3Rpb24odCxlKXt2YXIgbj1PYmplY3QuY3JlYXRlfHxmdW5jdGlvbigpe2Z1bmN0aW9uIHQoKXt9cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBuO3JldHVybiB0LnByb3RvdHlwZT1lLG49bmV3IHQsdC5wcm90b3R5cGU9bnVsbCxufX0oKSxyPXt9LG89ci5saWI9e30saT1vLkJhc2U9e2V4dGVuZDpmdW5jdGlvbih0KXt2YXIgZT1uKHRoaXMpO3JldHVybiB0JiZlLm1peEluKHQpLGUuaGFzT3duUHJvcGVydHkoImluaXQiKSYmdGhpcy5pbml0IT09ZS5pbml0fHwoZS5pbml0PWZ1bmN0aW9uKCl7ZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KSxlLmluaXQucHJvdG90eXBlPWUsZS4kc3VwZXI9dGhpcyxlfSxjcmVhdGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmV4dGVuZCgpO3JldHVybiB0LmluaXQuYXBwbHkodCxhcmd1bWVudHMpLHR9LGluaXQ6ZnVuY3Rpb24oKXt9LG1peEluOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0KXQuaGFzT3duUHJvcGVydHkoZSkmJih0aGlzW2VdPXRbZV0pO3QuaGFzT3duUHJvcGVydHkoInRvU3RyaW5nIikmJih0aGlzLnRvU3RyaW5nPXQudG9TdHJpbmcpfSxjbG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKX19LGE9by5Xb3JkQXJyYXk9aS5leHRlbmQoe2luaXQ6ZnVuY3Rpb24odCxlKXt0PXRoaXMud29yZHM9dHx8W10sdGhpcy5zaWdCeXRlcz12b2lkIDAhPWU/ZTo0KnQubGVuZ3RofSx0b1N0cmluZzpmdW5jdGlvbih0KXtyZXR1cm4odHx8Yykuc3RyaW5naWZ5KHRoaXMpfSxjb25jYXQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy53b3JkcyxuPXQud29yZHMscj10aGlzLnNpZ0J5dGVzLG89dC5zaWdCeXRlcztpZih0aGlzLmNsYW1wKCksciU0KWZvcih2YXIgaT0wO2k8bztpKyspe3ZhciBhPW5baT4+PjJdPj4+MjQtaSU0KjgmMjU1O2VbcitpPj4+Ml18PWE8PDI0LShyK2kpJTQqOH1lbHNlIGZvcihpPTA7aTxvO2krPTQpZVtyK2k+Pj4yXT1uW2k+Pj4yXTtyZXR1cm4gdGhpcy5zaWdCeXRlcys9byx0aGlzfSxjbGFtcDpmdW5jdGlvbigpe3ZhciBlPXRoaXMud29yZHMsbj10aGlzLnNpZ0J5dGVzO2Vbbj4+PjJdJj00Mjk0OTY3Mjk1PDwzMi1uJTQqOCxlLmxlbmd0aD10LmNlaWwobi80KX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1pLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQud29yZHM9dGhpcy53b3Jkcy5zbGljZSgwKSx0fSxyYW5kb206ZnVuY3Rpb24oZSl7Zm9yKHZhciBuLHI9W10sbz1mdW5jdGlvbihlKXtlPWU7dmFyIG49OTg3NjU0MzIxO3JldHVybiBmdW5jdGlvbigpe3ZhciByPSgobj0zNjk2OSooNjU1MzUmbikrKG4+PjE2KSY0Mjk0OTY3Mjk1KTw8MTYpKyhlPTE4ZTMqKDY1NTM1JmUpKyhlPj4xNikmNDI5NDk2NzI5NSkmNDI5NDk2NzI5NTtyZXR1cm4gci89NDI5NDk2NzI5Niwocis9LjUpKih0LnJhbmRvbSgpPi41PzE6LTEpfX0saT0wO2k8ZTtpKz00KXt2YXIgcz1vKDQyOTQ5NjcyOTYqKG58fHQucmFuZG9tKCkpKTtuPTk4NzY1NDA3MSpzKCksci5wdXNoKDQyOTQ5NjcyOTYqcygpfDApfXJldHVybiBuZXcgYS5pbml0KHIsZSl9fSkscz1yLmVuYz17fSxjPXMuSGV4PXtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQud29yZHMsbj10LnNpZ0J5dGVzLHI9W10sbz0wO288bjtvKyspe3ZhciBpPWVbbz4+PjJdPj4+MjQtbyU0KjgmMjU1O3IucHVzaCgoaT4+PjQpLnRvU3RyaW5nKDE2KSksci5wdXNoKCgxNSZpKS50b1N0cmluZygxNikpfXJldHVybiByLmpvaW4oIiIpfSxwYXJzZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5sZW5ndGgsbj1bXSxyPTA7cjxlO3IrPTIpbltyPj4+M118PXBhcnNlSW50KHQuc3Vic3RyKHIsMiksMTYpPDwyNC1yJTgqNDtyZXR1cm4gbmV3IGEuaW5pdChuLGUvMil9fSx1PXMuTGF0aW4xPXtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQud29yZHMsbj10LnNpZ0J5dGVzLHI9W10sbz0wO288bjtvKyspe3ZhciBpPWVbbz4+PjJdPj4+MjQtbyU0KjgmMjU1O3IucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpKX1yZXR1cm4gci5qb2luKCIiKX0scGFyc2U6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoLG49W10scj0wO3I8ZTtyKyspbltyPj4+Ml18PSgyNTUmdC5jaGFyQ29kZUF0KHIpKTw8MjQtciU0Kjg7cmV0dXJuIG5ldyBhLmluaXQobixlKX19LGY9cy5VdGY4PXtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHUuc3RyaW5naWZ5KHQpKSl9Y2F0Y2godCl7dGhyb3cgbmV3IEVycm9yKCJNYWxmb3JtZWQgVVRGLTggZGF0YSIpfX0scGFyc2U6ZnVuY3Rpb24odCl7cmV0dXJuIHUucGFyc2UodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHQpKSl9fSxsPW8uQnVmZmVyZWRCbG9ja0FsZ29yaXRobT1pLmV4dGVuZCh7cmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9kYXRhPW5ldyBhLmluaXQsdGhpcy5fbkRhdGFCeXRlcz0wfSxfYXBwZW5kOmZ1bmN0aW9uKHQpeyJzdHJpbmciPT10eXBlb2YgdCYmKHQ9Zi5wYXJzZSh0KSksdGhpcy5fZGF0YS5jb25jYXQodCksdGhpcy5fbkRhdGFCeXRlcys9dC5zaWdCeXRlc30sX3Byb2Nlc3M6ZnVuY3Rpb24oZSl7dmFyIG49dGhpcy5fZGF0YSxyPW4ud29yZHMsbz1uLnNpZ0J5dGVzLGk9dGhpcy5ibG9ja1NpemUscz1vLyg0KmkpLGM9KHM9ZT90LmNlaWwocyk6dC5tYXgoKDB8cyktdGhpcy5fbWluQnVmZmVyU2l6ZSwwKSkqaSx1PXQubWluKDQqYyxvKTtpZihjKXtmb3IodmFyIGY9MDtmPGM7Zis9aSl0aGlzLl9kb1Byb2Nlc3NCbG9jayhyLGYpO3ZhciBsPXIuc3BsaWNlKDAsYyk7bi5zaWdCeXRlcy09dX1yZXR1cm4gbmV3IGEuaW5pdChsLHUpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PWkuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5fZGF0YT10aGlzLl9kYXRhLmNsb25lKCksdH0sX21pbkJ1ZmZlclNpemU6MH0pLHA9KG8uSGFzaGVyPWwuZXh0ZW5kKHtjZmc6aS5leHRlbmQoKSxpbml0OmZ1bmN0aW9uKHQpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZCh0KSx0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7bC5yZXNldC5jYWxsKHRoaXMpLHRoaXMuX2RvUmVzZXQoKX0sdXBkYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9hcHBlbmQodCksdGhpcy5fcHJvY2VzcygpLHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKHQpe3QmJnRoaXMuX2FwcGVuZCh0KTtyZXR1cm4gdGhpcy5fZG9GaW5hbGl6ZSgpfSxibG9ja1NpemU6MTYsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuKXtyZXR1cm4gbmV3IHQuaW5pdChuKS5maW5hbGl6ZShlKX19LF9jcmVhdGVIbWFjSGVscGVyOmZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLG4pe3JldHVybiBuZXcgcC5ITUFDLmluaXQodCxuKS5maW5hbGl6ZShlKX19fSksci5hbGdvPXt9KTtyZXR1cm4gcn0oTWF0aCk7cmV0dXJuIHR9KX0se31dLDUzOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10LG49ZS5saWIuV29yZEFycmF5O2UuZW5jLkJhc2U2ND17c3RyaW5naWZ5OmZ1bmN0aW9uKHQpe3ZhciBlPXQud29yZHMsbj10LnNpZ0J5dGVzLHI9dGhpcy5fbWFwO3QuY2xhbXAoKTtmb3IodmFyIG89W10saT0wO2k8bjtpKz0zKWZvcih2YXIgYT0oZVtpPj4+Ml0+Pj4yNC1pJTQqOCYyNTUpPDwxNnwoZVtpKzE+Pj4yXT4+PjI0LShpKzEpJTQqOCYyNTUpPDw4fGVbaSsyPj4+Ml0+Pj4yNC0oaSsyKSU0KjgmMjU1LHM9MDtzPDQmJmkrLjc1KnM8bjtzKyspby5wdXNoKHIuY2hhckF0KGE+Pj42KigzLXMpJjYzKSk7dmFyIGM9ci5jaGFyQXQoNjQpO2lmKGMpZm9yKDtvLmxlbmd0aCU0OylvLnB1c2goYyk7cmV0dXJuIG8uam9pbigiIil9LHBhcnNlOmZ1bmN0aW9uKHQpe3ZhciBlPXQubGVuZ3RoLHI9dGhpcy5fbWFwLG89dGhpcy5fcmV2ZXJzZU1hcDtpZighbyl7bz10aGlzLl9yZXZlcnNlTWFwPVtdO2Zvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKW9bci5jaGFyQ29kZUF0KGkpXT1pfXZhciBhPXIuY2hhckF0KDY0KTtpZihhKXt2YXIgcz10LmluZGV4T2YoYSk7LTEhPT1zJiYoZT1zKX1yZXR1cm4gZnVuY3Rpb24odCxlLHIpe2Zvcih2YXIgbz1bXSxpPTAsYT0wO2E8ZTthKyspaWYoYSU0KXt2YXIgcz1yW3QuY2hhckNvZGVBdChhLTEpXTw8YSU0KjIsYz1yW3QuY2hhckNvZGVBdChhKV0+Pj42LWElNCoyO29baT4+PjJdfD0oc3xjKTw8MjQtaSU0KjgsaSsrfXJldHVybiBuLmNyZWF0ZShvLGkpfSh0LGUsbyl9LF9tYXA6IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89In19KCksdC5lbmMuQmFzZTY0fSl9LHsiLi9jb3JlIjo1Mn1dLDU0OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe3JldHVybiB0PDw4JjQyNzgyNTUzNjB8dD4+PjgmMTY3MTE5MzV9dmFyIG49dCxyPW4ubGliLldvcmRBcnJheSxvPW4uZW5jO28uVXRmMTY9by5VdGYxNkJFPXtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQud29yZHMsbj10LnNpZ0J5dGVzLHI9W10sbz0wO288bjtvKz0yKXt2YXIgaT1lW28+Pj4yXT4+PjE2LW8lNCo4JjY1NTM1O3IucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpKX1yZXR1cm4gci5qb2luKCIiKX0scGFyc2U6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoLG49W10sbz0wO288ZTtvKyspbltvPj4+MV18PXQuY2hhckNvZGVBdChvKTw8MTYtbyUyKjE2O3JldHVybiByLmNyZWF0ZShuLDIqZSl9fTtvLlV0ZjE2TEU9e3N0cmluZ2lmeTpmdW5jdGlvbih0KXtmb3IodmFyIG49dC53b3JkcyxyPXQuc2lnQnl0ZXMsbz1bXSxpPTA7aTxyO2krPTIpe3ZhciBhPWUobltpPj4+Ml0+Pj4xNi1pJTQqOCY2NTUzNSk7by5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYSkpfXJldHVybiBvLmpvaW4oIiIpfSxwYXJzZTpmdW5jdGlvbih0KXtmb3IodmFyIG49dC5sZW5ndGgsbz1bXSxpPTA7aTxuO2krKylvW2k+Pj4xXXw9ZSh0LmNoYXJDb2RlQXQoaSk8PDE2LWklMioxNik7cmV0dXJuIHIuY3JlYXRlKG8sMipuKX19fSgpLHQuZW5jLlV0ZjE2fSl9LHsiLi9jb3JlIjo1Mn1dLDU1OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL3NoYTEiKSx0KCIuL2htYWMiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL3NoYTEiLCIuL2htYWMiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXQsbj1lLmxpYixyPW4uQmFzZSxvPW4uV29yZEFycmF5LGk9ZS5hbGdvLGE9aS5NRDUscz1pLkV2cEtERj1yLmV4dGVuZCh7Y2ZnOnIuZXh0ZW5kKHtrZXlTaXplOjQsaGFzaGVyOmEsaXRlcmF0aW9uczoxfSksaW5pdDpmdW5jdGlvbih0KXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQodCl9LGNvbXB1dGU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5jZmcscj1uLmhhc2hlci5jcmVhdGUoKSxpPW8uY3JlYXRlKCksYT1pLndvcmRzLHM9bi5rZXlTaXplLGM9bi5pdGVyYXRpb25zO2EubGVuZ3RoPHM7KXt1JiZyLnVwZGF0ZSh1KTt2YXIgdT1yLnVwZGF0ZSh0KS5maW5hbGl6ZShlKTtyLnJlc2V0KCk7Zm9yKHZhciBmPTE7ZjxjO2YrKyl1PXIuZmluYWxpemUodSksci5yZXNldCgpO2kuY29uY2F0KHUpfXJldHVybiBpLnNpZ0J5dGVzPTQqcyxpfX0pO2UuRXZwS0RGPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gcy5jcmVhdGUobikuY29tcHV0ZSh0LGUpfX0oKSx0LkV2cEtERn0pfSx7Ii4vY29yZSI6NTIsIi4vaG1hYyI6NTcsIi4vc2hhMSI6NzZ9XSw1NjpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgbj10LHI9bi5saWIuQ2lwaGVyUGFyYW1zLG89bi5lbmMuSGV4O24uZm9ybWF0LkhleD17c3RyaW5naWZ5OmZ1bmN0aW9uKHQpe3JldHVybiB0LmNpcGhlcnRleHQudG9TdHJpbmcobyl9LHBhcnNlOmZ1bmN0aW9uKHQpe3ZhciBlPW8ucGFyc2UodCk7cmV0dXJuIHIuY3JlYXRlKHtjaXBoZXJ0ZXh0OmV9KX19fSgpLHQuZm9ybWF0LkhleH0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyfV0sNTc6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpeyFmdW5jdGlvbigpe3ZhciBlPXQsbj1lLmxpYi5CYXNlLHI9ZS5lbmMuVXRmODtlLmFsZ28uSE1BQz1uLmV4dGVuZCh7aW5pdDpmdW5jdGlvbih0LGUpe3Q9dGhpcy5faGFzaGVyPW5ldyB0LmluaXQsInN0cmluZyI9PXR5cGVvZiBlJiYoZT1yLnBhcnNlKGUpKTt2YXIgbj10LmJsb2NrU2l6ZSxvPTQqbjtlLnNpZ0J5dGVzPm8mJihlPXQuZmluYWxpemUoZSkpLGUuY2xhbXAoKTtmb3IodmFyIGk9dGhpcy5fb0tleT1lLmNsb25lKCksYT10aGlzLl9pS2V5PWUuY2xvbmUoKSxzPWkud29yZHMsYz1hLndvcmRzLHU9MDt1PG47dSsrKXNbdV1ePTE1NDk1NTY4MjgsY1t1XV49OTA5NTIyNDg2O2kuc2lnQnl0ZXM9YS5zaWdCeXRlcz1vLHRoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9oYXNoZXI7dC5yZXNldCgpLHQudXBkYXRlKHRoaXMuX2lLZXkpfSx1cGRhdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2hhc2hlci51cGRhdGUodCksdGhpc30sZmluYWxpemU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5faGFzaGVyLG49ZS5maW5hbGl6ZSh0KTtlLnJlc2V0KCk7cmV0dXJuIGUuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChuKSl9fSl9KCl9KX0seyIuL2NvcmUiOjUyfV0sNTg6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4veDY0LWNvcmUiKSx0KCIuL2xpYi10eXBlZGFycmF5cyIpLHQoIi4vZW5jLXV0ZjE2IiksdCgiLi9lbmMtYmFzZTY0IiksdCgiLi9tZDUiKSx0KCIuL3NoYTEiKSx0KCIuL3NoYTI1NiIpLHQoIi4vc2hhMjI0IiksdCgiLi9zaGE1MTIiKSx0KCIuL3NoYTM4NCIpLHQoIi4vc2hhMyIpLHQoIi4vcmlwZW1kMTYwIiksdCgiLi9obWFjIiksdCgiLi9wYmtkZjIiKSx0KCIuL2V2cGtkZiIpLHQoIi4vY2lwaGVyLWNvcmUiKSx0KCIuL21vZGUtY2ZiIiksdCgiLi9tb2RlLWN0ciIpLHQoIi4vbW9kZS1jdHItZ2xhZG1hbiIpLHQoIi4vbW9kZS1vZmIiKSx0KCIuL21vZGUtZWNiIiksdCgiLi9wYWQtYW5zaXg5MjMiKSx0KCIuL3BhZC1pc28xMDEyNiIpLHQoIi4vcGFkLWlzbzk3OTcxIiksdCgiLi9wYWQtemVyb3BhZGRpbmciKSx0KCIuL3BhZC1ub3BhZGRpbmciKSx0KCIuL2Zvcm1hdC1oZXgiKSx0KCIuL2FlcyIpLHQoIi4vdHJpcGxlZGVzIiksdCgiLi9yYzQiKSx0KCIuL3JhYmJpdCIpLHQoIi4vcmFiYml0LWxlZ2FjeSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4veDY0LWNvcmUiLCIuL2xpYi10eXBlZGFycmF5cyIsIi4vZW5jLXV0ZjE2IiwiLi9lbmMtYmFzZTY0IiwiLi9tZDUiLCIuL3NoYTEiLCIuL3NoYTI1NiIsIi4vc2hhMjI0IiwiLi9zaGE1MTIiLCIuL3NoYTM4NCIsIi4vc2hhMyIsIi4vcmlwZW1kMTYwIiwiLi9obWFjIiwiLi9wYmtkZjIiLCIuL2V2cGtkZiIsIi4vY2lwaGVyLWNvcmUiLCIuL21vZGUtY2ZiIiwiLi9tb2RlLWN0ciIsIi4vbW9kZS1jdHItZ2xhZG1hbiIsIi4vbW9kZS1vZmIiLCIuL21vZGUtZWNiIiwiLi9wYWQtYW5zaXg5MjMiLCIuL3BhZC1pc28xMDEyNiIsIi4vcGFkLWlzbzk3OTcxIiwiLi9wYWQtemVyb3BhZGRpbmciLCIuL3BhZC1ub3BhZGRpbmciLCIuL2Zvcm1hdC1oZXgiLCIuL2FlcyIsIi4vdHJpcGxlZGVzIiwiLi9yYzQiLCIuL3JhYmJpdCIsIi4vcmFiYml0LWxlZ2FjeSJdLG8pOnIuQ3J5cHRvSlM9byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdH0pfSx7Ii4vYWVzIjo1MCwiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTIsIi4vZW5jLWJhc2U2NCI6NTMsIi4vZW5jLXV0ZjE2Ijo1NCwiLi9ldnBrZGYiOjU1LCIuL2Zvcm1hdC1oZXgiOjU2LCIuL2htYWMiOjU3LCIuL2xpYi10eXBlZGFycmF5cyI6NTksIi4vbWQ1Ijo2MCwiLi9tb2RlLWNmYiI6NjEsIi4vbW9kZS1jdHIiOjYzLCIuL21vZGUtY3RyLWdsYWRtYW4iOjYyLCIuL21vZGUtZWNiIjo2NCwiLi9tb2RlLW9mYiI6NjUsIi4vcGFkLWFuc2l4OTIzIjo2NiwiLi9wYWQtaXNvMTAxMjYiOjY3LCIuL3BhZC1pc285Nzk3MSI6NjgsIi4vcGFkLW5vcGFkZGluZyI6NjksIi4vcGFkLXplcm9wYWRkaW5nIjo3MCwiLi9wYmtkZjIiOjcxLCIuL3JhYmJpdCI6NzMsIi4vcmFiYml0LWxlZ2FjeSI6NzIsIi4vcmM0Ijo3NCwiLi9yaXBlbWQxNjAiOjc1LCIuL3NoYTEiOjc2LCIuL3NoYTIyNCI6NzcsIi4vc2hhMjU2Ijo3OCwiLi9zaGEzIjo3OSwiLi9zaGEzODQiOjgwLCIuL3NoYTUxMiI6ODEsIi4vdHJpcGxlZGVzIjo4MiwiLi94NjQtY29yZSI6ODN9XSw1OTpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8peyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoImZ1bmN0aW9uIj09dHlwZW9mIEFycmF5QnVmZmVyKXt2YXIgZT10LmxpYi5Xb3JkQXJyYXksbj1lLmluaXQ7KGUuaW5pdD1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJih0PW5ldyBVaW50OEFycmF5KHQpKSwodCBpbnN0YW5jZW9mIEludDhBcnJheXx8InVuZGVmaW5lZCIhPXR5cGVvZiBVaW50OENsYW1wZWRBcnJheSYmdCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5fHx0IGluc3RhbmNlb2YgSW50MTZBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQxNkFycmF5fHx0IGluc3RhbmNlb2YgSW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQzMkFycmF5fHx0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5fHx0IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSYmKHQ9bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCkpLHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KXtmb3IodmFyIGU9dC5ieXRlTGVuZ3RoLHI9W10sbz0wO288ZTtvKyspcltvPj4+Ml18PXRbb108PDI0LW8lNCo4O24uY2FsbCh0aGlzLHIsZSl9ZWxzZSBuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pLnByb3RvdHlwZT1lfX0oKSx0LmxpYi5Xb3JkQXJyYXl9KX0seyIuL2NvcmUiOjUyfV0sNjA6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiBuKHQsZSxuLHIsbyxpLGEpe3ZhciBzPXQrKGUmbnx+ZSZyKStvK2E7cmV0dXJuKHM8PGl8cz4+PjMyLWkpK2V9ZnVuY3Rpb24gcih0LGUsbixyLG8saSxhKXt2YXIgcz10KyhlJnJ8biZ+cikrbythO3JldHVybihzPDxpfHM+Pj4zMi1pKStlfWZ1bmN0aW9uIG8odCxlLG4scixvLGksYSl7dmFyIHM9dCsoZV5uXnIpK28rYTtyZXR1cm4oczw8aXxzPj4+MzItaSkrZX1mdW5jdGlvbiBpKHQsZSxuLHIsbyxpLGEpe3ZhciBzPXQrKG5eKGV8fnIpKStvK2E7cmV0dXJuKHM8PGl8cz4+PjMyLWkpK2V9dmFyIGE9dCxzPWEubGliLGM9cy5Xb3JkQXJyYXksdT1zLkhhc2hlcixmPWEuYWxnbyxsPVtdOyFmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8NjQ7dCsrKWxbdF09NDI5NDk2NzI5NiplLmFicyhlLnNpbih0KzEpKXwwfSgpO3ZhciBwPWYuTUQ1PXUuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IGMuaW5pdChbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4XSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe2Zvcih2YXIgYT0wO2E8MTY7YSsrKXt2YXIgcz1lK2EsYz10W3NdO3Rbc109MTY3MTE5MzUmKGM8PDh8Yz4+PjI0KXw0Mjc4MjU1MzYwJihjPDwyNHxjPj4+OCl9dmFyIHU9dGhpcy5faGFzaC53b3JkcyxmPXRbZSswXSxwPXRbZSsxXSxoPXRbZSsyXSxkPXRbZSszXSxtPXRbZSs0XSx5PXRbZSs1XSxnPXRbZSs2XSx2PXRbZSs3XSxiPXRbZSs4XSxfPXRbZSs5XSx3PXRbZSsxMF0seD10W2UrMTFdLGs9dFtlKzEyXSxCPXRbZSsxM10sUz10W2UrMTRdLEE9dFtlKzE1XSxDPXVbMF0sRj11WzFdLE89dVsyXSxJPXVbM107Rj1pKEY9aShGPWkoRj1pKEY9byhGPW8oRj1vKEY9byhGPXIoRj1yKEY9cihGPXIoRj1uKEY9bihGPW4oRj1uKEYsTz1uKE8sST1uKEksQz1uKEMsRixPLEksZiw3LGxbMF0pLEYsTyxwLDEyLGxbMV0pLEMsRixoLDE3LGxbMl0pLEksQyxkLDIyLGxbM10pLE89bihPLEk9bihJLEM9bihDLEYsTyxJLG0sNyxsWzRdKSxGLE8seSwxMixsWzVdKSxDLEYsZywxNyxsWzZdKSxJLEMsdiwyMixsWzddKSxPPW4oTyxJPW4oSSxDPW4oQyxGLE8sSSxiLDcsbFs4XSksRixPLF8sMTIsbFs5XSksQyxGLHcsMTcsbFsxMF0pLEksQyx4LDIyLGxbMTFdKSxPPW4oTyxJPW4oSSxDPW4oQyxGLE8sSSxrLDcsbFsxMl0pLEYsTyxCLDEyLGxbMTNdKSxDLEYsUywxNyxsWzE0XSksSSxDLEEsMjIsbFsxNV0pLE89cihPLEk9cihJLEM9cihDLEYsTyxJLHAsNSxsWzE2XSksRixPLGcsOSxsWzE3XSksQyxGLHgsMTQsbFsxOF0pLEksQyxmLDIwLGxbMTldKSxPPXIoTyxJPXIoSSxDPXIoQyxGLE8sSSx5LDUsbFsyMF0pLEYsTyx3LDksbFsyMV0pLEMsRixBLDE0LGxbMjJdKSxJLEMsbSwyMCxsWzIzXSksTz1yKE8sST1yKEksQz1yKEMsRixPLEksXyw1LGxbMjRdKSxGLE8sUyw5LGxbMjVdKSxDLEYsZCwxNCxsWzI2XSksSSxDLGIsMjAsbFsyN10pLE89cihPLEk9cihJLEM9cihDLEYsTyxJLEIsNSxsWzI4XSksRixPLGgsOSxsWzI5XSksQyxGLHYsMTQsbFszMF0pLEksQyxrLDIwLGxbMzFdKSxPPW8oTyxJPW8oSSxDPW8oQyxGLE8sSSx5LDQsbFszMl0pLEYsTyxiLDExLGxbMzNdKSxDLEYseCwxNixsWzM0XSksSSxDLFMsMjMsbFszNV0pLE89byhPLEk9byhJLEM9byhDLEYsTyxJLHAsNCxsWzM2XSksRixPLG0sMTEsbFszN10pLEMsRix2LDE2LGxbMzhdKSxJLEMsdywyMyxsWzM5XSksTz1vKE8sST1vKEksQz1vKEMsRixPLEksQiw0LGxbNDBdKSxGLE8sZiwxMSxsWzQxXSksQyxGLGQsMTYsbFs0Ml0pLEksQyxnLDIzLGxbNDNdKSxPPW8oTyxJPW8oSSxDPW8oQyxGLE8sSSxfLDQsbFs0NF0pLEYsTyxrLDExLGxbNDVdKSxDLEYsQSwxNixsWzQ2XSksSSxDLGgsMjMsbFs0N10pLE89aShPLEk9aShJLEM9aShDLEYsTyxJLGYsNixsWzQ4XSksRixPLHYsMTAsbFs0OV0pLEMsRixTLDE1LGxbNTBdKSxJLEMseSwyMSxsWzUxXSksTz1pKE8sST1pKEksQz1pKEMsRixPLEksayw2LGxbNTJdKSxGLE8sZCwxMCxsWzUzXSksQyxGLHcsMTUsbFs1NF0pLEksQyxwLDIxLGxbNTVdKSxPPWkoTyxJPWkoSSxDPWkoQyxGLE8sSSxiLDYsbFs1Nl0pLEYsTyxBLDEwLGxbNTddKSxDLEYsZywxNSxsWzU4XSksSSxDLEIsMjEsbFs1OV0pLE89aShPLEk9aShJLEM9aShDLEYsTyxJLG0sNixsWzYwXSksRixPLHgsMTAsbFs2MV0pLEMsRixoLDE1LGxbNjJdKSxJLEMsXywyMSxsWzYzXSksdVswXT11WzBdK0N8MCx1WzFdPXVbMV0rRnwwLHVbMl09dVsyXStPfDAsdVszXT11WzNdK0l8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9kYXRhLG49dC53b3JkcyxyPTgqdGhpcy5fbkRhdGFCeXRlcyxvPTgqdC5zaWdCeXRlcztuW28+Pj41XXw9MTI4PDwyNC1vJTMyO3ZhciBpPWUuZmxvb3Ioci80Mjk0OTY3Mjk2KSxhPXI7blsxNSsobys2ND4+Pjk8PDQpXT0xNjcxMTkzNSYoaTw8OHxpPj4+MjQpfDQyNzgyNTUzNjAmKGk8PDI0fGk+Pj44KSxuWzE0KyhvKzY0Pj4+OTw8NCldPTE2NzExOTM1JihhPDw4fGE+Pj4yNCl8NDI3ODI1NTM2MCYoYTw8MjR8YT4+PjgpLHQuc2lnQnl0ZXM9NCoobi5sZW5ndGgrMSksdGhpcy5fcHJvY2VzcygpO2Zvcih2YXIgcz10aGlzLl9oYXNoLGM9cy53b3Jkcyx1PTA7dTw0O3UrKyl7dmFyIGY9Y1t1XTtjW3VdPTE2NzExOTM1JihmPDw4fGY+Pj4yNCl8NDI3ODI1NTM2MCYoZjw8MjR8Zj4+PjgpfXJldHVybiBzfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PXUuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5faGFzaD10aGlzLl9oYXNoLmNsb25lKCksdH19KTthLk1ENT11Ll9jcmVhdGVIZWxwZXIocCksYS5IbWFjTUQ1PXUuX2NyZWF0ZUhtYWNIZWxwZXIocCl9KE1hdGgpLHQuTUQ1fSl9LHsiLi9jb3JlIjo1Mn1dLDYxOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL2NpcGhlci1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9jaXBoZXItY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIHQubW9kZS5DRkI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsZSxuLHIpe3ZhciBvPXRoaXMuX2l2O2lmKG8pe3ZhciBpPW8uc2xpY2UoMCk7dGhpcy5faXY9dm9pZCAwfWVsc2UgaT10aGlzLl9wcmV2QmxvY2s7ci5lbmNyeXB0QmxvY2soaSwwKTtmb3IodmFyIGE9MDthPG47YSsrKXRbZSthXV49aVthXX12YXIgbj10LmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7cmV0dXJuIG4uRW5jcnlwdG9yPW4uZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxuKXt2YXIgcj10aGlzLl9jaXBoZXIsbz1yLmJsb2NrU2l6ZTtlLmNhbGwodGhpcyx0LG4sbyxyKSx0aGlzLl9wcmV2QmxvY2s9dC5zbGljZShuLG4rbyl9fSksbi5EZWNyeXB0b3I9bi5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LG4pe3ZhciByPXRoaXMuX2NpcGhlcixvPXIuYmxvY2tTaXplLGk9dC5zbGljZShuLG4rbyk7ZS5jYWxsKHRoaXMsdCxuLG8sciksdGhpcy5fcHJldkJsb2NrPWl9fSksbn0oKSx0Lm1vZGUuQ0ZCfSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw2MjpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1vZGUuQ1RSR2xhZG1hbj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUodCl7aWYoMjU1PT0odD4+MjQmMjU1KSl7dmFyIGU9dD4+MTYmMjU1LG49dD4+OCYyNTUscj0yNTUmdDsyNTU9PT1lPyhlPTAsMjU1PT09bj8obj0wLDI1NT09PXI/cj0wOisrcik6KytuKTorK2UsdD0wLHQrPWU8PDE2LHQrPW48PDgsdCs9cn1lbHNlIHQrPTE8PDI0O3JldHVybiB0fXZhciBuPXQubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKSxyPW4uRW5jcnlwdG9yPW4uZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxuKXt2YXIgcj10aGlzLl9jaXBoZXIsbz1yLmJsb2NrU2l6ZSxpPXRoaXMuX2l2LGE9dGhpcy5fY291bnRlcjtpJiYoYT10aGlzLl9jb3VudGVyPWkuc2xpY2UoMCksdGhpcy5faXY9dm9pZCAwKSxmdW5jdGlvbih0KXswPT09KHRbMF09ZSh0WzBdKSkmJih0WzFdPWUodFsxXSkpfShhKTt2YXIgcz1hLnNsaWNlKDApO3IuZW5jcnlwdEJsb2NrKHMsMCk7Zm9yKHZhciBjPTA7YzxvO2MrKyl0W24rY11ePXNbY119fSk7cmV0dXJuIG4uRGVjcnlwdG9yPXIsbn0oKSx0Lm1vZGUuQ1RSR2xhZG1hbn0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyfV0sNjM6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdC5tb2RlLkNUUj1mdW5jdGlvbigpe3ZhciBlPXQubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKSxuPWUuRW5jcnlwdG9yPWUuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLl9jaXBoZXIscj1uLmJsb2NrU2l6ZSxvPXRoaXMuX2l2LGk9dGhpcy5fY291bnRlcjtvJiYoaT10aGlzLl9jb3VudGVyPW8uc2xpY2UoMCksdGhpcy5faXY9dm9pZCAwKTt2YXIgYT1pLnNsaWNlKDApO24uZW5jcnlwdEJsb2NrKGEsMCksaVtyLTFdPWlbci0xXSsxfDA7Zm9yKHZhciBzPTA7czxyO3MrKyl0W2Urc11ePWFbc119fSk7cmV0dXJuIGUuRGVjcnlwdG9yPW4sZX0oKSx0Lm1vZGUuQ1RSfSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw2NDpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1vZGUuRUNCPWZ1bmN0aW9uKCl7dmFyIGU9dC5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO3JldHVybiBlLkVuY3J5cHRvcj1lLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh0LGUpfX0pLGUuRGVjcnlwdG9yPWUuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXt0aGlzLl9jaXBoZXIuZGVjcnlwdEJsb2NrKHQsZSl9fSksZX0oKSx0Lm1vZGUuRUNCfSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw2NTpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1vZGUuT0ZCPWZ1bmN0aW9uKCl7dmFyIGU9dC5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpLG49ZS5FbmNyeXB0b3I9ZS5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuX2NpcGhlcixyPW4uYmxvY2tTaXplLG89dGhpcy5faXYsaT10aGlzLl9rZXlzdHJlYW07byYmKGk9dGhpcy5fa2V5c3RyZWFtPW8uc2xpY2UoMCksdGhpcy5faXY9dm9pZCAwKSxuLmVuY3J5cHRCbG9jayhpLDApO2Zvcih2YXIgYT0wO2E8cjthKyspdFtlK2FdXj1pW2FdfX0pO3JldHVybiBlLkRlY3J5cHRvcj1uLGV9KCksdC5tb2RlLk9GQn0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyfV0sNjY6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdC5wYWQuQW5zaVg5MjM9e3BhZDpmdW5jdGlvbih0LGUpe3ZhciBuPXQuc2lnQnl0ZXMscj00KmUsbz1yLW4lcixpPW4rby0xO3QuY2xhbXAoKSx0LndvcmRzW2k+Pj4yXXw9bzw8MjQtaSU0KjgsdC5zaWdCeXRlcys9b30sdW5wYWQ6ZnVuY3Rpb24odCl7dmFyIGU9MjU1JnQud29yZHNbdC5zaWdCeXRlcy0xPj4+Ml07dC5zaWdCeXRlcy09ZX19LHQucGFkLkFuc2l4OTIzfSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw2NzpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0LnBhZC5Jc28xMDEyNj17cGFkOmZ1bmN0aW9uKGUsbil7dmFyIHI9NCpuLG89ci1lLnNpZ0J5dGVzJXI7ZS5jb25jYXQodC5saWIuV29yZEFycmF5LnJhbmRvbShvLTEpKS5jb25jYXQodC5saWIuV29yZEFycmF5LmNyZWF0ZShbbzw8MjRdLDEpKX0sdW5wYWQ6ZnVuY3Rpb24odCl7dmFyIGU9MjU1JnQud29yZHNbdC5zaWdCeXRlcy0xPj4+Ml07dC5zaWdCeXRlcy09ZX19LHQucGFkLklzbzEwMTI2fSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw2ODpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0LnBhZC5Jc285Nzk3MT17cGFkOmZ1bmN0aW9uKGUsbil7ZS5jb25jYXQodC5saWIuV29yZEFycmF5LmNyZWF0ZShbMjE0NzQ4MzY0OF0sMSkpLHQucGFkLlplcm9QYWRkaW5nLnBhZChlLG4pfSx1bnBhZDpmdW5jdGlvbihlKXt0LnBhZC5aZXJvUGFkZGluZy51bnBhZChlKSxlLnNpZ0J5dGVzLS19fSx0LnBhZC5Jc285Nzk3MX0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyfV0sNjk6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdC5wYWQuTm9QYWRkaW5nPXtwYWQ6ZnVuY3Rpb24oKXt9LHVucGFkOmZ1bmN0aW9uKCl7fX0sdC5wYWQuTm9QYWRkaW5nfSl9LHsiLi9jaXBoZXItY29yZSI6NTEsIi4vY29yZSI6NTJ9XSw3MDpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0LnBhZC5aZXJvUGFkZGluZz17cGFkOmZ1bmN0aW9uKHQsZSl7dmFyIG49NCplO3QuY2xhbXAoKSx0LnNpZ0J5dGVzKz1uLSh0LnNpZ0J5dGVzJW58fG4pfSx1bnBhZDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC53b3JkcyxuPXQuc2lnQnl0ZXMtMTshKGVbbj4+PjJdPj4+MjQtbiU0KjgmMjU1KTspbi0tO3Quc2lnQnl0ZXM9bisxfX0sdC5wYWQuWmVyb1BhZGRpbmd9KX0seyIuL2NpcGhlci1jb3JlIjo1MSwiLi9jb3JlIjo1Mn1dLDcxOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL3NoYTEiKSx0KCIuL2htYWMiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL3NoYTEiLCIuL2htYWMiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXQsbj1lLmxpYixyPW4uQmFzZSxvPW4uV29yZEFycmF5LGk9ZS5hbGdvLGE9aS5TSEExLHM9aS5ITUFDLGM9aS5QQktERjI9ci5leHRlbmQoe2NmZzpyLmV4dGVuZCh7a2V5U2l6ZTo0LGhhc2hlcjphLGl0ZXJhdGlvbnM6MX0pLGluaXQ6ZnVuY3Rpb24odCl7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKHQpfSxjb21wdXRlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuY2ZnLHI9cy5jcmVhdGUobi5oYXNoZXIsdCksaT1vLmNyZWF0ZSgpLGE9by5jcmVhdGUoWzFdKSxjPWkud29yZHMsdT1hLndvcmRzLGY9bi5rZXlTaXplLGw9bi5pdGVyYXRpb25zO2MubGVuZ3RoPGY7KXt2YXIgcD1yLnVwZGF0ZShlKS5maW5hbGl6ZShhKTtyLnJlc2V0KCk7Zm9yKHZhciBoPXAud29yZHMsZD1oLmxlbmd0aCxtPXAseT0xO3k8bDt5Kyspe209ci5maW5hbGl6ZShtKSxyLnJlc2V0KCk7Zm9yKHZhciBnPW0ud29yZHMsdj0wO3Y8ZDt2KyspaFt2XV49Z1t2XX1pLmNvbmNhdChwKSx1WzBdKyt9cmV0dXJuIGkuc2lnQnl0ZXM9NCpmLGl9fSk7ZS5QQktERjI9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBjLmNyZWF0ZShuKS5jb21wdXRlKHQsZSl9fSgpLHQuUEJLREYyfSl9LHsiLi9jb3JlIjo1MiwiLi9obWFjIjo1NywiLi9zaGExIjo3Nn1dLDcyOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL2VuYy1iYXNlNjQiKSx0KCIuL21kNSIpLHQoIi4vZXZwa2RmIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vZW5jLWJhc2U2NCIsIi4vbWQ1IiwiLi9ldnBrZGYiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7Zm9yKHZhciB0PXRoaXMuX1gsZT10aGlzLl9DLG49MDtuPDg7bisrKWlbbl09ZVtuXTtlWzBdPWVbMF0rMTI5NTMwNzU5Nyt0aGlzLl9ifDAsZVsxXT1lWzFdKzM1NDUwNTIzNzErKGVbMF0+Pj4wPGlbMF0+Pj4wPzE6MCl8MCxlWzJdPWVbMl0rODg2MjYzMDkyKyhlWzFdPj4+MDxpWzFdPj4+MD8xOjApfDAsZVszXT1lWzNdKzEyOTUzMDc1OTcrKGVbMl0+Pj4wPGlbMl0+Pj4wPzE6MCl8MCxlWzRdPWVbNF0rMzU0NTA1MjM3MSsoZVszXT4+PjA8aVszXT4+PjA/MTowKXwwLGVbNV09ZVs1XSs4ODYyNjMwOTIrKGVbNF0+Pj4wPGlbNF0+Pj4wPzE6MCl8MCxlWzZdPWVbNl0rMTI5NTMwNzU5NysoZVs1XT4+PjA8aVs1XT4+PjA/MTowKXwwLGVbN109ZVs3XSszNTQ1MDUyMzcxKyhlWzZdPj4+MDxpWzZdPj4+MD8xOjApfDAsdGhpcy5fYj1lWzddPj4+MDxpWzddPj4+MD8xOjA7Zm9yKG49MDtuPDg7bisrKXt2YXIgcj10W25dK2Vbbl0sbz02NTUzNSZyLHM9cj4+PjE2LGM9KChvKm8+Pj4xNykrbypzPj4+MTUpK3Mqcyx1PSgoNDI5NDkwMTc2MCZyKSpyfDApKygoNjU1MzUmcikqcnwwKTthW25dPWNedX10WzBdPWFbMF0rKGFbN108PDE2fGFbN10+Pj4xNikrKGFbNl08PDE2fGFbNl0+Pj4xNil8MCx0WzFdPWFbMV0rKGFbMF08PDh8YVswXT4+PjI0KSthWzddfDAsdFsyXT1hWzJdKyhhWzFdPDwxNnxhWzFdPj4+MTYpKyhhWzBdPDwxNnxhWzBdPj4+MTYpfDAsdFszXT1hWzNdKyhhWzJdPDw4fGFbMl0+Pj4yNCkrYVsxXXwwLHRbNF09YVs0XSsoYVszXTw8MTZ8YVszXT4+PjE2KSsoYVsyXTw8MTZ8YVsyXT4+PjE2KXwwLHRbNV09YVs1XSsoYVs0XTw8OHxhWzRdPj4+MjQpK2FbM118MCx0WzZdPWFbNl0rKGFbNV08PDE2fGFbNV0+Pj4xNikrKGFbNF08PDE2fGFbNF0+Pj4xNil8MCx0WzddPWFbN10rKGFbNl08PDh8YVs2XT4+PjI0KSthWzVdfDB9dmFyIG49dCxyPW4ubGliLlN0cmVhbUNpcGhlcixvPVtdLGk9W10sYT1bXSxzPW4uYWxnby5SYWJiaXRMZWdhY3k9ci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fa2V5LndvcmRzLG49dGhpcy5jZmcuaXYscj10aGlzLl9YPVt0WzBdLHRbM108PDE2fHRbMl0+Pj4xNix0WzFdLHRbMF08PDE2fHRbM10+Pj4xNix0WzJdLHRbMV08PDE2fHRbMF0+Pj4xNix0WzNdLHRbMl08PDE2fHRbMV0+Pj4xNl0sbz10aGlzLl9DPVt0WzJdPDwxNnx0WzJdPj4+MTYsNDI5NDkwMTc2MCZ0WzBdfDY1NTM1JnRbMV0sdFszXTw8MTZ8dFszXT4+PjE2LDQyOTQ5MDE3NjAmdFsxXXw2NTUzNSZ0WzJdLHRbMF08PDE2fHRbMF0+Pj4xNiw0Mjk0OTAxNzYwJnRbMl18NjU1MzUmdFszXSx0WzFdPDwxNnx0WzFdPj4+MTYsNDI5NDkwMTc2MCZ0WzNdfDY1NTM1JnRbMF1dO3RoaXMuX2I9MDtmb3IodmFyIGk9MDtpPDQ7aSsrKWUuY2FsbCh0aGlzKTtmb3IoaT0wO2k8ODtpKyspb1tpXV49cltpKzQmN107aWYobil7dmFyIGE9bi53b3JkcyxzPWFbMF0sYz1hWzFdLHU9MTY3MTE5MzUmKHM8PDh8cz4+PjI0KXw0Mjc4MjU1MzYwJihzPDwyNHxzPj4+OCksZj0xNjcxMTkzNSYoYzw8OHxjPj4+MjQpfDQyNzgyNTUzNjAmKGM8PDI0fGM+Pj44KSxsPXU+Pj4xNnw0Mjk0OTAxNzYwJmYscD1mPDwxNnw2NTUzNSZ1O29bMF1ePXUsb1sxXV49bCxvWzJdXj1mLG9bM11ePXAsb1s0XV49dSxvWzVdXj1sLG9bNl1ePWYsb1s3XV49cDtmb3IoaT0wO2k8NDtpKyspZS5jYWxsKHRoaXMpfX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcy5fWDtlLmNhbGwodGhpcyksb1swXT1yWzBdXnJbNV0+Pj4xNl5yWzNdPDwxNixvWzFdPXJbMl1ecls3XT4+PjE2XnJbNV08PDE2LG9bMl09cls0XV5yWzFdPj4+MTZecls3XTw8MTYsb1szXT1yWzZdXnJbM10+Pj4xNl5yWzFdPDwxNjtmb3IodmFyIGk9MDtpPDQ7aSsrKW9baV09MTY3MTE5MzUmKG9baV08PDh8b1tpXT4+PjI0KXw0Mjc4MjU1MzYwJihvW2ldPDwyNHxvW2ldPj4+OCksdFtuK2ldXj1vW2ldfSxibG9ja1NpemU6NCxpdlNpemU6Mn0pO24uUmFiYml0TGVnYWN5PXIuX2NyZWF0ZUhlbHBlcihzKX0oKSx0LlJhYmJpdExlZ2FjeX0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyLCIuL2VuYy1iYXNlNjQiOjUzLCIuL2V2cGtkZiI6NTUsIi4vbWQ1Ijo2MH1dLDczOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL2VuYy1iYXNlNjQiKSx0KCIuL21kNSIpLHQoIi4vZXZwa2RmIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vZW5jLWJhc2U2NCIsIi4vbWQ1IiwiLi9ldnBrZGYiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7Zm9yKHZhciB0PXRoaXMuX1gsZT10aGlzLl9DLG49MDtuPDg7bisrKWlbbl09ZVtuXTtlWzBdPWVbMF0rMTI5NTMwNzU5Nyt0aGlzLl9ifDAsZVsxXT1lWzFdKzM1NDUwNTIzNzErKGVbMF0+Pj4wPGlbMF0+Pj4wPzE6MCl8MCxlWzJdPWVbMl0rODg2MjYzMDkyKyhlWzFdPj4+MDxpWzFdPj4+MD8xOjApfDAsZVszXT1lWzNdKzEyOTUzMDc1OTcrKGVbMl0+Pj4wPGlbMl0+Pj4wPzE6MCl8MCxlWzRdPWVbNF0rMzU0NTA1MjM3MSsoZVszXT4+PjA8aVszXT4+PjA/MTowKXwwLGVbNV09ZVs1XSs4ODYyNjMwOTIrKGVbNF0+Pj4wPGlbNF0+Pj4wPzE6MCl8MCxlWzZdPWVbNl0rMTI5NTMwNzU5NysoZVs1XT4+PjA8aVs1XT4+PjA/MTowKXwwLGVbN109ZVs3XSszNTQ1MDUyMzcxKyhlWzZdPj4+MDxpWzZdPj4+MD8xOjApfDAsdGhpcy5fYj1lWzddPj4+MDxpWzddPj4+MD8xOjA7Zm9yKG49MDtuPDg7bisrKXt2YXIgcj10W25dK2Vbbl0sbz02NTUzNSZyLHM9cj4+PjE2LGM9KChvKm8+Pj4xNykrbypzPj4+MTUpK3Mqcyx1PSgoNDI5NDkwMTc2MCZyKSpyfDApKygoNjU1MzUmcikqcnwwKTthW25dPWNedX10WzBdPWFbMF0rKGFbN108PDE2fGFbN10+Pj4xNikrKGFbNl08PDE2fGFbNl0+Pj4xNil8MCx0WzFdPWFbMV0rKGFbMF08PDh8YVswXT4+PjI0KSthWzddfDAsdFsyXT1hWzJdKyhhWzFdPDwxNnxhWzFdPj4+MTYpKyhhWzBdPDwxNnxhWzBdPj4+MTYpfDAsdFszXT1hWzNdKyhhWzJdPDw4fGFbMl0+Pj4yNCkrYVsxXXwwLHRbNF09YVs0XSsoYVszXTw8MTZ8YVszXT4+PjE2KSsoYVsyXTw8MTZ8YVsyXT4+PjE2KXwwLHRbNV09YVs1XSsoYVs0XTw8OHxhWzRdPj4+MjQpK2FbM118MCx0WzZdPWFbNl0rKGFbNV08PDE2fGFbNV0+Pj4xNikrKGFbNF08PDE2fGFbNF0+Pj4xNil8MCx0WzddPWFbN10rKGFbNl08PDh8YVs2XT4+PjI0KSthWzVdfDB9dmFyIG49dCxyPW4ubGliLlN0cmVhbUNpcGhlcixvPVtdLGk9W10sYT1bXSxzPW4uYWxnby5SYWJiaXQ9ci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX2tleS53b3JkcyxuPXRoaXMuY2ZnLml2LHI9MDtyPDQ7cisrKXRbcl09MTY3MTE5MzUmKHRbcl08PDh8dFtyXT4+PjI0KXw0Mjc4MjU1MzYwJih0W3JdPDwyNHx0W3JdPj4+OCk7dmFyIG89dGhpcy5fWD1bdFswXSx0WzNdPDwxNnx0WzJdPj4+MTYsdFsxXSx0WzBdPDwxNnx0WzNdPj4+MTYsdFsyXSx0WzFdPDwxNnx0WzBdPj4+MTYsdFszXSx0WzJdPDwxNnx0WzFdPj4+MTZdLGk9dGhpcy5fQz1bdFsyXTw8MTZ8dFsyXT4+PjE2LDQyOTQ5MDE3NjAmdFswXXw2NTUzNSZ0WzFdLHRbM108PDE2fHRbM10+Pj4xNiw0Mjk0OTAxNzYwJnRbMV18NjU1MzUmdFsyXSx0WzBdPDwxNnx0WzBdPj4+MTYsNDI5NDkwMTc2MCZ0WzJdfDY1NTM1JnRbM10sdFsxXTw8MTZ8dFsxXT4+PjE2LDQyOTQ5MDE3NjAmdFszXXw2NTUzNSZ0WzBdXTt0aGlzLl9iPTA7Zm9yKHI9MDtyPDQ7cisrKWUuY2FsbCh0aGlzKTtmb3Iocj0wO3I8ODtyKyspaVtyXV49b1tyKzQmN107aWYobil7dmFyIGE9bi53b3JkcyxzPWFbMF0sYz1hWzFdLHU9MTY3MTE5MzUmKHM8PDh8cz4+PjI0KXw0Mjc4MjU1MzYwJihzPDwyNHxzPj4+OCksZj0xNjcxMTkzNSYoYzw8OHxjPj4+MjQpfDQyNzgyNTUzNjAmKGM8PDI0fGM+Pj44KSxsPXU+Pj4xNnw0Mjk0OTAxNzYwJmYscD1mPDwxNnw2NTUzNSZ1O2lbMF1ePXUsaVsxXV49bCxpWzJdXj1mLGlbM11ePXAsaVs0XV49dSxpWzVdXj1sLGlbNl1ePWYsaVs3XV49cDtmb3Iocj0wO3I8NDtyKyspZS5jYWxsKHRoaXMpfX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcy5fWDtlLmNhbGwodGhpcyksb1swXT1yWzBdXnJbNV0+Pj4xNl5yWzNdPDwxNixvWzFdPXJbMl1ecls3XT4+PjE2XnJbNV08PDE2LG9bMl09cls0XV5yWzFdPj4+MTZecls3XTw8MTYsb1szXT1yWzZdXnJbM10+Pj4xNl5yWzFdPDwxNjtmb3IodmFyIGk9MDtpPDQ7aSsrKW9baV09MTY3MTE5MzUmKG9baV08PDh8b1tpXT4+PjI0KXw0Mjc4MjU1MzYwJihvW2ldPDwyNHxvW2ldPj4+OCksdFtuK2ldXj1vW2ldfSxibG9ja1NpemU6NCxpdlNpemU6Mn0pO24uUmFiYml0PXIuX2NyZWF0ZUhlbHBlcihzKX0oKSx0LlJhYmJpdH0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUxLCIuL2NvcmUiOjUyLCIuL2VuYy1iYXNlNjQiOjUzLCIuL2V2cGtkZiI6NTUsIi4vbWQ1Ijo2MH1dLDc0OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL2VuYy1iYXNlNjQiKSx0KCIuL21kNSIpLHQoIi4vZXZwa2RmIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vZW5jLWJhc2U2NCIsIi4vbWQ1IiwiLi9ldnBrZGYiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7Zm9yKHZhciB0PXRoaXMuX1MsZT10aGlzLl9pLG49dGhpcy5faixyPTAsbz0wO288NDtvKyspe249KG4rdFtlPShlKzEpJTI1Nl0pJTI1Njt2YXIgaT10W2VdO3RbZV09dFtuXSx0W25dPWkscnw9dFsodFtlXSt0W25dKSUyNTZdPDwyNC04Km99cmV0dXJuIHRoaXMuX2k9ZSx0aGlzLl9qPW4scn12YXIgbj10LHI9bi5saWIuU3RyZWFtQ2lwaGVyLG89bi5hbGdvLGk9by5SQzQ9ci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX2tleSxlPXQud29yZHMsbj10LnNpZ0J5dGVzLHI9dGhpcy5fUz1bXSxvPTA7bzwyNTY7bysrKXJbb109bztvPTA7Zm9yKHZhciBpPTA7bzwyNTY7bysrKXt2YXIgYT1vJW4scz1lW2E+Pj4yXT4+PjI0LWElNCo4JjI1NTtpPShpK3Jbb10rcyklMjU2O3ZhciBjPXJbb107cltvXT1yW2ldLHJbaV09Y310aGlzLl9pPXRoaXMuX2o9MH0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsbil7dFtuXV49ZS5jYWxsKHRoaXMpfSxrZXlTaXplOjgsaXZTaXplOjB9KTtuLlJDND1yLl9jcmVhdGVIZWxwZXIoaSk7dmFyIGE9by5SQzREcm9wPWkuZXh0ZW5kKHtjZmc6aS5jZmcuZXh0ZW5kKHtkcm9wOjE5Mn0pLF9kb1Jlc2V0OmZ1bmN0aW9uKCl7aS5fZG9SZXNldC5jYWxsKHRoaXMpO2Zvcih2YXIgdD10aGlzLmNmZy5kcm9wO3Q+MDt0LS0pZS5jYWxsKHRoaXMpfX0pO24uUkM0RHJvcD1yLl9jcmVhdGVIZWxwZXIoYSl9KCksdC5SQzR9KX0seyIuL2NpcGhlci1jb3JlIjo1MSwiLi9jb3JlIjo1MiwiLi9lbmMtYmFzZTY0Ijo1MywiLi9ldnBrZGYiOjU1LCIuL21kNSI6NjB9XSw3NTpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8peyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4odCxlLG4pe3JldHVybiB0XmVebn1mdW5jdGlvbiByKHQsZSxuKXtyZXR1cm4gdCZlfH50Jm59ZnVuY3Rpb24gbyh0LGUsbil7cmV0dXJuKHR8fmUpXm59ZnVuY3Rpb24gaSh0LGUsbil7cmV0dXJuIHQmbnxlJn5ufWZ1bmN0aW9uIGEodCxlLG4pe3JldHVybiB0XihlfH5uKX1mdW5jdGlvbiBzKHQsZSl7cmV0dXJuIHQ8PGV8dD4+PjMyLWV9dmFyIGM9dCx1PWMubGliLGY9dS5Xb3JkQXJyYXksbD11Lkhhc2hlcixwPWMuYWxnbyxoPWYuY3JlYXRlKFswLDEsMiwzLDQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDcsNCwxMywxLDEwLDYsMTUsMywxMiwwLDksNSwyLDE0LDExLDgsMywxMCwxNCw0LDksMTUsOCwxLDIsNywwLDYsMTMsMTEsNSwxMiwxLDksMTEsMTAsMCw4LDEyLDQsMTMsMyw3LDE1LDE0LDUsNiwyLDQsMCw1LDksNywxMiwyLDEwLDE0LDEsMyw4LDExLDYsMTUsMTNdKSxkPWYuY3JlYXRlKFs1LDE0LDcsMCw5LDIsMTEsNCwxMyw2LDE1LDgsMSwxMCwzLDEyLDYsMTEsMyw3LDAsMTMsNSwxMCwxNCwxNSw4LDEyLDQsOSwxLDIsMTUsNSwxLDMsNywxNCw2LDksMTEsOCwxMiwyLDEwLDAsNCwxMyw4LDYsNCwxLDMsMTEsMTUsMCw1LDEyLDIsMTMsOSw3LDEwLDE0LDEyLDE1LDEwLDQsMSw1LDgsNyw2LDIsMTMsMTQsMCwzLDksMTFdKSxtPWYuY3JlYXRlKFsxMSwxNCwxNSwxMiw1LDgsNyw5LDExLDEzLDE0LDE1LDYsNyw5LDgsNyw2LDgsMTMsMTEsOSw3LDE1LDcsMTIsMTUsOSwxMSw3LDEzLDEyLDExLDEzLDYsNywxNCw5LDEzLDE1LDE0LDgsMTMsNiw1LDEyLDcsNSwxMSwxMiwxNCwxNSwxNCwxNSw5LDgsOSwxNCw1LDYsOCw2LDUsMTIsOSwxNSw1LDExLDYsOCwxMywxMiw1LDEyLDEzLDE0LDExLDgsNSw2XSkseT1mLmNyZWF0ZShbOCw5LDksMTEsMTMsMTUsMTUsNSw3LDcsOCwxMSwxNCwxNCwxMiw2LDksMTMsMTUsNywxMiw4LDksMTEsNyw3LDEyLDcsNiwxNSwxMywxMSw5LDcsMTUsMTEsOCw2LDYsMTQsMTIsMTMsNSwxNCwxMywxMyw3LDUsMTUsNSw4LDExLDE0LDE0LDYsMTQsNiw5LDEyLDksMTIsNSwxNSw4LDgsNSwxMiw5LDEyLDUsMTQsNiw4LDEzLDYsNSwxNSwxMywxMSwxMV0pLGc9Zi5jcmVhdGUoWzAsMTUxODUwMDI0OSwxODU5Nzc1MzkzLDI0MDA5NTk3MDgsMjg0MDg1MzgzOF0pLHY9Zi5jcmVhdGUoWzEzNTI4Mjk5MjYsMTU0ODYwMzY4NCwxODM2MDcyNjkxLDIwNTM5OTQyMTcsMF0pLGI9cC5SSVBFTUQxNjA9bC5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1mLmNyZWF0ZShbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4LDMyODUzNzc1MjBdKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBjPTA7YzwxNjtjKyspe3ZhciB1PWUrYyxmPXRbdV07dFt1XT0xNjcxMTkzNSYoZjw8OHxmPj4+MjQpfDQyNzgyNTUzNjAmKGY8PDI0fGY+Pj44KX12YXIgbCxwLGIsXyx3LHgsayxCLFMsQSxDPXRoaXMuX2hhc2gud29yZHMsRj1nLndvcmRzLE89di53b3JkcyxJPWgud29yZHMsTj1kLndvcmRzLFQ9bS53b3JkcyxQPXkud29yZHM7eD1sPUNbMF0saz1wPUNbMV0sQj1iPUNbMl0sUz1fPUNbM10sQT13PUNbNF07dmFyIEQ7Zm9yKGM9MDtjPDgwO2MrPTEpRD1sK3RbZStJW2NdXXwwLEQrPWM8MTY/bihwLGIsXykrRlswXTpjPDMyP3IocCxiLF8pK0ZbMV06Yzw0OD9vKHAsYixfKStGWzJdOmM8NjQ/aShwLGIsXykrRlszXTphKHAsYixfKStGWzRdLEQ9KEQ9cyhEfD0wLFRbY10pKSt3fDAsbD13LHc9XyxfPXMoYiwxMCksYj1wLHA9RCxEPXgrdFtlK05bY11dfDAsRCs9YzwxNj9hKGssQixTKStPWzBdOmM8MzI/aShrLEIsUykrT1sxXTpjPDQ4P28oayxCLFMpK09bMl06Yzw2ND9yKGssQixTKStPWzNdOm4oayxCLFMpK09bNF0sRD0oRD1zKER8PTAsUFtjXSkpK0F8MCx4PUEsQT1TLFM9cyhCLDEwKSxCPWssaz1EO0Q9Q1sxXStiK1N8MCxDWzFdPUNbMl0rXytBfDAsQ1syXT1DWzNdK3creHwwLENbM109Q1s0XStsK2t8MCxDWzRdPUNbMF0rcCtCfDAsQ1swXT1EfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2RhdGEsZT10LndvcmRzLG49OCp0aGlzLl9uRGF0YUJ5dGVzLHI9OCp0LnNpZ0J5dGVzO2Vbcj4+PjVdfD0xMjg8PDI0LXIlMzIsZVsxNCsocis2ND4+Pjk8PDQpXT0xNjcxMTkzNSYobjw8OHxuPj4+MjQpfDQyNzgyNTUzNjAmKG48PDI0fG4+Pj44KSx0LnNpZ0J5dGVzPTQqKGUubGVuZ3RoKzEpLHRoaXMuX3Byb2Nlc3MoKTtmb3IodmFyIG89dGhpcy5faGFzaCxpPW8ud29yZHMsYT0wO2E8NTthKyspe3ZhciBzPWlbYV07aVthXT0xNjcxMTkzNSYoczw8OHxzPj4+MjQpfDQyNzgyNTUzNjAmKHM8PDI0fHM+Pj44KX1yZXR1cm4gb30sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1sLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpLHR9fSk7Yy5SSVBFTUQxNjA9bC5fY3JlYXRlSGVscGVyKGIpLGMuSG1hY1JJUEVNRDE2MD1sLl9jcmVhdGVIbWFjSGVscGVyKGIpfShNYXRoKSx0LlJJUEVNRDE2MH0pfSx7Ii4vY29yZSI6NTJ9XSw3NjpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8peyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9dCxuPWUubGliLHI9bi5Xb3JkQXJyYXksbz1uLkhhc2hlcixpPVtdLGE9ZS5hbGdvLlNIQTE9by5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgci5pbml0KFsxNzMyNTg0MTkzLDQwMjMyMzM0MTcsMjU2MjM4MzEwMiwyNzE3MzM4NzgsMzI4NTM3NzUyMF0pfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5faGFzaC53b3JkcyxyPW5bMF0sbz1uWzFdLGE9blsyXSxzPW5bM10sYz1uWzRdLHU9MDt1PDgwO3UrKyl7aWYodTwxNilpW3VdPTB8dFtlK3VdO2Vsc2V7dmFyIGY9aVt1LTNdXmlbdS04XV5pW3UtMTRdXmlbdS0xNl07aVt1XT1mPDwxfGY+Pj4zMX12YXIgbD0ocjw8NXxyPj4+MjcpK2MraVt1XTtsKz11PDIwPzE1MTg1MDAyNDkrKG8mYXx+byZzKTp1PDQwPzE4NTk3NzUzOTMrKG9eYV5zKTp1PDYwPyhvJmF8byZzfGEmcyktMTg5NDAwNzU4ODoob15hXnMpLTg5OTQ5NzUxNCxjPXMscz1hLGE9bzw8MzB8bz4+PjIsbz1yLHI9bH1uWzBdPW5bMF0rcnwwLG5bMV09blsxXStvfDAsblsyXT1uWzJdK2F8MCxuWzNdPW5bM10rc3wwLG5bNF09bls0XStjfDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZGF0YSxlPXQud29yZHMsbj04KnRoaXMuX25EYXRhQnl0ZXMscj04KnQuc2lnQnl0ZXM7cmV0dXJuIGVbcj4+PjVdfD0xMjg8PDI0LXIlMzIsZVsxNCsocis2ND4+Pjk8PDQpXT1NYXRoLmZsb29yKG4vNDI5NDk2NzI5NiksZVsxNSsocis2ND4+Pjk8PDQpXT1uLHQuc2lnQnl0ZXM9NCplLmxlbmd0aCx0aGlzLl9wcm9jZXNzKCksdGhpcy5faGFzaH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1vLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpLHR9fSk7ZS5TSEExPW8uX2NyZWF0ZUhlbHBlcihhKSxlLkhtYWNTSEExPW8uX2NyZWF0ZUhtYWNIZWxwZXIoYSl9KCksdC5TSEExfSl9LHsiLi9jb3JlIjo1Mn1dLDc3OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL3NoYTI1NiIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vc2hhMjU2Il0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10LG49ZS5saWIuV29yZEFycmF5LHI9ZS5hbGdvLG89ci5TSEEyNTYsaT1yLlNIQTIyND1vLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBuLmluaXQoWzMyMzgzNzEwMzIsOTE0MTUwNjYzLDgxMjcwMjk5OSw0MTQ0OTEyNjk3LDQyOTA3NzU4NTcsMTc1MDYwMzAyNSwxNjk0MDc2ODM5LDMyMDQwNzU0MjhdKX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD1vLl9kb0ZpbmFsaXplLmNhbGwodGhpcyk7cmV0dXJuIHQuc2lnQnl0ZXMtPTQsdH19KTtlLlNIQTIyND1vLl9jcmVhdGVIZWxwZXIoaSksZS5IbWFjU0hBMjI0PW8uX2NyZWF0ZUhtYWNIZWxwZXIoaSl9KCksdC5TSEEyMjR9KX0seyIuL2NvcmUiOjUyLCIuL3NoYTI1NiI6Nzh9XSw3ODpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8peyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBuPXQscj1uLmxpYixvPXIuV29yZEFycmF5LGk9ci5IYXNoZXIsYT1uLmFsZ28scz1bXSxjPVtdOyFmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7Zm9yKHZhciBuPWUuc3FydCh0KSxyPTI7cjw9bjtyKyspaWYoISh0JXIpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIG4odCl7cmV0dXJuIDQyOTQ5NjcyOTYqKHQtKDB8dCkpfDB9Zm9yKHZhciByPTIsbz0wO288NjQ7KXQocikmJihvPDgmJihzW29dPW4oZS5wb3cociwuNSkpKSxjW29dPW4oZS5wb3cociwxLzMpKSxvKyspLHIrK30oKTt2YXIgdT1bXSxmPWEuU0hBMjU2PWkuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IG8uaW5pdChzLnNsaWNlKDApKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuX2hhc2gud29yZHMscj1uWzBdLG89blsxXSxpPW5bMl0sYT1uWzNdLHM9bls0XSxmPW5bNV0sbD1uWzZdLHA9bls3XSxoPTA7aDw2NDtoKyspe2lmKGg8MTYpdVtoXT0wfHRbZStoXTtlbHNle3ZhciBkPXVbaC0xNV0sbT0oZDw8MjV8ZD4+PjcpXihkPDwxNHxkPj4+MTgpXmQ+Pj4zLHk9dVtoLTJdLGc9KHk8PDE1fHk+Pj4xNyleKHk8PDEzfHk+Pj4xOSleeT4+PjEwO3VbaF09bSt1W2gtN10rZyt1W2gtMTZdfXZhciB2PXImb15yJmlebyZpLGI9KHI8PDMwfHI+Pj4yKV4ocjw8MTl8cj4+PjEzKV4ocjw8MTB8cj4+PjIyKSxfPXArKChzPDwyNnxzPj4+NileKHM8PDIxfHM+Pj4xMSleKHM8PDd8cz4+PjI1KSkrKHMmZl5+cyZsKStjW2hdK3VbaF07cD1sLGw9ZixmPXMscz1hK198MCxhPWksaT1vLG89cixyPV8rKGIrdil8MH1uWzBdPW5bMF0rcnwwLG5bMV09blsxXStvfDAsblsyXT1uWzJdK2l8MCxuWzNdPW5bM10rYXwwLG5bNF09bls0XStzfDAsbls1XT1uWzVdK2Z8MCxuWzZdPW5bNl0rbHwwLG5bN109bls3XStwfDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZGF0YSxuPXQud29yZHMscj04KnRoaXMuX25EYXRhQnl0ZXMsbz04KnQuc2lnQnl0ZXM7cmV0dXJuIG5bbz4+PjVdfD0xMjg8PDI0LW8lMzIsblsxNCsobys2ND4+Pjk8PDQpXT1lLmZsb29yKHIvNDI5NDk2NzI5NiksblsxNSsobys2ND4+Pjk8PDQpXT1yLHQuc2lnQnl0ZXM9NCpuLmxlbmd0aCx0aGlzLl9wcm9jZXNzKCksdGhpcy5faGFzaH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1pLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpLHR9fSk7bi5TSEEyNTY9aS5fY3JlYXRlSGVscGVyKGYpLG4uSG1hY1NIQTI1Nj1pLl9jcmVhdGVIbWFjSGVscGVyKGYpfShNYXRoKSx0LlNIQTI1Nn0pfSx7Ii4vY29yZSI6NTJ9XSw3OTpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi94NjQtY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4veDY0LWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgbj10LHI9bi5saWIsbz1yLldvcmRBcnJheSxpPXIuSGFzaGVyLGE9bi54NjQuV29yZCxzPW4uYWxnbyxjPVtdLHU9W10sZj1bXTshZnVuY3Rpb24oKXtmb3IodmFyIHQ9MSxlPTAsbj0wO248MjQ7bisrKXtjW3QrNSplXT0obisxKSoobisyKS8yJTY0O3ZhciByPSgyKnQrMyplKSU1O3Q9ZSU1LGU9cn1mb3IodD0wO3Q8NTt0KyspZm9yKGU9MDtlPDU7ZSsrKXVbdCs1KmVdPWUrKDIqdCszKmUpJTUqNTtmb3IodmFyIG89MSxpPTA7aTwyNDtpKyspe2Zvcih2YXIgcz0wLGw9MCxwPTA7cDw3O3ArKyl7aWYoMSZvKXt2YXIgaD0oMTw8cCktMTtoPDMyP2xePTE8PGg6c149MTw8aC0zMn0xMjgmbz9vPW88PDFeMTEzOm88PD0xfWZbaV09YS5jcmVhdGUocyxsKX19KCk7dmFyIGw9W107IWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDwyNTt0KyspbFt0XT1hLmNyZWF0ZSgpfSgpO3ZhciBwPXMuU0hBMz1pLmV4dGVuZCh7Y2ZnOmkuY2ZnLmV4dGVuZCh7b3V0cHV0TGVuZ3RoOjUxMn0pLF9kb1Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX3N0YXRlPVtdLGU9MDtlPDI1O2UrKyl0W2VdPW5ldyBhLmluaXQ7dGhpcy5ibG9ja1NpemU9KDE2MDAtMip0aGlzLmNmZy5vdXRwdXRMZW5ndGgpLzMyfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5fc3RhdGUscj10aGlzLmJsb2NrU2l6ZS8yLG89MDtvPHI7bysrKXt2YXIgaT10W2UrMipvXSxhPXRbZSsyKm8rMV07aT0xNjcxMTkzNSYoaTw8OHxpPj4+MjQpfDQyNzgyNTUzNjAmKGk8PDI0fGk+Pj44KSxhPTE2NzExOTM1JihhPDw4fGE+Pj4yNCl8NDI3ODI1NTM2MCYoYTw8MjR8YT4+PjgpOyhGPW5bb10pLmhpZ2hePWEsRi5sb3dePWl9Zm9yKHZhciBzPTA7czwyNDtzKyspe2Zvcih2YXIgcD0wO3A8NTtwKyspe2Zvcih2YXIgaD0wLGQ9MCxtPTA7bTw1O20rKyl7aF49KEY9bltwKzUqbV0pLmhpZ2gsZF49Ri5sb3d9dmFyIHk9bFtwXTt5LmhpZ2g9aCx5Lmxvdz1kfWZvcihwPTA7cDw1O3ArKyl7dmFyIGc9bFsocCs0KSU1XSx2PWxbKHArMSklNV0sYj12LmhpZ2gsXz12Lmxvdztmb3IoaD1nLmhpZ2heKGI8PDF8Xz4+PjMxKSxkPWcubG93XihfPDwxfGI+Pj4zMSksbT0wO208NTttKyspeyhGPW5bcCs1Km1dKS5oaWdoXj1oLEYubG93Xj1kfX1mb3IodmFyIHc9MTt3PDI1O3crKyl7dmFyIHg9KEY9blt3XSkuaGlnaCxrPUYubG93LEI9Y1t3XTtpZihCPDMyKWg9eDw8QnxrPj4+MzItQixkPWs8PEJ8eD4+PjMyLUI7ZWxzZSBoPWs8PEItMzJ8eD4+PjY0LUIsZD14PDxCLTMyfGs+Pj42NC1CO3ZhciBTPWxbdVt3XV07Uy5oaWdoPWgsUy5sb3c9ZH12YXIgQT1sWzBdLEM9blswXTtBLmhpZ2g9Qy5oaWdoLEEubG93PUMubG93O2ZvcihwPTA7cDw1O3ArKylmb3IobT0wO208NTttKyspe3ZhciBGPW5bdz1wKzUqbV0sTz1sW3ddLEk9bFsocCsxKSU1KzUqbV0sTj1sWyhwKzIpJTUrNSptXTtGLmhpZ2g9Ty5oaWdoXn5JLmhpZ2gmTi5oaWdoLEYubG93PU8ubG93Xn5JLmxvdyZOLmxvd31GPW5bMF07dmFyIFQ9ZltzXTtGLmhpZ2hePVQuaGlnaCxGLmxvd149VC5sb3d9fSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2RhdGEsbj10LndvcmRzLHI9KHRoaXMuX25EYXRhQnl0ZXMsOCp0LnNpZ0J5dGVzKSxpPTMyKnRoaXMuYmxvY2tTaXplO25bcj4+PjVdfD0xPDwyNC1yJTMyLG5bKGUuY2VpbCgocisxKS9pKSppPj4+NSktMV18PTEyOCx0LnNpZ0J5dGVzPTQqbi5sZW5ndGgsdGhpcy5fcHJvY2VzcygpO2Zvcih2YXIgYT10aGlzLl9zdGF0ZSxzPXRoaXMuY2ZnLm91dHB1dExlbmd0aC84LGM9cy84LHU9W10sZj0wO2Y8YztmKyspe3ZhciBsPWFbZl0scD1sLmhpZ2gsaD1sLmxvdztwPTE2NzExOTM1JihwPDw4fHA+Pj4yNCl8NDI3ODI1NTM2MCYocDw8MjR8cD4+PjgpLGg9MTY3MTE5MzUmKGg8PDh8aD4+PjI0KXw0Mjc4MjU1MzYwJihoPDwyNHxoPj4+OCksdS5wdXNoKGgpLHUucHVzaChwKX1yZXR1cm4gbmV3IG8uaW5pdCh1LHMpfSxjbG9uZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1pLmNsb25lLmNhbGwodGhpcyksZT10Ll9zdGF0ZT10aGlzLl9zdGF0ZS5zbGljZSgwKSxuPTA7bjwyNTtuKyspZVtuXT1lW25dLmNsb25lKCk7cmV0dXJuIHR9fSk7bi5TSEEzPWkuX2NyZWF0ZUhlbHBlcihwKSxuLkhtYWNTSEEzPWkuX2NyZWF0ZUhtYWNIZWxwZXIocCl9KE1hdGgpLHQuU0hBM30pfSx7Ii4vY29yZSI6NTIsIi4veDY0LWNvcmUiOjgzfV0sODA6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4veDY0LWNvcmUiKSx0KCIuL3NoYTUxMiIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4veDY0LWNvcmUiLCIuL3NoYTUxMiJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9dCxuPWUueDY0LHI9bi5Xb3JkLG89bi5Xb3JkQXJyYXksaT1lLmFsZ28sYT1pLlNIQTUxMixzPWkuU0hBMzg0PWEuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IG8uaW5pdChbbmV3IHIuaW5pdCgzNDE4MDcwMzY1LDMyMzgzNzEwMzIpLG5ldyByLmluaXQoMTY1NDI3MDI1MCw5MTQxNTA2NjMpLG5ldyByLmluaXQoMjQzODUyOTM3MCw4MTI3MDI5OTkpLG5ldyByLmluaXQoMzU1NDYyMzYwLDQxNDQ5MTI2OTcpLG5ldyByLmluaXQoMTczMTQwNTQxNSw0MjkwNzc1ODU3KSxuZXcgci5pbml0KDIzOTQxODAyMzEsMTc1MDYwMzAyNSksbmV3IHIuaW5pdCgzNjc1MDA4NTI1LDE2OTQwNzY4MzkpLG5ldyByLmluaXQoMTIwMzA2MjgxMywzMjA0MDc1NDI4KV0pfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciB0PWEuX2RvRmluYWxpemUuY2FsbCh0aGlzKTtyZXR1cm4gdC5zaWdCeXRlcy09MTYsdH19KTtlLlNIQTM4ND1hLl9jcmVhdGVIZWxwZXIocyksZS5IbWFjU0hBMzg0PWEuX2NyZWF0ZUhtYWNIZWxwZXIocyl9KCksdC5TSEEzODR9KX0seyIuL2NvcmUiOjUyLCIuL3NoYTUxMiI6ODEsIi4veDY0LWNvcmUiOjgzfV0sODE6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4veDY0LWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL3g2NC1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7cmV0dXJuIGkuY3JlYXRlLmFwcGx5KGksYXJndW1lbnRzKX12YXIgbj10LHI9bi5saWIuSGFzaGVyLG89bi54NjQsaT1vLldvcmQsYT1vLldvcmRBcnJheSxzPW4uYWxnbyxjPVtlKDExMTYzNTI0MDgsMzYwOTc2NzQ1OCksZSgxODk5NDQ3NDQxLDYwMjg5MTcyNSksZSgzMDQ5MzIzNDcxLDM5NjQ0ODQzOTkpLGUoMzkyMTAwOTU3MywyMTczMjk1NTQ4KSxlKDk2MTk4NzE2Myw0MDgxNjI4NDcyKSxlKDE1MDg5NzA5OTMsMzA1MzgzNDI2NSksZSgyNDUzNjM1NzQ4LDI5Mzc2NzE1NzkpLGUoMjg3MDc2MzIyMSwzNjY0NjA5NTYwKSxlKDM2MjQzODEwODAsMjczNDg4MzM5NCksZSgzMTA1OTg0MDEsMTE2NDk5NjU0MiksZSg2MDcyMjUyNzgsMTMyMzYxMDc2NCksZSgxNDI2ODgxOTg3LDM1OTAzMDQ5OTQpLGUoMTkyNTA3ODM4OCw0MDY4MTgyMzgzKSxlKDIxNjIwNzgyMDYsOTkxMzM2MTEzKSxlKDI2MTQ4ODgxMDMsNjMzODAzMzE3KSxlKDMyNDgyMjI1ODAsMzQ3OTc3NDg2OCksZSgzODM1MzkwNDAxLDI2NjY2MTM0NTgpLGUoNDAyMjIyNDc3NCw5NDQ3MTExMzkpLGUoMjY0MzQ3MDc4LDIzNDEyNjI3NzMpLGUoNjA0ODA3NjI4LDIwMDc4MDA5MzMpLGUoNzcwMjU1OTgzLDE0OTU5OTA5MDEpLGUoMTI0OTE1MDEyMiwxODU2NDMxMjM1KSxlKDE1NTUwODE2OTIsMzE3NTIxODEzMiksZSgxOTk2MDY0OTg2LDIxOTg5NTA4MzcpLGUoMjU1NDIyMDg4MiwzOTk5NzE5MzM5KSxlKDI4MjE4MzQzNDksNzY2Nzg0MDE2KSxlKDI5NTI5OTY4MDgsMjU2NjU5NDg3OSksZSgzMjEwMzEzNjcxLDMyMDMzMzc5NTYpLGUoMzMzNjU3MTg5MSwxMDM0NDU3MDI2KSxlKDM1ODQ1Mjg3MTEsMjQ2Njk0ODkwMSksZSgxMTM5MjY5OTMsMzc1ODMyNjM4MyksZSgzMzgyNDE4OTUsMTY4NzE3OTM2KSxlKDY2NjMwNzIwNSwxMTg4MTc5OTY0KSxlKDc3MzUyOTkxMiwxNTQ2MDQ1NzM0KSxlKDEyOTQ3NTczNzIsMTUyMjgwNTQ4NSksZSgxMzk2MTgyMjkxLDI2NDM4MzM4MjMpLGUoMTY5NTE4MzcwMCwyMzQzNTI3MzkwKSxlKDE5ODY2NjEwNTEsMTAxNDQ3NzQ4MCksZSgyMTc3MDI2MzUwLDEyMDY3NTkxNDIpLGUoMjQ1Njk1NjAzNywzNDQwNzc2MjcpLGUoMjczMDQ4NTkyMSwxMjkwODYzNDYwKSxlKDI4MjAzMDI0MTEsMzE1ODQ1NDI3MyksZSgzMjU5NzMwODAwLDM1MDU5NTI2NTcpLGUoMzM0NTc2NDc3MSwxMDYyMTcwMDgpLGUoMzUxNjA2NTgxNywzNjA2MDA4MzQ0KSxlKDM2MDAzNTI4MDQsMTQzMjcyNTc3NiksZSg0MDk0NTcxOTA5LDE0NjcwMzE1OTQpLGUoMjc1NDIzMzQ0LDg1MTE2OTcyMCksZSg0MzAyMjc3MzQsMzEwMDgyMzc1MiksZSg1MDY5NDg2MTYsMTM2MzI1ODE5NSksZSg2NTkwNjA1NTYsMzc1MDY4NTU5MyksZSg4ODM5OTc4NzcsMzc4NTA1MDI4MCksZSg5NTgxMzk1NzEsMzMxODMwNzQyNyksZSgxMzIyODIyMjE4LDM4MTI3MjM0MDMpLGUoMTUzNzAwMjA2MywyMDAzMDM0OTk1KSxlKDE3NDc4NzM3NzksMzYwMjAzNjg5OSksZSgxOTU1NTYyMjIyLDE1NzU5OTAwMTIpLGUoMjAyNDEwNDgxNSwxMTI1NTkyOTI4KSxlKDIyMjc3MzA0NTIsMjcxNjkwNDMwNiksZSgyMzYxODUyNDI0LDQ0Mjc3NjA0NCksZSgyNDI4NDM2NDc0LDU5MzY5ODM0NCksZSgyNzU2NzM0MTg3LDM3MzMxMTAyNDkpLGUoMzIwNDAzMTQ3OSwyOTk5MzUxNTczKSxlKDMzMjkzMjUyOTgsMzgxNTkyMDQyNyksZSgzMzkxNTY5NjE0LDM5MjgzODM5MDApLGUoMzUxNTI2NzI3MSw1NjYyODA3MTEpLGUoMzk0MDE4NzYwNiwzNDU0MDY5NTM0KSxlKDQxMTg2MzAyNzEsNDAwMDIzOTk5MiksZSgxMTY0MTg0NzQsMTkxNDEzODU1NCksZSgxNzQyOTI0MjEsMjczMTA1NTI3MCksZSgyODkzODAzNTYsMzIwMzk5MzAwNiksZSg0NjAzOTMyNjksMzIwNjIwMzE1KSxlKDY4NTQ3MTczMyw1ODc0OTY4MzYpLGUoODUyMTQyOTcxLDEwODY3OTI4NTEpLGUoMTAxNzAzNjI5OCwzNjU1NDMxMDApLGUoMTEyNjAwMDU4MCwyNjE4Mjk3Njc2KSxlKDEyODgwMzM0NzAsMzQwOTg1NTE1OCksZSgxNTAxNTA1OTQ4LDQyMzQ1MDk4NjYpLGUoMTYwNzE2NzkxNSw5ODcxNjc0NjgpLGUoMTgxNjQwMjMxNiwxMjQ2MTg5NTkxKV0sdT1bXTshZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PDgwO3QrKyl1W3RdPWUoKX0oKTt2YXIgZj1zLlNIQTUxMj1yLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBhLmluaXQoW25ldyBpLmluaXQoMTc3OTAzMzcwMyw0MDg5MjM1NzIwKSxuZXcgaS5pbml0KDMxNDQxMzQyNzcsMjIyNzg3MzU5NSksbmV3IGkuaW5pdCgxMDEzOTA0MjQyLDQyNzExNzU3MjMpLG5ldyBpLmluaXQoMjc3MzQ4MDc2MiwxNTk1NzUwMTI5KSxuZXcgaS5pbml0KDEzNTk4OTMxMTksMjkxNzU2NTEzNyksbmV3IGkuaW5pdCgyNjAwODIyOTI0LDcyNTUxMTE5OSksbmV3IGkuaW5pdCg1Mjg3MzQ2MzUsNDIxNTM4OTU0NyksbmV3IGkuaW5pdCgxNTQxNDU5MjI1LDMyNzAzMzIwOSldKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuX2hhc2gud29yZHMscj1uWzBdLG89blsxXSxpPW5bMl0sYT1uWzNdLHM9bls0XSxmPW5bNV0sbD1uWzZdLHA9bls3XSxoPXIuaGlnaCxkPXIubG93LG09by5oaWdoLHk9by5sb3csZz1pLmhpZ2gsdj1pLmxvdyxiPWEuaGlnaCxfPWEubG93LHc9cy5oaWdoLHg9cy5sb3csaz1mLmhpZ2gsQj1mLmxvdyxTPWwuaGlnaCxBPWwubG93LEM9cC5oaWdoLEY9cC5sb3csTz1oLEk9ZCxOPW0sVD15LFA9ZyxEPXYsUj1iLEU9XyxNPXcsSD14LGo9ayxxPUIsej1TLEw9QSxVPUMsVz1GLEo9MDtKPDgwO0orKyl7dmFyIEs9dVtKXTtpZihKPDE2KXZhciBHPUsuaGlnaD0wfHRbZSsyKkpdLFg9Sy5sb3c9MHx0W2UrMipKKzFdO2Vsc2V7dmFyICQ9dVtKLTE1XSxWPSQuaGlnaCxaPSQubG93LFk9KFY+Pj4xfFo8PDMxKV4oVj4+Pjh8Wjw8MjQpXlY+Pj43LFE9KFo+Pj4xfFY8PDMxKV4oWj4+Pjh8Vjw8MjQpXihaPj4+N3xWPDwyNSksdHQ9dVtKLTJdLGV0PXR0LmhpZ2gsbnQ9dHQubG93LHJ0PShldD4+PjE5fG50PDwxMyleKGV0PDwzfG50Pj4+MjkpXmV0Pj4+NixvdD0obnQ+Pj4xOXxldDw8MTMpXihudDw8M3xldD4+PjI5KV4obnQ+Pj42fGV0PDwyNiksaXQ9dVtKLTddLGF0PWl0LmhpZ2gsc3Q9aXQubG93LGN0PXVbSi0xNl0sdXQ9Y3QuaGlnaCxmdD1jdC5sb3c7Rz0oRz0oRz1ZK2F0KygoWD1RK3N0KT4+PjA8UT4+PjA/MTowKSkrcnQrKChYPVgrb3QpPj4+MDxvdD4+PjA/MTowKSkrdXQrKChYPVgrZnQpPj4+MDxmdD4+PjA/MTowKTtLLmhpZ2g9RyxLLmxvdz1YfXZhciBsdCxwdD1NJmpefk0meixodD1IJnFefkgmTCxkdD1PJk5eTyZQXk4mUCxtdD1JJlReSSZEXlQmRCx5dD0oTz4+PjI4fEk8PDQpXihPPDwzMHxJPj4+MileKE88PDI1fEk+Pj43KSxndD0oST4+PjI4fE88PDQpXihJPDwzMHxPPj4+MileKEk8PDI1fE8+Pj43KSx2dD0oTT4+PjE0fEg8PDE4KV4oTT4+PjE4fEg8PDE0KV4oTTw8MjN8SD4+PjkpLGJ0PShIPj4+MTR8TTw8MTgpXihIPj4+MTh8TTw8MTQpXihIPDwyM3xNPj4+OSksX3Q9Y1tKXSx3dD1fdC5oaWdoLHh0PV90LmxvdyxrdD1VK3Z0KygobHQ9VytidCk+Pj4wPFc+Pj4wPzE6MCksQnQ9Z3QrbXQ7VT16LFc9TCx6PWosTD1xLGo9TSxxPUgsTT1SKyhrdD0oa3Q9KGt0PWt0K3B0KygobHQ9bHQraHQpPj4+MDxodD4+PjA/MTowKSkrd3QrKChsdD1sdCt4dCk+Pj4wPHh0Pj4+MD8xOjApKStHKygobHQ9bHQrWCk+Pj4wPFg+Pj4wPzE6MCkpKygoSD1FK2x0fDApPj4+MDxFPj4+MD8xOjApfDAsUj1QLEU9RCxQPU4sRD1ULE49TyxUPUksTz1rdCsoeXQrZHQrKEJ0Pj4+MDxndD4+PjA/MTowKSkrKChJPWx0K0J0fDApPj4+MDxsdD4+PjA/MTowKXwwfWQ9ci5sb3c9ZCtJLHIuaGlnaD1oK08rKGQ+Pj4wPEk+Pj4wPzE6MCkseT1vLmxvdz15K1Qsby5oaWdoPW0rTisoeT4+PjA8VD4+PjA/MTowKSx2PWkubG93PXYrRCxpLmhpZ2g9ZytQKyh2Pj4+MDxEPj4+MD8xOjApLF89YS5sb3c9XytFLGEuaGlnaD1iK1IrKF8+Pj4wPEU+Pj4wPzE6MCkseD1zLmxvdz14K0gscy5oaWdoPXcrTSsoeD4+PjA8SD4+PjA/MTowKSxCPWYubG93PUIrcSxmLmhpZ2g9aytqKyhCPj4+MDxxPj4+MD8xOjApLEE9bC5sb3c9QStMLGwuaGlnaD1TK3orKEE+Pj4wPEw+Pj4wPzE6MCksRj1wLmxvdz1GK1cscC5oaWdoPUMrVSsoRj4+PjA8Vz4+PjA/MTowKX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9kYXRhLGU9dC53b3JkcyxuPTgqdGhpcy5fbkRhdGFCeXRlcyxyPTgqdC5zaWdCeXRlcztlW3I+Pj41XXw9MTI4PDwyNC1yJTMyLGVbMzArKHIrMTI4Pj4+MTA8PDUpXT1NYXRoLmZsb29yKG4vNDI5NDk2NzI5NiksZVszMSsocisxMjg+Pj4xMDw8NSldPW4sdC5zaWdCeXRlcz00KmUubGVuZ3RoLHRoaXMuX3Byb2Nlc3MoKTtyZXR1cm4gdGhpcy5faGFzaC50b1gzMigpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PXIuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5faGFzaD10aGlzLl9oYXNoLmNsb25lKCksdH0sYmxvY2tTaXplOjMyfSk7bi5TSEE1MTI9ci5fY3JlYXRlSGVscGVyKGYpLG4uSG1hY1NIQTUxMj1yLl9jcmVhdGVIbWFjSGVscGVyKGYpfSgpLHQuU0hBNTEyfSl9LHsiLi9jb3JlIjo1MiwiLi94NjQtY29yZSI6ODN9XSw4MjpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9lbmMtYmFzZTY0IiksdCgiLi9tZDUiKSx0KCIuL2V2cGtkZiIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2VuYy1iYXNlNjQiLCIuL21kNSIsIi4vZXZwa2RmIiwiLi9jaXBoZXItY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LGUpe3ZhciBuPSh0aGlzLl9sQmxvY2s+Pj50XnRoaXMuX3JCbG9jaykmZTt0aGlzLl9yQmxvY2tePW4sdGhpcy5fbEJsb2NrXj1uPDx0fWZ1bmN0aW9uIG4odCxlKXt2YXIgbj0odGhpcy5fckJsb2NrPj4+dF50aGlzLl9sQmxvY2spJmU7dGhpcy5fbEJsb2NrXj1uLHRoaXMuX3JCbG9ja149bjw8dH12YXIgcj10LG89ci5saWIsaT1vLldvcmRBcnJheSxhPW8uQmxvY2tDaXBoZXIscz1yLmFsZ28sYz1bNTcsNDksNDEsMzMsMjUsMTcsOSwxLDU4LDUwLDQyLDM0LDI2LDE4LDEwLDIsNTksNTEsNDMsMzUsMjcsMTksMTEsMyw2MCw1Miw0NCwzNiw2Myw1NSw0NywzOSwzMSwyMywxNSw3LDYyLDU0LDQ2LDM4LDMwLDIyLDE0LDYsNjEsNTMsNDUsMzcsMjksMjEsMTMsNSwyOCwyMCwxMiw0XSx1PVsxNCwxNywxMSwyNCwxLDUsMywyOCwxNSw2LDIxLDEwLDIzLDE5LDEyLDQsMjYsOCwxNiw3LDI3LDIwLDEzLDIsNDEsNTIsMzEsMzcsNDcsNTUsMzAsNDAsNTEsNDUsMzMsNDgsNDQsNDksMzksNTYsMzQsNTMsNDYsNDIsNTAsMzYsMjksMzJdLGY9WzEsMiw0LDYsOCwxMCwxMiwxNCwxNSwxNywxOSwyMSwyMywyNSwyNywyOF0sbD1bezA6ODQyMTg4OCwyNjg0MzU0NTY6MzI3NjgsNTM2ODcwOTEyOjg0MjEzNzgsODA1MzA2MzY4OjIsMTA3Mzc0MTgyNDo1MTIsMTM0MjE3NzI4MDo4NDIxODkwLDE2MTA2MTI3MzY6ODM4OTEyMiwxODc5MDQ4MTkyOjgzODg2MDgsMjE0NzQ4MzY0ODo1MTQsMjQxNTkxOTEwNDo4Mzg5MTIwLDI2ODQzNTQ1NjA6MzMyODAsMjk1Mjc5MDAxNjo4NDIxMzc2LDMyMjEyMjU0NzI6MzI3NzAsMzQ4OTY2MDkyODo4Mzg4NjEwLDM3NTgwOTYzODQ6MCw0MDI2NTMxODQwOjMzMjgyLDEzNDIxNzcyODowLDQwMjY1MzE4NDo4NDIxODkwLDY3MTA4ODY0MDozMzI4Miw5Mzk1MjQwOTY6MzI3NjgsMTIwNzk1OTU1Mjo4NDIxODg4LDE0NzYzOTUwMDg6NTEyLDE3NDQ4MzA0NjQ6ODQyMTM3OCwyMDEzMjY1OTIwOjIsMjI4MTcwMTM3Njo4Mzg5MTIwLDI1NTAxMzY4MzI6MzMyODAsMjgxODU3MjI4ODo4NDIxMzc2LDMwODcwMDc3NDQ6ODM4OTEyMiwzMzU1NDQzMjAwOjgzODg2MTAsMzYyMzg3ODY1NjozMjc3MCwzODkyMzE0MTEyOjUxNCw0MTYwNzQ5NTY4OjgzODg2MDgsMTozMjc2OCwyNjg0MzU0NTc6Miw1MzY4NzA5MTM6ODQyMTg4OCw4MDUzMDYzNjk6ODM4ODYwOCwxMDczNzQxODI1Ojg0MjEzNzgsMTM0MjE3NzI4MTozMzI4MCwxNjEwNjEyNzM3OjUxMiwxODc5MDQ4MTkzOjgzODkxMjIsMjE0NzQ4MzY0OTo4NDIxODkwLDI0MTU5MTkxMDU6ODQyMTM3NiwyNjg0MzU0NTYxOjgzODg2MTAsMjk1Mjc5MDAxNzozMzI4MiwzMjIxMjI1NDczOjUxNCwzNDg5NjYwOTI5OjgzODkxMjAsMzc1ODA5NjM4NTozMjc3MCw0MDI2NTMxODQxOjAsMTM0MjE3NzI5Ojg0MjE4OTAsNDAyNjUzMTg1Ojg0MjEzNzYsNjcxMDg4NjQxOjgzODg2MDgsOTM5NTI0MDk3OjUxMiwxMjA3OTU5NTUzOjMyNzY4LDE0NzYzOTUwMDk6ODM4ODYxMCwxNzQ0ODMwNDY1OjIsMjAxMzI2NTkyMTozMzI4MiwyMjgxNzAxMzc3OjMyNzcwLDI1NTAxMzY4MzM6ODM4OTEyMiwyODE4NTcyMjg5OjUxNCwzMDg3MDA3NzQ1Ojg0MjE4ODgsMzM1NTQ0MzIwMTo4Mzg5MTIwLDM2MjM4Nzg2NTc6MCwzODkyMzE0MTEzOjMzMjgwLDQxNjA3NDk1Njk6ODQyMTM3OH0sezA6MTA3NDI4MjUxMiwxNjc3NzIxNjoxNjM4NCwzMzU1NDQzMjo1MjQyODgsNTAzMzE2NDg6MTA3NDI2NjEyOCw2NzEwODg2NDoxMDczNzQxODQwLDgzODg2MDgwOjEwNzQyODI0OTYsMTAwNjYzMjk2OjEwNzM3NTgyMDgsMTE3NDQwNTEyOjE2LDEzNDIxNzcyODo1NDA2NzIsMTUwOTk0OTQ0OjEwNzM3NTgyMjQsMTY3NzcyMTYwOjEwNzM3NDE4MjQsMTg0NTQ5Mzc2OjU0MDY4OCwyMDEzMjY1OTI6NTI0MzA0LDIxODEwMzgwODowLDIzNDg4MTAyNDoxNjQwMCwyNTE2NTgyNDA6MTA3NDI2NjExMiw4Mzg4NjA4OjEwNzM3NTgyMDgsMjUxNjU4MjQ6NTQwNjg4LDQxOTQzMDQwOjE2LDU4NzIwMjU2OjEwNzM3NTgyMjQsNzU0OTc0NzI6MTA3NDI4MjUxMiw5MjI3NDY4ODoxMDczNzQxODI0LDEwOTA1MTkwNDo1MjQyODgsMTI1ODI5MTIwOjEwNzQyNjYxMjgsMTQyNjA2MzM2OjUyNDMwNCwxNTkzODM1NTI6MCwxNzYxNjA3Njg6MTYzODQsMTkyOTM3OTg0OjEwNzQyNjYxMTIsMjA5NzE1MjAwOjEwNzM3NDE4NDAsMjI2NDkyNDE2OjU0MDY3MiwyNDMyNjk2MzI6MTA3NDI4MjQ5NiwyNjAwNDY4NDg6MTY0MDAsMjY4NDM1NDU2OjAsMjg1MjEyNjcyOjEwNzQyNjYxMjgsMzAxOTg5ODg4OjEwNzM3NTgyMjQsMzE4NzY3MTA0OjEwNzQyODI0OTYsMzM1NTQ0MzIwOjEwNzQyNjYxMTIsMzUyMzIxNTM2OjE2LDM2OTA5ODc1Mjo1NDA2ODgsMzg1ODc1OTY4OjE2Mzg0LDQwMjY1MzE4NDoxNjQwMCw0MTk0MzA0MDA6NTI0Mjg4LDQzNjIwNzYxNjo1MjQzMDQsNDUyOTg0ODMyOjEwNzM3NDE4NDAsNDY5NzYyMDQ4OjU0MDY3Miw0ODY1MzkyNjQ6MTA3Mzc1ODIwOCw1MDMzMTY0ODA6MTA3Mzc0MTgyNCw1MjAwOTM2OTY6MTA3NDI4MjUxMiwyNzY4MjQwNjQ6NTQwNjg4LDI5MzYwMTI4MDo1MjQyODgsMzEwMzc4NDk2OjEwNzQyNjYxMTIsMzI3MTU1NzEyOjE2Mzg0LDM0MzkzMjkyODoxMDczNzU4MjA4LDM2MDcxMDE0NDoxMDc0MjgyNTEyLDM3NzQ4NzM2MDoxNiwzOTQyNjQ1NzY6MTA3Mzc0MTgyNCw0MTEwNDE3OTI6MTA3NDI4MjQ5Niw0Mjc4MTkwMDg6MTA3Mzc0MTg0MCw0NDQ1OTYyMjQ6MTA3Mzc1ODIyNCw0NjEzNzM0NDA6NTI0MzA0LDQ3ODE1MDY1NjowLDQ5NDkyNzg3MjoxNjQwMCw1MTE3MDUwODg6MTA3NDI2NjEyOCw1Mjg0ODIzMDQ6NTQwNjcyfSx7MDoyNjAsMTA0ODU3NjowLDIwOTcxNTI6NjcxMDkxMjAsMzE0NTcyODo2NTc5Niw0MTk0MzA0OjY1NTQwLDUyNDI4ODA6NjcxMDg4NjgsNjI5MTQ1Njo2NzE3NDY2MCw3MzQwMDMyOjY3MTc0NDAwLDgzODg2MDg6NjcxMDg4NjQsOTQzNzE4NDo2NzE3NDY1NiwxMDQ4NTc2MDo2NTc5MiwxMTUzNDMzNjo2NzE3NDQwNCwxMjU4MjkxMjo2NzEwOTEyNCwxMzYzMTQ4ODo2NTUzNiwxNDY4MDA2NDo0LDE1NzI4NjQwOjI1Niw1MjQyODg6NjcxNzQ2NTYsMTU3Mjg2NDo2NzE3NDQwNCwyNjIxNDQwOjAsMzY3MDAxNjo2NzEwOTEyMCw0NzE4NTkyOjY3MTA4ODY4LDU3NjcxNjg6NjU1MzYsNjgxNTc0NDo2NTU0MCw3ODY0MzIwOjI2MCw4OTEyODk2OjQsOTk2MTQ3MjoyNTYsMTEwMTAwNDg6NjcxNzQ0MDAsMTIwNTg2MjQ6NjU3OTYsMTMxMDcyMDA6NjU3OTIsMTQxNTU3NzY6NjcxMDkxMjQsMTUyMDQzNTI6NjcxNzQ2NjAsMTYyNTI5Mjg6NjcxMDg4NjQsMTY3NzcyMTY6NjcxNzQ2NTYsMTc4MjU3OTI6NjU1NDAsMTg4NzQzNjg6NjU1MzYsMTk5MjI5NDQ6NjcxMDkxMjAsMjA5NzE1MjA6MjU2LDIyMDIwMDk2OjY3MTc0NjYwLDIzMDY4NjcyOjY3MTA4ODY4LDI0MTE3MjQ4OjAsMjUxNjU4MjQ6NjcxMDkxMjQsMjYyMTQ0MDA6NjcxMDg4NjQsMjcyNjI5NzY6NCwyODMxMTU1Mjo2NTc5MiwyOTM2MDEyODo2NzE3NDQwMCwzMDQwODcwNDoyNjAsMzE0NTcyODA6NjU3OTYsMzI1MDU4NTY6NjcxNzQ0MDQsMTczMDE1MDQ6NjcxMDg4NjQsMTgzNTAwODA6MjYwLDE5Mzk4NjU2OjY3MTc0NjU2LDIwNDQ3MjMyOjAsMjE0OTU4MDg6NjU1NDAsMjI1NDQzODQ6NjcxMDkxMjAsMjM1OTI5NjA6MjU2LDI0NjQxNTM2OjY3MTc0NDA0LDI1NjkwMTEyOjY1NTM2LDI2NzM4Njg4OjY3MTc0NjYwLDI3Nzg3MjY0OjY1Nzk2LDI4ODM1ODQwOjY3MTA4ODY4LDI5ODg0NDE2OjY3MTA5MTI0LDMwOTMyOTkyOjY3MTc0NDAwLDMxOTgxNTY4OjQsMzMwMzAxNDQ6NjU3OTJ9LHswOjIxNTE2ODIwNDgsNjU1MzY6MjE0NzQ4NzgwOCwxMzEwNzI6NDE5ODQ2NCwxOTY2MDg6MjE1MTY3Nzk1MiwyNjIxNDQ6MCwzMjc2ODA6NDE5ODQwMCwzOTMyMTY6MjE0NzQ4MzcxMiw0NTg3NTI6NDE5NDM2OCw1MjQyODg6MjE0NzQ4MzY0OCw1ODk4MjQ6NDE5NDMwNCw2NTUzNjA6NjQsNzIwODk2OjIxNDc0ODc3NDQsNzg2NDMyOjIxNTE2NzgwMTYsODUxOTY4OjQxNjAsOTE3NTA0OjQwOTYsOTgzMDQwOjIxNTE2ODIxMTIsMzI3Njg6MjE0NzQ4NzgwOCw5ODMwNDo2NCwxNjM4NDA6MjE1MTY3ODAxNiwyMjkzNzY6MjE0NzQ4Nzc0NCwyOTQ5MTI6NDE5ODQwMCwzNjA0NDg6MjE1MTY4MjExMiw0MjU5ODQ6MCw0OTE1MjA6MjE1MTY3Nzk1Miw1NTcwNTY6NDA5Niw2MjI1OTI6MjE1MTY4MjA0OCw2ODgxMjg6NDE5NDMwNCw3NTM2NjQ6NDE2MCw4MTkyMDA6MjE0NzQ4MzY0OCw4ODQ3MzY6NDE5NDM2OCw5NTAyNzI6NDE5ODQ2NCwxMDE1ODA4OjIxNDc0ODM3MTIsMTA0ODU3Njo0MTk0MzY4LDExMTQxMTI6NDE5ODQwMCwxMTc5NjQ4OjIxNDc0ODM3MTIsMTI0NTE4NDowLDEzMTA3MjA6NDE2MCwxMzc2MjU2OjIxNTE2NzgwMTYsMTQ0MTc5MjoyMTUxNjgyMDQ4LDE1MDczMjg6MjE0NzQ4NzgwOCwxNTcyODY0OjIxNTE2ODIxMTIsMTYzODQwMDoyMTQ3NDgzNjQ4LDE3MDM5MzY6MjE1MTY3Nzk1MiwxNzY5NDcyOjQxOTg0NjQsMTgzNTAwODoyMTQ3NDg3NzQ0LDE5MDA1NDQ6NDE5NDMwNCwxOTY2MDgwOjY0LDIwMzE2MTY6NDA5NiwxMDgxMzQ0OjIxNTE2Nzc5NTIsMTE0Njg4MDoyMTUxNjgyMTEyLDEyMTI0MTY6MCwxMjc3OTUyOjQxOTg0MDAsMTM0MzQ4ODo0MTk0MzY4LDE0MDkwMjQ6MjE0NzQ4MzY0OCwxNDc0NTYwOjIxNDc0ODc4MDgsMTU0MDA5Njo2NCwxNjA1NjMyOjIxNDc0ODM3MTIsMTY3MTE2ODo0MDk2LDE3MzY3MDQ6MjE0NzQ4Nzc0NCwxODAyMjQwOjIxNTE2NzgwMTYsMTg2Nzc3Njo0MTYwLDE5MzMzMTI6MjE1MTY4MjA0OCwxOTk4ODQ4OjQxOTQzMDQsMjA2NDM4NDo0MTk4NDY0fSx7MDoxMjgsNDA5NjoxNzAzOTM2MCw4MTkyOjI2MjE0NCwxMjI4ODo1MzY4NzA5MTIsMTYzODQ6NTM3MTMzMTg0LDIwNDgwOjE2Nzc3MzQ0LDI0NTc2OjU1MzY0ODI1NiwyODY3MjoyNjIyNzIsMzI3Njg6MTY3NzcyMTYsMzY4NjQ6NTM3MTMzMDU2LDQwOTYwOjUzNjg3MTA0MCw0NTA1Njo1NTM5MTA0MDAsNDkxNTI6NTUzOTEwMjcyLDUzMjQ4OjAsNTczNDQ6MTcwMzk0ODgsNjE0NDA6NTUzNjQ4MTI4LDIwNDg6MTcwMzk0ODgsNjE0NDo1NTM2NDgyNTYsMTAyNDA6MTI4LDE0MzM2OjE3MDM5MzYwLDE4NDMyOjI2MjE0NCwyMjUyODo1MzcxMzMxODQsMjY2MjQ6NTUzOTEwMjcyLDMwNzIwOjUzNjg3MDkxMiwzNDgxNjo1MzcxMzMwNTYsMzg5MTI6MCw0MzAwODo1NTM5MTA0MDAsNDcxMDQ6MTY3NzczNDQsNTEyMDA6NTM2ODcxMDQwLDU1Mjk2OjU1MzY0ODEyOCw1OTM5MjoxNjc3NzIxNiw2MzQ4ODoyNjIyNzIsNjU1MzY6MjYyMTQ0LDY5NjMyOjEyOCw3MzcyODo1MzY4NzA5MTIsNzc4MjQ6NTUzNjQ4MjU2LDgxOTIwOjE2Nzc3MzQ0LDg2MDE2OjU1MzkxMDI3Miw5MDExMjo1MzcxMzMxODQsOTQyMDg6MTY3NzcyMTYsOTgzMDQ6NTUzOTEwNDAwLDEwMjQwMDo1NTM2NDgxMjgsMTA2NDk2OjE3MDM5MzYwLDExMDU5Mjo1MzcxMzMwNTYsMTE0Njg4OjI2MjI3MiwxMTg3ODQ6NTM2ODcxMDQwLDEyMjg4MDowLDEyNjk3NjoxNzAzOTQ4OCw2NzU4NDo1NTM2NDgyNTYsNzE2ODA6MTY3NzcyMTYsNzU3NzY6MTcwMzkzNjAsNzk4NzI6NTM3MTMzMTg0LDgzOTY4OjUzNjg3MDkxMiw4ODA2NDoxNzAzOTQ4OCw5MjE2MDoxMjgsOTYyNTY6NTUzOTEwMjcyLDEwMDM1MjoyNjIyNzIsMTA0NDQ4OjU1MzkxMDQwMCwxMDg1NDQ6MCwxMTI2NDA6NTUzNjQ4MTI4LDExNjczNjoxNjc3NzM0NCwxMjA4MzI6MjYyMTQ0LDEyNDkyODo1MzcxMzMwNTYsMTI5MDI0OjUzNjg3MTA0MH0sezA6MjY4NDM1NDY0LDI1Njo4MTkyLDUxMjoyNzA1MzI2MDgsNzY4OjI3MDU0MDgwOCwxMDI0OjI2ODQ0MzY0OCwxMjgwOjIwOTcxNTIsMTUzNjoyMDk3MTYwLDE3OTI6MjY4NDM1NDU2LDIwNDg6MCwyMzA0OjI2ODQ0MzY1NiwyNTYwOjIxMDUzNDQsMjgxNjo4LDMwNzI6MjcwNTMyNjE2LDMzMjg6MjEwNTM1MiwzNTg0OjgyMDAsMzg0MDoyNzA1NDA4MDAsMTI4OjI3MDUzMjYwOCwzODQ6MjcwNTQwODA4LDY0MDo4LDg5NjoyMDk3MTUyLDExNTI6MjEwNTM1MiwxNDA4OjI2ODQzNTQ2NCwxNjY0OjI2ODQ0MzY0OCwxOTIwOjgyMDAsMjE3NjoyMDk3MTYwLDI0MzI6ODE5MiwyNjg4OjI2ODQ0MzY1NiwyOTQ0OjI3MDUzMjYxNiwzMjAwOjAsMzQ1NjoyNzA1NDA4MDAsMzcxMjoyMTA1MzQ0LDM5Njg6MjY4NDM1NDU2LDQwOTY6MjY4NDQzNjQ4LDQzNTI6MjcwNTMyNjE2LDQ2MDg6MjcwNTQwODA4LDQ4NjQ6ODIwMCw1MTIwOjIwOTcxNTIsNTM3NjoyNjg0MzU0NTYsNTYzMjoyNjg0MzU0NjQsNTg4ODoyMTA1MzQ0LDYxNDQ6MjEwNTM1Miw2NDAwOjAsNjY1Njo4LDY5MTI6MjcwNTMyNjA4LDcxNjg6ODE5Miw3NDI0OjI2ODQ0MzY1Niw3NjgwOjI3MDU0MDgwMCw3OTM2OjIwOTcxNjAsNDIyNDo4LDQ0ODA6MjEwNTM0NCw0NzM2OjIwOTcxNTIsNDk5MjoyNjg0MzU0NjQsNTI0ODoyNjg0NDM2NDgsNTUwNDo4MjAwLDU3NjA6MjcwNTQwODA4LDYwMTY6MjcwNTMyNjA4LDYyNzI6MjcwNTQwODAwLDY1Mjg6MjcwNTMyNjE2LDY3ODQ6ODE5Miw3MDQwOjIxMDUzNTIsNzI5NjoyMDk3MTYwLDc1NTI6MCw3ODA4OjI2ODQzNTQ1Niw4MDY0OjI2ODQ0MzY1Nn0sezA6MTA0ODU3NiwxNjozMzU1NTQ1NywzMjoxMDI0LDQ4OjEwNDk2MDEsNjQ6MzQ2MDQwMzMsODA6MCw5NjoxLDExMjozNDYwMzAwOSwxMjg6MzM1NTU0NTYsMTQ0OjEwNDg1NzcsMTYwOjMzNTU0NDMzLDE3NjozNDYwNDAzMiwxOTI6MzQ2MDMwMDgsMjA4OjEwMjUsMjI0OjEwNDk2MDAsMjQwOjMzNTU0NDMyLDg6MzQ2MDMwMDksMjQ6MCw0MDozMzU1NTQ1Nyw1NjozNDYwNDAzMiw3MjoxMDQ4NTc2LDg4OjMzNTU0NDMzLDEwNDozMzU1NDQzMiwxMjA6MTAyNSwxMzY6MTA0OTYwMSwxNTI6MzM1NTU0NTYsMTY4OjM0NjAzMDA4LDE4NDoxMDQ4NTc3LDIwMDoxMDI0LDIxNjozNDYwNDAzMywyMzI6MSwyNDg6MTA0OTYwMCwyNTY6MzM1NTQ0MzIsMjcyOjEwNDg1NzYsMjg4OjMzNTU1NDU3LDMwNDozNDYwMzAwOSwzMjA6MTA0ODU3NywzMzY6MzM1NTU0NTYsMzUyOjM0NjA0MDMyLDM2ODoxMDQ5NjAxLDM4NDoxMDI1LDQwMDozNDYwNDAzMyw0MTY6MTA0OTYwMCw0MzI6MSw0NDg6MCw0NjQ6MzQ2MDMwMDgsNDgwOjMzNTU0NDMzLDQ5NjoxMDI0LDI2NDoxMDQ5NjAwLDI4MDozMzU1NTQ1NywyOTY6MzQ2MDMwMDksMzEyOjEsMzI4OjMzNTU0NDMyLDM0NDoxMDQ4NTc2LDM2MDoxMDI1LDM3NjozNDYwNDAzMiwzOTI6MzM1NTQ0MzMsNDA4OjM0NjAzMDA4LDQyNDowLDQ0MDozNDYwNDAzMyw0NTY6MTA0OTYwMSw0NzI6MTAyNCw0ODg6MzM1NTU0NTYsNTA0OjEwNDg1Nzd9LHswOjEzNDIxOTgwOCwxOjEzMTA3MiwyOjEzNDIxNzcyOCwzOjMyLDQ6MTMxMTA0LDU6MTM0MzUwODgwLDY6MTM0MzUwODQ4LDc6MjA0OCw4OjEzNDM0ODgwMCw5OjEzNDIxOTc3NiwxMDoxMzMxMjAsMTE6MTM0MzQ4ODMyLDEyOjIwODAsMTM6MCwxNDoxMzQyMTc3NjAsMTU6MTMzMTUyLDIxNDc0ODM2NDg6MjA0OCwyMTQ3NDgzNjQ5OjEzNDM1MDg4MCwyMTQ3NDgzNjUwOjEzNDIxOTgwOCwyMTQ3NDgzNjUxOjEzNDIxNzcyOCwyMTQ3NDgzNjUyOjEzNDM0ODgwMCwyMTQ3NDgzNjUzOjEzMzEyMCwyMTQ3NDgzNjU0OjEzMzE1MiwyMTQ3NDgzNjU1OjMyLDIxNDc0ODM2NTY6MTM0MjE3NzYwLDIxNDc0ODM2NTc6MjA4MCwyMTQ3NDgzNjU4OjEzMTEwNCwyMTQ3NDgzNjU5OjEzNDM1MDg0OCwyMTQ3NDgzNjYwOjAsMjE0NzQ4MzY2MToxMzQzNDg4MzIsMjE0NzQ4MzY2MjoxMzQyMTk3NzYsMjE0NzQ4MzY2MzoxMzEwNzIsMTY6MTMzMTUyLDE3OjEzNDM1MDg0OCwxODozMiwxOToyMDQ4LDIwOjEzNDIxOTc3NiwyMToxMzQyMTc3NjAsMjI6MTM0MzQ4ODMyLDIzOjEzMTA3MiwyNDowLDI1OjEzMTEwNCwyNjoxMzQzNDg4MDAsMjc6MTM0MjE5ODA4LDI4OjEzNDM1MDg4MCwyOToxMzMxMjAsMzA6MjA4MCwzMToxMzQyMTc3MjgsMjE0NzQ4MzY2NDoxMzEwNzIsMjE0NzQ4MzY2NToyMDQ4LDIxNDc0ODM2NjY6MTM0MzQ4ODMyLDIxNDc0ODM2Njc6MTMzMTUyLDIxNDc0ODM2Njg6MzIsMjE0NzQ4MzY2OToxMzQzNDg4MDAsMjE0NzQ4MzY3MDoxMzQyMTc3MjgsMjE0NzQ4MzY3MToxMzQyMTk4MDgsMjE0NzQ4MzY3MjoxMzQzNTA4ODAsMjE0NzQ4MzY3MzoxMzQyMTc3NjAsMjE0NzQ4MzY3NDoxMzQyMTk3NzYsMjE0NzQ4MzY3NTowLDIxNDc0ODM2NzY6MTMzMTIwLDIxNDc0ODM2Nzc6MjA4MCwyMTQ3NDgzNjc4OjEzMTEwNCwyMTQ3NDgzNjc5OjEzNDM1MDg0OH1dLHA9WzQxNjA3NDk1NjksNTI4NDgyMzA0LDMzMDMwMTQ0LDIwNjQzODQsMTI5MDI0LDgwNjQsNTA0LDIxNDc0ODM2NzldLGg9cy5ERVM9YS5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuX2tleS53b3JkcyxlPVtdLG49MDtuPDU2O24rKyl7dmFyIHI9Y1tuXS0xO2Vbbl09dFtyPj4+NV0+Pj4zMS1yJTMyJjF9Zm9yKHZhciBvPXRoaXMuX3N1YktleXM9W10saT0wO2k8MTY7aSsrKXt2YXIgYT1vW2ldPVtdLHM9ZltpXTtmb3Iobj0wO248MjQ7bisrKWFbbi82fDBdfD1lWyh1W25dLTErcyklMjhdPDwzMS1uJTYsYVs0KyhuLzZ8MCldfD1lWzI4Kyh1W24rMjRdLTErcyklMjhdPDwzMS1uJTY7YVswXT1hWzBdPDwxfGFbMF0+Pj4zMTtmb3Iobj0xO248NztuKyspYVtuXT1hW25dPj4+NCoobi0xKSszO2FbN109YVs3XTw8NXxhWzddPj4+Mjd9dmFyIGw9dGhpcy5faW52U3ViS2V5cz1bXTtmb3Iobj0wO248MTY7bisrKWxbbl09b1sxNS1uXX0sZW5jcnlwdEJsb2NrOmZ1bmN0aW9uKHQsZSl7dGhpcy5fZG9DcnlwdEJsb2NrKHQsZSx0aGlzLl9zdWJLZXlzKX0sZGVjcnlwdEJsb2NrOmZ1bmN0aW9uKHQsZSl7dGhpcy5fZG9DcnlwdEJsb2NrKHQsZSx0aGlzLl9pbnZTdWJLZXlzKX0sX2RvQ3J5cHRCbG9jazpmdW5jdGlvbih0LHIsbyl7dGhpcy5fbEJsb2NrPXRbcl0sdGhpcy5fckJsb2NrPXRbcisxXSxlLmNhbGwodGhpcyw0LDI1MjY0NTEzNSksZS5jYWxsKHRoaXMsMTYsNjU1MzUpLG4uY2FsbCh0aGlzLDIsODU4OTkzNDU5KSxuLmNhbGwodGhpcyw4LDE2NzExOTM1KSxlLmNhbGwodGhpcywxLDE0MzE2NTU3NjUpO2Zvcih2YXIgaT0wO2k8MTY7aSsrKXtmb3IodmFyIGE9b1tpXSxzPXRoaXMuX2xCbG9jayxjPXRoaXMuX3JCbG9jayx1PTAsZj0wO2Y8ODtmKyspdXw9bFtmXVsoKGNeYVtmXSkmcFtmXSk+Pj4wXTt0aGlzLl9sQmxvY2s9Yyx0aGlzLl9yQmxvY2s9c151fXZhciBoPXRoaXMuX2xCbG9jazt0aGlzLl9sQmxvY2s9dGhpcy5fckJsb2NrLHRoaXMuX3JCbG9jaz1oLGUuY2FsbCh0aGlzLDEsMTQzMTY1NTc2NSksbi5jYWxsKHRoaXMsOCwxNjcxMTkzNSksbi5jYWxsKHRoaXMsMiw4NTg5OTM0NTkpLGUuY2FsbCh0aGlzLDE2LDY1NTM1KSxlLmNhbGwodGhpcyw0LDI1MjY0NTEzNSksdFtyXT10aGlzLl9sQmxvY2ssdFtyKzFdPXRoaXMuX3JCbG9ja30sa2V5U2l6ZToyLGl2U2l6ZToyLGJsb2NrU2l6ZToyfSk7ci5ERVM9YS5fY3JlYXRlSGVscGVyKGgpO3ZhciBkPXMuVHJpcGxlREVTPWEuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2tleS53b3Jkczt0aGlzLl9kZXMxPWguY3JlYXRlRW5jcnlwdG9yKGkuY3JlYXRlKHQuc2xpY2UoMCwyKSkpLHRoaXMuX2RlczI9aC5jcmVhdGVFbmNyeXB0b3IoaS5jcmVhdGUodC5zbGljZSgyLDQpKSksdGhpcy5fZGVzMz1oLmNyZWF0ZUVuY3J5cHRvcihpLmNyZWF0ZSh0LnNsaWNlKDQsNikpKX0sZW5jcnlwdEJsb2NrOmZ1bmN0aW9uKHQsZSl7dGhpcy5fZGVzMS5lbmNyeXB0QmxvY2sodCxlKSx0aGlzLl9kZXMyLmRlY3J5cHRCbG9jayh0LGUpLHRoaXMuX2RlczMuZW5jcnlwdEJsb2NrKHQsZSl9LGRlY3J5cHRCbG9jazpmdW5jdGlvbih0LGUpe3RoaXMuX2RlczMuZGVjcnlwdEJsb2NrKHQsZSksdGhpcy5fZGVzMi5lbmNyeXB0QmxvY2sodCxlKSx0aGlzLl9kZXMxLmRlY3J5cHRCbG9jayh0LGUpfSxrZXlTaXplOjYsaXZTaXplOjIsYmxvY2tTaXplOjJ9KTtyLlRyaXBsZURFUz1hLl9jcmVhdGVIZWxwZXIoZCl9KCksdC5UcmlwbGVERVN9KX0seyIuL2NpcGhlci1jb3JlIjo1MSwiLi9jb3JlIjo1MiwiLi9lbmMtYmFzZTY0Ijo1MywiLi9ldnBrZGYiOjU1LCIuL21kNSI6NjB9XSw4MzpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8peyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBuPXQscj1uLmxpYixvPXIuQmFzZSxpPXIuV29yZEFycmF5LGE9bi54NjQ9e307YS5Xb3JkPW8uZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKHQsZSl7dGhpcy5oaWdoPXQsdGhpcy5sb3c9ZX19KSxhLldvcmRBcnJheT1vLmV4dGVuZCh7aW5pdDpmdW5jdGlvbih0LGUpe3Q9dGhpcy53b3Jkcz10fHxbXSx0aGlzLnNpZ0J5dGVzPXZvaWQgMCE9ZT9lOjgqdC5sZW5ndGh9LHRvWDMyOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMud29yZHMsZT10Lmxlbmd0aCxuPVtdLHI9MDtyPGU7cisrKXt2YXIgbz10W3JdO24ucHVzaChvLmhpZ2gpLG4ucHVzaChvLmxvdyl9cmV0dXJuIGkuY3JlYXRlKG4sdGhpcy5zaWdCeXRlcyl9LGNsb25lOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW8uY2xvbmUuY2FsbCh0aGlzKSxlPXQud29yZHM9dGhpcy53b3Jkcy5zbGljZSgwKSxuPWUubGVuZ3RoLHI9MDtyPG47cisrKWVbcl09ZVtyXS5jbG9uZSgpO3JldHVybiB0fX0pfSgpLHR9KX0seyIuL2NvcmUiOjUyfV0sODQ6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24odCl7ZnVuY3Rpb24gcih0KXtmb3IodmFyIGUsbixyPVtdLG89MCxpPXQubGVuZ3RoO288aTspKGU9dC5jaGFyQ29kZUF0KG8rKykpPj01NTI5NiYmZTw9NTYzMTkmJm88aT81NjMyMD09KDY0NTEyJihuPXQuY2hhckNvZGVBdChvKyspKSk/ci5wdXNoKCgoMTAyMyZlKTw8MTApKygxMDIzJm4pKzY1NTM2KTooci5wdXNoKGUpLG8tLSk6ci5wdXNoKGUpO3JldHVybiByfWZ1bmN0aW9uIG8odCl7aWYodD49NTUyOTYmJnQ8PTU3MzQzKXRocm93IEVycm9yKCJMb25lIHN1cnJvZ2F0ZSBVKyIrdC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSsiIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSIpfWZ1bmN0aW9uIGkodCxlKXtyZXR1cm4gbSh0Pj5lJjYzfDEyOCl9ZnVuY3Rpb24gYSh0KXtpZigwPT0oNDI5NDk2NzE2OCZ0KSlyZXR1cm4gbSh0KTt2YXIgZT0iIjtyZXR1cm4gMD09KDQyOTQ5NjUyNDgmdCk/ZT1tKHQ+PjYmMzF8MTkyKTowPT0oNDI5NDkwMTc2MCZ0KT8obyh0KSxlPW0odD4+MTImMTV8MjI0KSxlKz1pKHQsNikpOjA9PSg0MjkyODcwMTQ0JnQpJiYoZT1tKHQ+PjE4Jjd8MjQwKSxlKz1pKHQsMTIpLGUrPWkodCw2KSksZSs9bSg2MyZ0fDEyOCl9ZnVuY3Rpb24gcygpe2lmKGQ+PWgpdGhyb3cgRXJyb3IoIkludmFsaWQgYnl0ZSBpbmRleCIpO3ZhciB0PTI1NSZwW2RdO2lmKGQrKywxMjg9PSgxOTImdCkpcmV0dXJuIDYzJnQ7dGhyb3cgRXJyb3IoIkludmFsaWQgY29udGludWF0aW9uIGJ5dGUiKX1mdW5jdGlvbiBjKCl7dmFyIHQsZSxuLHIsaTtpZihkPmgpdGhyb3cgRXJyb3IoIkludmFsaWQgYnl0ZSBpbmRleCIpO2lmKGQ9PWgpcmV0dXJuITE7aWYodD0yNTUmcFtkXSxkKyssMD09KDEyOCZ0KSlyZXR1cm4gdDtpZigxOTI9PSgyMjQmdCkpe2lmKGU9cygpLChpPSgzMSZ0KTw8NnxlKT49MTI4KXJldHVybiBpO3Rocm93IEVycm9yKCJJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlIil9aWYoMjI0PT0oMjQwJnQpKXtpZihlPXMoKSxuPXMoKSwoaT0oMTUmdCk8PDEyfGU8PDZ8bik+PTIwNDgpcmV0dXJuIG8oaSksaTt0aHJvdyBFcnJvcigiSW52YWxpZCBjb250aW51YXRpb24gYnl0ZSIpfWlmKDI0MD09KDI0OCZ0KSYmKGU9cygpLG49cygpLHI9cygpLChpPSg3JnQpPDwxOHxlPDwxMnxuPDw2fHIpPj02NTUzNiYmaTw9MTExNDExMSkpcmV0dXJuIGk7dGhyb3cgRXJyb3IoIkludmFsaWQgVVRGLTggZGV0ZWN0ZWQiKX12YXIgdT0ib2JqZWN0Ij09dHlwZW9mIG4mJm4sZj0ib2JqZWN0Ij09dHlwZW9mIGUmJmUmJmUuZXhwb3J0cz09dSYmZSxsPSJvYmplY3QiPT10eXBlb2YgZ2xvYmFsJiZnbG9iYWw7bC5nbG9iYWwhPT1sJiZsLndpbmRvdyE9PWx8fCh0PWwpO3ZhciBwLGgsZCxtPVN0cmluZy5mcm9tQ2hhckNvZGUseT17dmVyc2lvbjoiMi4xLjIiLGVuY29kZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9cih0KSxuPWUubGVuZ3RoLG89LTEsaT0iIjsrK288bjspaSs9YShlW29dKTtyZXR1cm4gaX0sZGVjb2RlOmZ1bmN0aW9uKHQpe3A9cih0KSxoPXAubGVuZ3RoLGQ9MDtmb3IodmFyIGUsbj1bXTshMSE9PShlPWMoKSk7KW4ucHVzaChlKTtyZXR1cm4gZnVuY3Rpb24odCl7Zm9yKHZhciBlLG49dC5sZW5ndGgscj0tMSxvPSIiOysrcjxuOykoZT10W3JdKT42NTUzNSYmKG8rPW0oKGUtPTY1NTM2KT4+PjEwJjEwMjN8NTUyOTYpLGU9NTYzMjB8MTAyMyZlKSxvKz1tKGUpO3JldHVybiBvfShuKX19O2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJiJvYmplY3QiPT10eXBlb2YgZGVmaW5lLmFtZCYmZGVmaW5lLmFtZClkZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4geX0pO2Vsc2UgaWYodSYmIXUubm9kZVR5cGUpaWYoZilmLmV4cG9ydHM9eTtlbHNle3ZhciBnPXt9Lmhhc093blByb3BlcnR5O2Zvcih2YXIgdiBpbiB5KWcuY2FsbCh5LHYpJiYodVt2XT15W3ZdKX1lbHNlIHQudXRmOD15fSh0aGlzKX0se31dLDg1OltmdW5jdGlvbih0LGUsbil7ZS5leHBvcnRzPVhNTEh0dHBSZXF1ZXN0fSx7fV0sImJpZ251bWJlci5qcyI6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24odCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIG4odCl7ZnVuY3Rpb24gZSh0LG4pe3ZhciByLG8saSxhLHMsYyx1PXRoaXM7aWYoISh1IGluc3RhbmNlb2YgZSkpcmV0dXJuIFUmJkkoMjYsImNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBuZXciLHQpLG5ldyBlKHQsbik7aWYobnVsbCE9biYmVyhuLDIsNjQsRCwiYmFzZSIpKXtpZihufD0wLGM9dCsiIiwxMD09bilyZXR1cm4gdT1uZXcgZSh0IGluc3RhbmNlb2YgZT90OmMpLE4odSxNK3UuZSsxLEgpO2lmKChhPSJudW1iZXIiPT10eXBlb2YgdCkmJjAqdCE9MHx8IW5ldyBSZWdFeHAoIl4tPyIrKHI9IlsiK2Iuc2xpY2UoMCxuKSsiXSsiKSsiKD86XFwuIityKyIpPyQiLG48Mzc/ImkiOiIiKS50ZXN0KGMpKXJldHVybiBQKHUsYyxhLG4pO2E/KHUucz0xL3Q8MD8oYz1jLnNsaWNlKDEpLC0xKToxLFUmJmMucmVwbGFjZSgvXjBcLjAqfFwuLywiIikubGVuZ3RoPjE1JiZJKEQsdix0KSxhPSExKTp1LnM9NDU9PT1jLmNoYXJDb2RlQXQoMCk/KGM9Yy5zbGljZSgxKSwtMSk6MSxjPXAoYywxMCxuLHUucyl9ZWxzZXtpZih0IGluc3RhbmNlb2YgZSlyZXR1cm4gdS5zPXQucyx1LmU9dC5lLHUuYz0odD10LmMpP3Quc2xpY2UoKTp0LHZvaWQoRD0wKTtpZigoYT0ibnVtYmVyIj09dHlwZW9mIHQpJiYwKnQ9PTApe2lmKHUucz0xL3Q8MD8odD0tdCwtMSk6MSx0PT09fn50KXtmb3Iobz0wLGk9dDtpPj0xMDtpLz0xMCxvKyspO3JldHVybiB1LmU9byx1LmM9W3RdLHZvaWQoRD0wKX1jPXQrIiJ9ZWxzZXtpZighaC50ZXN0KGM9dCsiIikpcmV0dXJuIFAodSxjLGEpO3Uucz00NT09PWMuY2hhckNvZGVBdCgwKT8oYz1jLnNsaWNlKDEpLC0xKToxfX1mb3IoKG89Yy5pbmRleE9mKCIuIikpPi0xJiYoYz1jLnJlcGxhY2UoIi4iLCIiKSksKGk9Yy5zZWFyY2goL2UvaSkpPjA/KG88MCYmKG89aSksbys9K2Muc2xpY2UoaSsxKSxjPWMuc3Vic3RyaW5nKDAsaSkpOm88MCYmKG89Yy5sZW5ndGgpLGk9MDs0OD09PWMuY2hhckNvZGVBdChpKTtpKyspO2ZvcihzPWMubGVuZ3RoOzQ4PT09Yy5jaGFyQ29kZUF0KC0tcyk7KTtpZihjPWMuc2xpY2UoaSxzKzEpKWlmKHM9Yy5sZW5ndGgsYSYmVSYmcz4xNSYmKHQ+eHx8dCE9PW0odCkpJiZJKEQsdix1LnMqdCksKG89by1pLTEpPkwpdS5jPXUuZT1udWxsO2Vsc2UgaWYobzx6KXUuYz1bdS5lPTBdO2Vsc2V7aWYodS5lPW8sdS5jPVtdLGk9KG8rMSkldyxvPDAmJihpKz13KSxpPHMpe2ZvcihpJiZ1LmMucHVzaCgrYy5zbGljZSgwLGkpKSxzLT13O2k8czspdS5jLnB1c2goK2Muc2xpY2UoaSxpKz13KSk7Yz1jLnNsaWNlKGkpLGk9dy1jLmxlbmd0aH1lbHNlIGktPXM7Zm9yKDtpLS07Yys9IjAiKTt1LmMucHVzaCgrYyl9ZWxzZSB1LmM9W3UuZT0wXTtEPTB9ZnVuY3Rpb24gcCh0LG4scixpKXt2YXIgYSxzLHUsbCxwLGgsZCxtPXQuaW5kZXhPZigiLiIpLHk9TSxnPUg7Zm9yKHI8MzcmJih0PXQudG9Mb3dlckNhc2UoKSksbT49MCYmKHU9RyxHPTAsdD10LnJlcGxhY2UoIi4iLCIiKSxwPShkPW5ldyBlKHIpKS5wb3codC5sZW5ndGgtbSksRz11LGQuYz1jKGYobyhwLmMpLHAuZSksMTAsbiksZC5lPWQuYy5sZW5ndGgpLHM9dT0oaD1jKHQscixuKSkubGVuZ3RoOzA9PWhbLS11XTtoLnBvcCgpKTtpZighaFswXSlyZXR1cm4iMCI7aWYobTwwPy0tczoocC5jPWgscC5lPXMscC5zPWksaD0ocD1UKHAsZCx5LGcsbikpLmMsbD1wLnIscz1wLmUpLGE9cyt5KzEsbT1oW2FdLHU9bi8yLGw9bHx8YTwwfHxudWxsIT1oW2ErMV0sbD1nPDQ/KG51bGwhPW18fGwpJiYoMD09Z3x8Zz09KHAuczwwPzM6MikpOm0+dXx8bT09dSYmKDQ9PWd8fGx8fDY9PWcmJjEmaFthLTFdfHxnPT0ocC5zPDA/ODo3KSksYTwxfHwhaFswXSl0PWw/ZigiMSIsLXkpOiIwIjtlbHNle2lmKGgubGVuZ3RoPWEsbClmb3IoLS1uOysraFstLWFdPm47KWhbYV09MCxhfHwoKytzLGg9WzFdLmNvbmNhdChoKSk7Zm9yKHU9aC5sZW5ndGg7IWhbLS11XTspO2ZvcihtPTAsdD0iIjttPD11O3QrPWIuY2hhckF0KGhbbSsrXSkpO3Q9Zih0LHMpfXJldHVybiB0fWZ1bmN0aW9uIEEodCxuLHIsaSl7dmFyIGEscyxjLGwscDtpZihyPW51bGwhPXImJlcociwwLDgsaSxnKT8wfHI6SCwhdC5jKXJldHVybiB0LnRvU3RyaW5nKCk7aWYoYT10LmNbMF0sYz10LmUsbnVsbD09bilwPW8odC5jKSxwPTE5PT1pfHwyND09aSYmYzw9aj91KHAsYyk6ZihwLGMpO2Vsc2UgaWYodD1OKG5ldyBlKHQpLG4scikscz10LmUscD1vKHQuYyksbD1wLmxlbmd0aCwxOT09aXx8MjQ9PWkmJihuPD1zfHxzPD1qKSl7Zm9yKDtsPG47cCs9IjAiLGwrKyk7cD11KHAscyl9ZWxzZSBpZihuLT1jLHA9ZihwLHMpLHMrMT5sKXtpZigtLW4+MClmb3IocCs9Ii4iO24tLTtwKz0iMCIpO31lbHNlIGlmKChuKz1zLWwpPjApZm9yKHMrMT09bCYmKHArPSIuIik7bi0tO3ArPSIwIik7cmV0dXJuIHQuczwwJiZhPyItIitwOnB9ZnVuY3Rpb24gQyh0LG4pe3ZhciByLG8saT0wO2ZvcihzKHRbMF0pJiYodD10WzBdKSxyPW5ldyBlKHRbMF0pOysraTx0Lmxlbmd0aDspe2lmKCEobz1uZXcgZSh0W2ldKSkucyl7cj1vO2JyZWFrfW4uY2FsbChyLG8pJiYocj1vKX1yZXR1cm4gcn1mdW5jdGlvbiBGKHQsZSxuLHIsbyl7cmV0dXJuKHQ8ZXx8dD5ufHx0IT1sKHQpKSYmSShyLChvfHwiZGVjaW1hbCBwbGFjZXMiKSsodDxlfHx0Pm4/IiBvdXQgb2YgcmFuZ2UiOiIgbm90IGFuIGludGVnZXIiKSx0KSwhMH1mdW5jdGlvbiBPKHQsZSxuKXtmb3IodmFyIHI9MSxvPWUubGVuZ3RoOyFlWy0tb107ZS5wb3AoKSk7Zm9yKG89ZVswXTtvPj0xMDtvLz0xMCxyKyspO3JldHVybihuPXIrbip3LTEpPkw/dC5jPXQuZT1udWxsOm48ej90LmM9W3QuZT0wXToodC5lPW4sdC5jPWUpLHR9ZnVuY3Rpb24gSSh0LGUsbil7dmFyIHI9bmV3IEVycm9yKFsibmV3IEJpZ051bWJlciIsImNtcCIsImNvbmZpZyIsImRpdiIsImRpdlRvSW50IiwiZXEiLCJndCIsImd0ZSIsImx0IiwibHRlIiwibWludXMiLCJtb2QiLCJwbHVzIiwicHJlY2lzaW9uIiwicmFuZG9tIiwicm91bmQiLCJzaGlmdCIsInRpbWVzIiwidG9EaWdpdHMiLCJ0b0V4cG9uZW50aWFsIiwidG9GaXhlZCIsInRvRm9ybWF0IiwidG9GcmFjdGlvbiIsInBvdyIsInRvUHJlY2lzaW9uIiwidG9TdHJpbmciLCJCaWdOdW1iZXIiXVt0XSsiKCkgIitlKyI6ICIrbik7dGhyb3cgci5uYW1lPSJCaWdOdW1iZXIgRXJyb3IiLEQ9MCxyfWZ1bmN0aW9uIE4odCxlLG4scil7dmFyIG8saSxhLHMsYyx1LGYsbD10LmMscD1rO2lmKGwpe3Q6e2ZvcihvPTEscz1sWzBdO3M+PTEwO3MvPTEwLG8rKyk7aWYoKGk9ZS1vKTwwKWkrPXcsYT1lLGY9KGM9bFt1PTBdKS9wW28tYS0xXSUxMHwwO2Vsc2UgaWYoKHU9ZCgoaSsxKS93KSk+PWwubGVuZ3RoKXtpZighcilicmVhayB0O2Zvcig7bC5sZW5ndGg8PXU7bC5wdXNoKDApKTtjPWY9MCxvPTEsYT0oaSU9dyktdysxfWVsc2V7Zm9yKGM9cz1sW3VdLG89MTtzPj0xMDtzLz0xMCxvKyspO2Y9KGE9KGklPXcpLXcrbyk8MD8wOmMvcFtvLWEtMV0lMTB8MH1pZihyPXJ8fGU8MHx8bnVsbCE9bFt1KzFdfHwoYTwwP2M6YyVwW28tYS0xXSkscj1uPDQ/KGZ8fHIpJiYoMD09bnx8bj09KHQuczwwPzM6MikpOmY+NXx8NT09ZiYmKDQ9PW58fHJ8fDY9PW4mJihpPjA/YT4wP2MvcFtvLWFdOjA6bFt1LTFdKSUxMCYxfHxuPT0odC5zPDA/ODo3KSksZTwxfHwhbFswXSlyZXR1cm4gbC5sZW5ndGg9MCxyPyhlLT10LmUrMSxsWzBdPXBbKHctZSV3KSV3XSx0LmU9LWV8fDApOmxbMF09dC5lPTAsdDtpZigwPT1pPyhsLmxlbmd0aD11LHM9MSx1LS0pOihsLmxlbmd0aD11KzEscz1wW3ctaV0sbFt1XT1hPjA/bShjL3Bbby1hXSVwW2FdKSpzOjApLHIpZm9yKDs7KXtpZigwPT11KXtmb3IoaT0xLGE9bFswXTthPj0xMDthLz0xMCxpKyspO2ZvcihhPWxbMF0rPXMscz0xO2E+PTEwO2EvPTEwLHMrKyk7aSE9cyYmKHQuZSsrLGxbMF09PV8mJihsWzBdPTEpKTticmVha31pZihsW3VdKz1zLGxbdV0hPV8pYnJlYWs7bFt1LS1dPTAscz0xfWZvcihpPWwubGVuZ3RoOzA9PT1sWy0taV07bC5wb3AoKSk7fXQuZT5MP3QuYz10LmU9bnVsbDp0LmU8eiYmKHQuYz1bdC5lPTBdKX1yZXR1cm4gdH12YXIgVCxQLEQ9MCxSPWUucHJvdG90eXBlLEU9bmV3IGUoMSksTT0yMCxIPTQsaj0tNyxxPTIxLHo9LTFlNyxMPTFlNyxVPSEwLFc9RixKPSExLEs9MSxHPTAsWD17ZGVjaW1hbFNlcGFyYXRvcjoiLiIsZ3JvdXBTZXBhcmF0b3I6IiwiLGdyb3VwU2l6ZTozLHNlY29uZGFyeUdyb3VwU2l6ZTowLGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6IsKgIixmcmFjdGlvbkdyb3VwU2l6ZTowfTtyZXR1cm4gZS5hbm90aGVyPW4sZS5ST1VORF9VUD0wLGUuUk9VTkRfRE9XTj0xLGUuUk9VTkRfQ0VJTD0yLGUuUk9VTkRfRkxPT1I9MyxlLlJPVU5EX0hBTEZfVVA9NCxlLlJPVU5EX0hBTEZfRE9XTj01LGUuUk9VTkRfSEFMRl9FVkVOPTYsZS5ST1VORF9IQUxGX0NFSUw9NyxlLlJPVU5EX0hBTEZfRkxPT1I9OCxlLkVVQ0xJRD05LGUuY29uZmlnPWUuc2V0PWZ1bmN0aW9uKCl7dmFyIHQsZSxuPTAscj17fSxvPWFyZ3VtZW50cyxpPW9bMF0sYz1pJiYib2JqZWN0Ij09dHlwZW9mIGk/ZnVuY3Rpb24oKXtpZihpLmhhc093blByb3BlcnR5KGUpKXJldHVybiBudWxsIT0odD1pW2VdKX06ZnVuY3Rpb24oKXtpZihvLmxlbmd0aD5uKXJldHVybiBudWxsIT0odD1vW24rK10pfTtyZXR1cm4gYyhlPSJERUNJTUFMX1BMQUNFUyIpJiZXKHQsMCxTLDIsZSkmJihNPTB8dCkscltlXT1NLGMoZT0iUk9VTkRJTkdfTU9ERSIpJiZXKHQsMCw4LDIsZSkmJihIPTB8dCkscltlXT1ILGMoZT0iRVhQT05FTlRJQUxfQVQiKSYmKHModCk/Vyh0WzBdLC1TLDAsMixlKSYmVyh0WzFdLDAsUywyLGUpJiYoaj0wfHRbMF0scT0wfHRbMV0pOlcodCwtUyxTLDIsZSkmJihqPS0ocT0wfCh0PDA/LXQ6dCkpKSkscltlXT1baixxXSxjKGU9IlJBTkdFIikmJihzKHQpP1codFswXSwtUywtMSwyLGUpJiZXKHRbMV0sMSxTLDIsZSkmJih6PTB8dFswXSxMPTB8dFsxXSk6Vyh0LC1TLFMsMixlKSYmKDB8dD96PS0oTD0wfCh0PDA/LXQ6dCkpOlUmJkkoMixlKyIgY2Fubm90IGJlIHplcm8iLHQpKSkscltlXT1beixMXSxjKGU9IkVSUk9SUyIpJiYodD09PSEhdHx8MT09PXR8fDA9PT10PyhEPTAsVz0oVT0hIXQpP0Y6YSk6VSYmSSgyLGUreSx0KSkscltlXT1VLGMoZT0iQ1JZUFRPIikmJighMD09PXR8fCExPT09dHx8MT09PXR8fDA9PT10P3Q/ISh0PSJ1bmRlZmluZWQiPT10eXBlb2YgY3J5cHRvKSYmY3J5cHRvJiYoY3J5cHRvLmdldFJhbmRvbVZhbHVlc3x8Y3J5cHRvLnJhbmRvbUJ5dGVzKT9KPSEwOlU/SSgyLCJjcnlwdG8gdW5hdmFpbGFibGUiLHQ/dm9pZCAwOmNyeXB0byk6Sj0hMTpKPSExOlUmJkkoMixlK3ksdCkpLHJbZV09SixjKGU9Ik1PRFVMT19NT0RFIikmJlcodCwwLDksMixlKSYmKEs9MHx0KSxyW2VdPUssYyhlPSJQT1dfUFJFQ0lTSU9OIikmJlcodCwwLFMsMixlKSYmKEc9MHx0KSxyW2VdPUcsYyhlPSJGT1JNQVQiKSYmKCJvYmplY3QiPT10eXBlb2YgdD9YPXQ6VSYmSSgyLGUrIiBub3QgYW4gb2JqZWN0Iix0KSkscltlXT1YLHJ9LGUubWF4PWZ1bmN0aW9uKCl7cmV0dXJuIEMoYXJndW1lbnRzLFIubHQpfSxlLm1pbj1mdW5jdGlvbigpe3JldHVybiBDKGFyZ3VtZW50cyxSLmd0KX0sZS5yYW5kb209ZnVuY3Rpb24oKXt2YXIgdD05MDA3MTk5MjU0NzQwOTkyKk1hdGgucmFuZG9tKCkmMjA5NzE1MT9mdW5jdGlvbigpe3JldHVybiBtKDkwMDcxOTkyNTQ3NDA5OTIqTWF0aC5yYW5kb20oKSl9OmZ1bmN0aW9uKCl7cmV0dXJuIDgzODg2MDgqKDEwNzM3NDE4MjQqTWF0aC5yYW5kb20oKXwwKSsoODM4ODYwOCpNYXRoLnJhbmRvbSgpfDApfTtyZXR1cm4gZnVuY3Rpb24obil7dmFyIHIsbyxpLGEscyxjPTAsdT1bXSxmPW5ldyBlKEUpO2lmKG49bnVsbCE9biYmVyhuLDAsUywxNCk/MHxuOk0sYT1kKG4vdyksSilpZihjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXtmb3Iocj1jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShhKj0yKSk7YzxhOykocz0xMzEwNzIqcltjXSsocltjKzFdPj4+MTEpKT49OWUxNT8obz1jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSkscltjXT1vWzBdLHJbYysxXT1vWzFdKToodS5wdXNoKHMlMWUxNCksYys9Mik7Yz1hLzJ9ZWxzZSBpZihjcnlwdG8ucmFuZG9tQnl0ZXMpe2ZvcihyPWNyeXB0by5yYW5kb21CeXRlcyhhKj03KTtjPGE7KShzPTI4MTQ3NDk3NjcxMDY1NiooMzEmcltjXSkrMTA5OTUxMTYyNzc3NipyW2MrMV0rNDI5NDk2NzI5NipyW2MrMl0rMTY3NzcyMTYqcltjKzNdKyhyW2MrNF08PDE2KSsocltjKzVdPDw4KStyW2MrNl0pPj05ZTE1P2NyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KHIsYyk6KHUucHVzaChzJTFlMTQpLGMrPTcpO2M9YS83fWVsc2UgSj0hMSxVJiZJKDE0LCJjcnlwdG8gdW5hdmFpbGFibGUiLGNyeXB0byk7aWYoIUopZm9yKDtjPGE7KShzPXQoKSk8OWUxNSYmKHVbYysrXT1zJTFlMTQpO2ZvcihhPXVbLS1jXSxuJT13LGEmJm4mJihzPWtbdy1uXSx1W2NdPW0oYS9zKSpzKTswPT09dVtjXTt1LnBvcCgpLGMtLSk7aWYoYzwwKXU9W2k9MF07ZWxzZXtmb3IoaT0tMTswPT09dVswXTt1LnNwbGljZSgwLDEpLGktPXcpO2ZvcihjPTEscz11WzBdO3M+PTEwO3MvPTEwLGMrKyk7Yzx3JiYoaS09dy1jKX1yZXR1cm4gZi5lPWksZi5jPXUsZn19KCksVD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLG4pe3ZhciByLG8saSxhLHM9MCxjPXQubGVuZ3RoLHU9ZSVCLGY9ZS9CfDA7Zm9yKHQ9dC5zbGljZSgpO2MtLTspcz0oKG89dSooaT10W2NdJUIpKyhyPWYqaSsoYT10W2NdL0J8MCkqdSklQipCK3MpL258MCkrKHIvQnwwKStmKmEsdFtjXT1vJW47cmV0dXJuIHMmJih0PVtzXS5jb25jYXQodCkpLHR9ZnVuY3Rpb24gbih0LGUsbixyKXt2YXIgbyxpO2lmKG4hPXIpaT1uPnI/MTotMTtlbHNlIGZvcihvPWk9MDtvPG47bysrKWlmKHRbb10hPWVbb10pe2k9dFtvXT5lW29dPzE6LTE7YnJlYWt9cmV0dXJuIGl9ZnVuY3Rpb24gbyh0LGUsbixyKXtmb3IodmFyIG89MDtuLS07KXRbbl0tPW8sbz10W25dPGVbbl0/MTowLHRbbl09bypyK3Rbbl0tZVtuXTtmb3IoOyF0WzBdJiZ0Lmxlbmd0aD4xO3Quc3BsaWNlKDAsMSkpO31yZXR1cm4gZnVuY3Rpb24oaSxhLHMsYyx1KXt2YXIgZixsLHAsaCxkLHksZyx2LGIseCxrLEIsUyxBLEMsRixPLEk9aS5zPT1hLnM/MTotMSxUPWkuYyxQPWEuYztpZighKFQmJlRbMF0mJlAmJlBbMF0pKXJldHVybiBuZXcgZShpLnMmJmEucyYmKFQ/IVB8fFRbMF0hPVBbMF06UCk/VCYmMD09VFswXXx8IVA/MCpJOkkvMDpOYU4pO2ZvcihiPSh2PW5ldyBlKEkpKS5jPVtdLEk9cysobD1pLmUtYS5lKSsxLHV8fCh1PV8sbD1yKGkuZS93KS1yKGEuZS93KSxJPUkvd3wwKSxwPTA7UFtwXT09KFRbcF18fDApO3ArKyk7aWYoUFtwXT4oVFtwXXx8MCkmJmwtLSxJPDApYi5wdXNoKDEpLGg9ITA7ZWxzZXtmb3IoQT1ULmxlbmd0aCxGPVAubGVuZ3RoLHA9MCxJKz0yLChkPW0odS8oUFswXSsxKSkpPjEmJihQPXQoUCxkLHUpLFQ9dChULGQsdSksRj1QLmxlbmd0aCxBPVQubGVuZ3RoKSxTPUYsaz0oeD1ULnNsaWNlKDAsRikpLmxlbmd0aDtrPEY7eFtrKytdPTApO089UC5zbGljZSgpLE89WzBdLmNvbmNhdChPKSxDPVBbMF0sUFsxXT49dS8yJiZDKys7ZG97aWYoZD0wLChmPW4oUCx4LEYsaykpPDApe2lmKEI9eFswXSxGIT1rJiYoQj1CKnUrKHhbMV18fDApKSwoZD1tKEIvQykpPjEpZm9yKGQ+PXUmJihkPXUtMSksZz0oeT10KFAsZCx1KSkubGVuZ3RoLGs9eC5sZW5ndGg7MT09bih5LHgsZyxrKTspZC0tLG8oeSxGPGc/TzpQLGcsdSksZz15Lmxlbmd0aCxmPTE7ZWxzZSAwPT1kJiYoZj1kPTEpLGc9KHk9UC5zbGljZSgpKS5sZW5ndGg7aWYoZzxrJiYoeT1bMF0uY29uY2F0KHkpKSxvKHgseSxrLHUpLGs9eC5sZW5ndGgsLTE9PWYpZm9yKDtuKFAseCxGLGspPDE7KWQrKyxvKHgsRjxrP086UCxrLHUpLGs9eC5sZW5ndGh9ZWxzZSAwPT09ZiYmKGQrKyx4PVswXSk7YltwKytdPWQseFswXT94W2srK109VFtTXXx8MDooeD1bVFtTXV0saz0xKX13aGlsZSgoUysrPEF8fG51bGwhPXhbMF0pJiZJLS0pO2g9bnVsbCE9eFswXSxiWzBdfHxiLnNwbGljZSgwLDEpfWlmKHU9PV8pe2ZvcihwPTEsST1iWzBdO0k+PTEwO0kvPTEwLHArKyk7Tih2LHMrKHYuZT1wK2wqdy0xKSsxLGMsaCl9ZWxzZSB2LmU9bCx2LnI9K2g7cmV0dXJuIHZ9fSgpLFA9ZnVuY3Rpb24oKXt2YXIgdD0vXigtPykwKFt4Ym9dKSg/PVx3W1x3Ll0qJCkvaSxuPS9eKFteLl0rKVwuJC8scj0vXlwuKFteLl0rKSQvLG89L14tPyhJbmZpbml0eXxOYU4pJC8saT0vXlxzKlwrKD89W1x3Ll0pfF5ccyt8XHMrJC9nO3JldHVybiBmdW5jdGlvbihhLHMsYyx1KXt2YXIgZixsPWM/czpzLnJlcGxhY2UoaSwiIik7aWYoby50ZXN0KGwpKWEucz1pc05hTihsKT9udWxsOmw8MD8tMToxO2Vsc2V7aWYoIWMmJihsPWwucmVwbGFjZSh0LGZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gZj0ieCI9PShuPW4udG9Mb3dlckNhc2UoKSk/MTY6ImIiPT1uPzI6OCx1JiZ1IT1mP3Q6ZX0pLHUmJihmPXUsbD1sLnJlcGxhY2UobiwiJDEiKS5yZXBsYWNlKHIsIjAuJDEiKSkscyE9bCkpcmV0dXJuIG5ldyBlKGwsZik7VSYmSShELCJub3QgYSIrKHU/IiBiYXNlICIrdToiIikrIiBudW1iZXIiLHMpLGEucz1udWxsfWEuYz1hLmU9bnVsbCxEPTB9fSgpLFIuYWJzb2x1dGVWYWx1ZT1SLmFicz1mdW5jdGlvbigpe3ZhciB0PW5ldyBlKHRoaXMpO3JldHVybiB0LnM8MCYmKHQucz0xKSx0fSxSLmNlaWw9ZnVuY3Rpb24oKXtyZXR1cm4gTihuZXcgZSh0aGlzKSx0aGlzLmUrMSwyKX0sUi5jb21wYXJlZFRvPVIuY21wPWZ1bmN0aW9uKHQsbil7cmV0dXJuIEQ9MSxpKHRoaXMsbmV3IGUodCxuKSl9LFIuZGVjaW1hbFBsYWNlcz1SLmRwPWZ1bmN0aW9uKCl7dmFyIHQsZSxuPXRoaXMuYztpZighbilyZXR1cm4gbnVsbDtpZih0PSgoZT1uLmxlbmd0aC0xKS1yKHRoaXMuZS93KSkqdyxlPW5bZV0pZm9yKDtlJTEwPT0wO2UvPTEwLHQtLSk7cmV0dXJuIHQ8MCYmKHQ9MCksdH0sUi5kaXZpZGVkQnk9Ui5kaXY9ZnVuY3Rpb24odCxuKXtyZXR1cm4gRD0zLFQodGhpcyxuZXcgZSh0LG4pLE0sSCl9LFIuZGl2aWRlZFRvSW50ZWdlckJ5PVIuZGl2VG9JbnQ9ZnVuY3Rpb24odCxuKXtyZXR1cm4gRD00LFQodGhpcyxuZXcgZSh0LG4pLDAsMSl9LFIuZXF1YWxzPVIuZXE9ZnVuY3Rpb24odCxuKXtyZXR1cm4gRD01LDA9PT1pKHRoaXMsbmV3IGUodCxuKSl9LFIuZmxvb3I9ZnVuY3Rpb24oKXtyZXR1cm4gTihuZXcgZSh0aGlzKSx0aGlzLmUrMSwzKX0sUi5ncmVhdGVyVGhhbj1SLmd0PWZ1bmN0aW9uKHQsbil7cmV0dXJuIEQ9NixpKHRoaXMsbmV3IGUodCxuKSk+MH0sUi5ncmVhdGVyVGhhbk9yRXF1YWxUbz1SLmd0ZT1mdW5jdGlvbih0LG4pe3JldHVybiBEPTcsMT09PShuPWkodGhpcyxuZXcgZSh0LG4pKSl8fDA9PT1ufSxSLmlzRmluaXRlPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmN9LFIuaXNJbnRlZ2VyPVIuaXNJbnQ9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuYyYmcih0aGlzLmUvdyk+dGhpcy5jLmxlbmd0aC0yfSxSLmlzTmFOPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuc30sUi5pc05lZ2F0aXZlPVIuaXNOZWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zPDB9LFIuaXNaZXJvPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmMmJjA9PXRoaXMuY1swXX0sUi5sZXNzVGhhbj1SLmx0PWZ1bmN0aW9uKHQsbil7cmV0dXJuIEQ9OCxpKHRoaXMsbmV3IGUodCxuKSk8MH0sUi5sZXNzVGhhbk9yRXF1YWxUbz1SLmx0ZT1mdW5jdGlvbih0LG4pe3JldHVybiBEPTksLTE9PT0obj1pKHRoaXMsbmV3IGUodCxuKSkpfHwwPT09bn0sUi5taW51cz1SLnN1Yj1mdW5jdGlvbih0LG4pe3ZhciBvLGksYSxzLGM9dGhpcy5zO2lmKEQ9MTAsdD1uZXcgZSh0LG4pLG49dC5zLCFjfHwhbilyZXR1cm4gbmV3IGUoTmFOKTtpZihjIT1uKXJldHVybiB0LnM9LW4sdGhpcy5wbHVzKHQpO3ZhciB1PXRoaXMuZS93LGY9dC5lL3csbD10aGlzLmMscD10LmM7aWYoIXV8fCFmKXtpZighbHx8IXApcmV0dXJuIGw/KHQucz0tbix0KTpuZXcgZShwP3RoaXM6TmFOKTtpZighbFswXXx8IXBbMF0pcmV0dXJuIHBbMF0/KHQucz0tbix0KTpuZXcgZShsWzBdP3RoaXM6Mz09SD8tMDowKX1pZih1PXIodSksZj1yKGYpLGw9bC5zbGljZSgpLGM9dS1mKXtmb3IoKHM9YzwwKT8oYz0tYyxhPWwpOihmPXUsYT1wKSxhLnJldmVyc2UoKSxuPWM7bi0tO2EucHVzaCgwKSk7YS5yZXZlcnNlKCl9ZWxzZSBmb3IoaT0ocz0oYz1sLmxlbmd0aCk8KG49cC5sZW5ndGgpKT9jOm4sYz1uPTA7bjxpO24rKylpZihsW25dIT1wW25dKXtzPWxbbl08cFtuXTticmVha31pZihzJiYoYT1sLGw9cCxwPWEsdC5zPS10LnMpLChuPShpPXAubGVuZ3RoKS0obz1sLmxlbmd0aCkpPjApZm9yKDtuLS07bFtvKytdPTApO2ZvcihuPV8tMTtpPmM7KXtpZihsWy0taV08cFtpXSl7Zm9yKG89aTtvJiYhbFstLW9dO2xbb109bik7LS1sW29dLGxbaV0rPV99bFtpXS09cFtpXX1mb3IoOzA9PWxbMF07bC5zcGxpY2UoMCwxKSwtLWYpO3JldHVybiBsWzBdP08odCxsLGYpOih0LnM9Mz09SD8tMToxLHQuYz1bdC5lPTBdLHQpfSxSLm1vZHVsbz1SLm1vZD1mdW5jdGlvbih0LG4pe3ZhciByLG87cmV0dXJuIEQ9MTEsdD1uZXcgZSh0LG4pLCF0aGlzLmN8fCF0LnN8fHQuYyYmIXQuY1swXT9uZXcgZShOYU4pOiF0LmN8fHRoaXMuYyYmIXRoaXMuY1swXT9uZXcgZSh0aGlzKTooOT09Sz8obz10LnMsdC5zPTEscj1UKHRoaXMsdCwwLDMpLHQucz1vLHIucyo9byk6cj1UKHRoaXMsdCwwLEspLHRoaXMubWludXMoci50aW1lcyh0KSkpfSxSLm5lZ2F0ZWQ9Ui5uZWc9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgZSh0aGlzKTtyZXR1cm4gdC5zPS10LnN8fG51bGwsdH0sUi5wbHVzPVIuYWRkPWZ1bmN0aW9uKHQsbil7dmFyIG8saT10aGlzLnM7aWYoRD0xMix0PW5ldyBlKHQsbiksbj10LnMsIWl8fCFuKXJldHVybiBuZXcgZShOYU4pO2lmKGkhPW4pcmV0dXJuIHQucz0tbix0aGlzLm1pbnVzKHQpO3ZhciBhPXRoaXMuZS93LHM9dC5lL3csYz10aGlzLmMsdT10LmM7aWYoIWF8fCFzKXtpZighY3x8IXUpcmV0dXJuIG5ldyBlKGkvMCk7aWYoIWNbMF18fCF1WzBdKXJldHVybiB1WzBdP3Q6bmV3IGUoY1swXT90aGlzOjAqaSl9aWYoYT1yKGEpLHM9cihzKSxjPWMuc2xpY2UoKSxpPWEtcyl7Zm9yKGk+MD8ocz1hLG89dSk6KGk9LWksbz1jKSxvLnJldmVyc2UoKTtpLS07by5wdXNoKDApKTtvLnJldmVyc2UoKX1mb3IoKGk9Yy5sZW5ndGgpLShuPXUubGVuZ3RoKTwwJiYobz11LHU9YyxjPW8sbj1pKSxpPTA7bjspaT0oY1stLW5dPWNbbl0rdVtuXStpKS9ffDAsY1tuXT1fPT09Y1tuXT8wOmNbbl0lXztyZXR1cm4gaSYmKGM9W2ldLmNvbmNhdChjKSwrK3MpLE8odCxjLHMpfSxSLnByZWNpc2lvbj1SLnNkPWZ1bmN0aW9uKHQpe3ZhciBlLG4scj10aGlzLmM7aWYobnVsbCE9dCYmdCE9PSEhdCYmMSE9PXQmJjAhPT10JiYoVSYmSSgxMywiYXJndW1lbnQiK3ksdCksdCE9ISF0JiYodD1udWxsKSksIXIpcmV0dXJuIG51bGw7aWYobj1yLmxlbmd0aC0xLGU9bip3KzEsbj1yW25dKXtmb3IoO24lMTA9PTA7bi89MTAsZS0tKTtmb3Iobj1yWzBdO24+PTEwO24vPTEwLGUrKyk7fXJldHVybiB0JiZ0aGlzLmUrMT5lJiYoZT10aGlzLmUrMSksZX0sUi5yb3VuZD1mdW5jdGlvbih0LG4pe3ZhciByPW5ldyBlKHRoaXMpO3JldHVybihudWxsPT10fHxXKHQsMCxTLDE1KSkmJk4ocix+fnQrdGhpcy5lKzEsbnVsbCE9biYmVyhuLDAsOCwxNSxnKT8wfG46SCkscn0sUi5zaGlmdD1mdW5jdGlvbih0KXtyZXR1cm4gVyh0LC14LHgsMTYsImFyZ3VtZW50Iik/dGhpcy50aW1lcygiMWUiK2wodCkpOm5ldyBlKHRoaXMuYyYmdGhpcy5jWzBdJiYodDwteHx8dD54KT90aGlzLnMqKHQ8MD8wOjEvMCk6dGhpcyl9LFIuc3F1YXJlUm9vdD1SLnNxcnQ9ZnVuY3Rpb24oKXt2YXIgdCxuLGksYSxzLGM9dGhpcy5jLHU9dGhpcy5zLGY9dGhpcy5lLGw9TSs0LHA9bmV3IGUoIjAuNSIpO2lmKDEhPT11fHwhY3x8IWNbMF0pcmV0dXJuIG5ldyBlKCF1fHx1PDAmJighY3x8Y1swXSk/TmFOOmM/dGhpczoxLzApO2lmKDA9PSh1PU1hdGguc3FydCgrdGhpcykpfHx1PT0xLzA/KCgobj1vKGMpKS5sZW5ndGgrZiklMj09MCYmKG4rPSIwIiksdT1NYXRoLnNxcnQobiksZj1yKChmKzEpLzIpLShmPDB8fGYlMiksaT1uZXcgZShuPXU9PTEvMD8iMWUiK2Y6KG49dS50b0V4cG9uZW50aWFsKCkpLnNsaWNlKDAsbi5pbmRleE9mKCJlIikrMSkrZikpOmk9bmV3IGUodSsiIiksaS5jWzBdKWZvcigodT0oZj1pLmUpK2wpPDMmJih1PTApOzspaWYocz1pLGk9cC50aW1lcyhzLnBsdXMoVCh0aGlzLHMsbCwxKSkpLG8ocy5jKS5zbGljZSgwLHUpPT09KG49byhpLmMpKS5zbGljZSgwLHUpKXtpZihpLmU8ZiYmLS11LCI5OTk5IiE9KG49bi5zbGljZSh1LTMsdSsxKSkmJihhfHwiNDk5OSIhPW4pKXsrbiYmKCtuLnNsaWNlKDEpfHwiNSIhPW4uY2hhckF0KDApKXx8KE4oaSxpLmUrTSsyLDEpLHQ9IWkudGltZXMoaSkuZXEodGhpcykpO2JyZWFrfWlmKCFhJiYoTihzLHMuZStNKzIsMCkscy50aW1lcyhzKS5lcSh0aGlzKSkpe2k9czticmVha31sKz00LHUrPTQsYT0xfXJldHVybiBOKGksaS5lK00rMSxILHQpfSxSLnRpbWVzPVIubXVsPWZ1bmN0aW9uKHQsbil7dmFyIG8saSxhLHMsYyx1LGYsbCxwLGgsZCxtLHksZyx2LGI9dGhpcy5jLHg9KEQ9MTcsdD1uZXcgZSh0LG4pKS5jO2lmKCEoYiYmeCYmYlswXSYmeFswXSkpcmV0dXJuIXRoaXMuc3x8IXQuc3x8YiYmIWJbMF0mJiF4fHx4JiYheFswXSYmIWI/dC5jPXQuZT10LnM9bnVsbDoodC5zKj10aGlzLnMsYiYmeD8odC5jPVswXSx0LmU9MCk6dC5jPXQuZT1udWxsKSx0O2ZvcihpPXIodGhpcy5lL3cpK3IodC5lL3cpLHQucyo9dGhpcy5zLChmPWIubGVuZ3RoKTwoaD14Lmxlbmd0aCkmJih5PWIsYj14LHg9eSxhPWYsZj1oLGg9YSksYT1mK2gseT1bXTthLS07eS5wdXNoKDApKTtmb3IoZz1fLHY9QixhPWg7LS1hPj0wOyl7Zm9yKG89MCxkPXhbYV0ldixtPXhbYV0vdnwwLHM9YSsoYz1mKTtzPmE7KW89KChsPWQqKGw9YlstLWNdJXYpKyh1PW0qbCsocD1iW2NdL3Z8MCkqZCkldip2K3lbc10rbykvZ3wwKSsodS92fDApK20qcCx5W3MtLV09bCVnO3lbc109b31yZXR1cm4gbz8rK2k6eS5zcGxpY2UoMCwxKSxPKHQseSxpKX0sUi50b0RpZ2l0cz1mdW5jdGlvbih0LG4pe3ZhciByPW5ldyBlKHRoaXMpO3JldHVybiB0PW51bGwhPXQmJlcodCwxLFMsMTgsInByZWNpc2lvbiIpPzB8dDpudWxsLG49bnVsbCE9biYmVyhuLDAsOCwxOCxnKT8wfG46SCx0P04ocix0LG4pOnJ9LFIudG9FeHBvbmVudGlhbD1mdW5jdGlvbih0LGUpe3JldHVybiBBKHRoaXMsbnVsbCE9dCYmVyh0LDAsUywxOSk/MSt+fnQ6bnVsbCxlLDE5KX0sUi50b0ZpeGVkPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEEodGhpcyxudWxsIT10JiZXKHQsMCxTLDIwKT9+fnQrdGhpcy5lKzE6bnVsbCxlLDIwKX0sUi50b0Zvcm1hdD1mdW5jdGlvbih0LGUpe3ZhciBuPUEodGhpcyxudWxsIT10JiZXKHQsMCxTLDIxKT9+fnQrdGhpcy5lKzE6bnVsbCxlLDIxKTtpZih0aGlzLmMpe3ZhciByLG89bi5zcGxpdCgiLiIpLGk9K1guZ3JvdXBTaXplLGE9K1guc2Vjb25kYXJ5R3JvdXBTaXplLHM9WC5ncm91cFNlcGFyYXRvcixjPW9bMF0sdT1vWzFdLGY9dGhpcy5zPDAsbD1mP2Muc2xpY2UoMSk6YyxwPWwubGVuZ3RoO2lmKGEmJihyPWksaT1hLGE9cixwLT1yKSxpPjAmJnA+MCl7Zm9yKHI9cCVpfHxpLGM9bC5zdWJzdHIoMCxyKTtyPHA7cis9aSljKz1zK2wuc3Vic3RyKHIsaSk7YT4wJiYoYys9cytsLnNsaWNlKHIpKSxmJiYoYz0iLSIrYyl9bj11P2MrWC5kZWNpbWFsU2VwYXJhdG9yKygoYT0rWC5mcmFjdGlvbkdyb3VwU2l6ZSk/dS5yZXBsYWNlKG5ldyBSZWdFeHAoIlxcZHsiK2ErIn1cXEIiLCJnIiksIiQmIitYLmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IpOnUpOmN9cmV0dXJuIG59LFIudG9GcmFjdGlvbj1mdW5jdGlvbih0KXt2YXIgbixyLGksYSxzLGMsdSxmLGwscD1VLGg9dGhpcy5jLGQ9bmV3IGUoRSksbT1yPW5ldyBlKEUpLHk9dT1uZXcgZShFKTtpZihudWxsIT10JiYoVT0hMSxjPW5ldyBlKHQpLFU9cCwocD1jLmlzSW50KCkpJiYhYy5sdChFKXx8KFUmJkkoMjIsIm1heCBkZW5vbWluYXRvciAiKyhwPyJvdXQgb2YgcmFuZ2UiOiJub3QgYW4gaW50ZWdlciIpLHQpLHQ9IXAmJmMuYyYmTihjLGMuZSsxLDEpLmd0ZShFKT9jOm51bGwpKSwhaClyZXR1cm4gdGhpcy50b1N0cmluZygpO2ZvcihsPW8oaCksYT1kLmU9bC5sZW5ndGgtdGhpcy5lLTEsZC5jWzBdPWtbKHM9YSV3KTwwP3crczpzXSx0PSF0fHxjLmNtcChkKT4wP2E+MD9kOm06YyxzPUwsTD0xLzAsYz1uZXcgZShsKSx1LmNbMF09MDtmPVQoYyxkLDAsMSksMSE9KGk9ci5wbHVzKGYudGltZXMoeSkpKS5jbXAodCk7KXI9eSx5PWksbT11LnBsdXMoZi50aW1lcyhpPW0pKSx1PWksZD1jLm1pbnVzKGYudGltZXMoaT1kKSksYz1pO3JldHVybiBpPVQodC5taW51cyhyKSx5LDAsMSksdT11LnBsdXMoaS50aW1lcyhtKSkscj1yLnBsdXMoaS50aW1lcyh5KSksdS5zPW0ucz10aGlzLnMsYSo9MixuPVQobSx5LGEsSCkubWludXModGhpcykuYWJzKCkuY21wKFQodSxyLGEsSCkubWludXModGhpcykuYWJzKCkpPDE/W20udG9TdHJpbmcoKSx5LnRvU3RyaW5nKCldOlt1LnRvU3RyaW5nKCksci50b1N0cmluZygpXSxMPXMsbn0sUi50b051bWJlcj1mdW5jdGlvbigpe3JldHVybit0aGlzfSxSLnRvUG93ZXI9Ui5wb3c9ZnVuY3Rpb24odCxuKXt2YXIgcixvLGksYT1tKHQ8MD8tdDordCkscz10aGlzO2lmKG51bGwhPW4mJihEPTIzLG49bmV3IGUobikpLCFXKHQsLXgseCwyMywiZXhwb25lbnQiKSYmKCFpc0Zpbml0ZSh0KXx8YT54JiYodC89MCl8fHBhcnNlRmxvYXQodCkhPXQmJiEodD1OYU4pKXx8MD09dClyZXR1cm4gcj1NYXRoLnBvdygrcyx0KSxuZXcgZShuP3IlbjpyKTtmb3Iobj90PjEmJnMuZ3QoRSkmJnMuaXNJbnQoKSYmbi5ndChFKSYmbi5pc0ludCgpP3M9cy5tb2Qobik6KGk9bixuPW51bGwpOkcmJihyPWQoRy93KzIpKSxvPW5ldyBlKEUpOzspe2lmKGElMil7aWYoIShvPW8udGltZXMocykpLmMpYnJlYWs7cj9vLmMubGVuZ3RoPnImJihvLmMubGVuZ3RoPXIpOm4mJihvPW8ubW9kKG4pKX1pZighKGE9bShhLzIpKSlicmVhaztzPXMudGltZXMocykscj9zLmMmJnMuYy5sZW5ndGg+ciYmKHMuYy5sZW5ndGg9cik6biYmKHM9cy5tb2QobikpfXJldHVybiBuP286KHQ8MCYmKG89RS5kaXYobykpLGk/by5tb2QoaSk6cj9OKG8sRyxIKTpvKX0sUi50b1ByZWNpc2lvbj1mdW5jdGlvbih0LGUpe3JldHVybiBBKHRoaXMsbnVsbCE9dCYmVyh0LDEsUywyNCwicHJlY2lzaW9uIik/MHx0Om51bGwsZSwyNCl9LFIudG9TdHJpbmc9ZnVuY3Rpb24odCl7dmFyIGUsbj10aGlzLnMscj10aGlzLmU7cmV0dXJuIG51bGw9PT1yP24/KGU9IkluZmluaXR5IixuPDAmJihlPSItIitlKSk6ZT0iTmFOIjooZT1vKHRoaXMuYyksZT1udWxsIT10JiZXKHQsMiw2NCwyNSwiYmFzZSIpP3AoZihlLHIpLDB8dCwxMCxuKTpyPD1qfHxyPj1xP3UoZSxyKTpmKGUsciksbjwwJiZ0aGlzLmNbMF0mJihlPSItIitlKSksZX0sUi50cnVuY2F0ZWQ9Ui50cnVuYz1mdW5jdGlvbigpe3JldHVybiBOKG5ldyBlKHRoaXMpLHRoaXMuZSsxLDEpfSxSLnZhbHVlT2Y9Ui50b0pTT049ZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXMuZTtyZXR1cm4gbnVsbD09PWU/dGhpcy50b1N0cmluZygpOih0PW8odGhpcy5jKSx0PWU8PWp8fGU+PXE/dSh0LGUpOmYodCxlKSx0aGlzLnM8MD8iLSIrdDp0KX0sUi5pc0JpZ051bWJlcj0hMCxudWxsIT10JiZlLmNvbmZpZyh0KSxlfWZ1bmN0aW9uIHIodCl7dmFyIGU9MHx0O3JldHVybiB0PjB8fHQ9PT1lP2U6ZS0xfWZ1bmN0aW9uIG8odCl7Zm9yKHZhciBlLG4scj0xLG89dC5sZW5ndGgsaT10WzBdKyIiO3I8bzspe2ZvcihlPXRbcisrXSsiIixuPXctZS5sZW5ndGg7bi0tO2U9IjAiK2UpO2krPWV9Zm9yKG89aS5sZW5ndGg7NDg9PT1pLmNoYXJDb2RlQXQoLS1vKTspO3JldHVybiBpLnNsaWNlKDAsbysxfHwxKX1mdW5jdGlvbiBpKHQsZSl7dmFyIG4scixvPXQuYyxpPWUuYyxhPXQucyxzPWUucyxjPXQuZSx1PWUuZTtpZighYXx8IXMpcmV0dXJuIG51bGw7aWYobj1vJiYhb1swXSxyPWkmJiFpWzBdLG58fHIpcmV0dXJuIG4/cj8wOi1zOmE7aWYoYSE9cylyZXR1cm4gYTtpZihuPWE8MCxyPWM9PXUsIW98fCFpKXJldHVybiByPzA6IW9ebj8xOi0xO2lmKCFyKXJldHVybiBjPnVebj8xOi0xO2ZvcihzPShjPW8ubGVuZ3RoKTwodT1pLmxlbmd0aCk/Yzp1LGE9MDthPHM7YSsrKWlmKG9bYV0hPWlbYV0pcmV0dXJuIG9bYV0+aVthXV5uPzE6LTE7cmV0dXJuIGM9PXU/MDpjPnVebj8xOi0xfWZ1bmN0aW9uIGEodCxlLG4pe3JldHVybih0PWwodCkpPj1lJiZ0PD1ufWZ1bmN0aW9uIHModCl7cmV0dXJuIltvYmplY3QgQXJyYXldIj09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpfWZ1bmN0aW9uIGModCxlLG4pe2Zvcih2YXIgcixvLGk9WzBdLGE9MCxzPXQubGVuZ3RoO2E8czspe2ZvcihvPWkubGVuZ3RoO28tLTtpW29dKj1lKTtmb3IoaVtyPTBdKz1iLmluZGV4T2YodC5jaGFyQXQoYSsrKSk7cjxpLmxlbmd0aDtyKyspaVtyXT5uLTEmJihudWxsPT1pW3IrMV0mJihpW3IrMV09MCksaVtyKzFdKz1pW3JdL258MCxpW3JdJT1uKX1yZXR1cm4gaS5yZXZlcnNlKCl9ZnVuY3Rpb24gdSh0LGUpe3JldHVybih0Lmxlbmd0aD4xP3QuY2hhckF0KDApKyIuIit0LnNsaWNlKDEpOnQpKyhlPDA/ImUiOiJlKyIpK2V9ZnVuY3Rpb24gZih0LGUpe3ZhciBuLHI7aWYoZTwwKXtmb3Iocj0iMC4iOysrZTtyKz0iMCIpO3Q9cit0fWVsc2UgaWYobj10Lmxlbmd0aCwrK2U+bil7Zm9yKHI9IjAiLGUtPW47LS1lO3IrPSIwIik7dCs9cn1lbHNlIGU8biYmKHQ9dC5zbGljZSgwLGUpKyIuIit0LnNsaWNlKGUpKTtyZXR1cm4gdH1mdW5jdGlvbiBsKHQpe3JldHVybih0PXBhcnNlRmxvYXQodCkpPDA/ZCh0KTptKHQpfXZhciBwLGg9L14tPyhcZCsoXC5cZCopP3xcLlxkKykoZVsrLV0/XGQrKT8kL2ksZD1NYXRoLmNlaWwsbT1NYXRoLmZsb29yLHk9IiBub3QgYSBib29sZWFuIG9yIGJpbmFyeSBkaWdpdCIsZz0icm91bmRpbmcgbW9kZSIsdj0ibnVtYmVyIHR5cGUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHMiLGI9IjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8iLF89MWUxNCx3PTE0LHg9OTAwNzE5OTI1NDc0MDk5MSxrPVsxLDEwLDEwMCwxZTMsMWU0LDFlNSwxZTYsMWU3LDFlOCwxZTksMWUxMCwxZTExLDFlMTIsMWUxM10sQj0xZTcsUz0xZTk7KHA9bigpKS5kZWZhdWx0PXAuQmlnTnVtYmVyPXAsImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gcH0pOnZvaWQgMCE9PWUmJmUuZXhwb3J0cz9lLmV4cG9ydHM9cDoodHx8KHQ9InVuZGVmaW5lZCIhPXR5cGVvZiBzZWxmP3NlbGY6RnVuY3Rpb24oInJldHVybiB0aGlzIikoKSksdC5CaWdOdW1iZXI9cCl9KHRoaXMpfSx7fV0sd2ViMzpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vbGliL3dlYjMiKTsidW5kZWZpbmVkIiE9dHlwZW9mIHdpbmRvdyYmdm9pZCAwPT09d2luZG93LldlYjMmJih3aW5kb3cuV2ViMz1yKSxlLmV4cG9ydHM9cn0seyIuL2xpYi93ZWIzIjoyMn1dfSx7fSxbIndlYjMiXSk7Cn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHt9LF9kZXJlcV8oImJ1ZmZlciIpLkJ1ZmZlcikKfSx7ImJ1ZmZlciI6OTh9XSwxNDE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IGV4dGVuZAoKdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTsKCmZ1bmN0aW9uIGV4dGVuZCgpIHsKICAgIHZhciB0YXJnZXQgPSB7fQoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXQoKICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7CiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgewogICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIHJldHVybiB0YXJnZXQKfQoKfSx7fV19LHt9LFsxXSk7Cg==","base64").toString();
var inpageSuffix = '//# sourceURL=' + extension.extension.getURL('scripts/inpage.js') + '\n';
var inpageBundle = inpageContent + inpageSuffix;

// Eventually this streaming injection could be replaced with:
// https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Language_Bindings/Components.utils.exportFunction
//
// But for now that is only Firefox
// If we create a FireFox-only code path using that API,
// MetaMask will be much faster loading and performant on Firefox.

if (shouldInjectWeb3()) {
  setupInjection();
  setupStreams();
}

function setupInjection() {
  try {
    // inject in-page script
    var scriptTag = document.createElement('script');
    scriptTag.textContent = inpageBundle;
    scriptTag.onload = function () {
      this.parentNode.removeChild(this);
    };
    var container = document.head || document.documentElement;
    // append as first child
    container.insertBefore(scriptTag, container.children[0]);
  } catch (e) {
    console.error('eIncMeta injection failed.', e);
  }
}

function setupStreams() {
  // setup communication to page and plugin
  var pageStream = new LocalMessageDuplexStream({
    name: 'contentscript',
    target: 'inpage'
  });
  var pluginPort = extension.runtime.connect({ name: 'contentscript' });
  var pluginStream = new PortStream(pluginPort);

  // forward communication plugin->inpage
  pump(pageStream, pluginStream, pageStream, function (err) {
    return logStreamDisconnectWarning('eIncMeta Contentscript Forwarding', err);
  });

  // setup local multistream channels
  var mux = new ObjectMultiplex();
  mux.setMaxListeners(25);

  pump(mux, pageStream, mux, function (err) {
    return logStreamDisconnectWarning('eIncMeta Inpage', err);
  });
  pump(mux, pluginStream, mux, function (err) {
    return logStreamDisconnectWarning('eIncMeta Background', err);
  });

  // connect ping stream
  var pongStream = new PongStream({ objectMode: true });
  pump(mux, pongStream, mux, function (err) {
    return logStreamDisconnectWarning('eIncMeta PingPongStream', err);
  });

  // connect phishing warning stream
  var phishingStream = mux.createStream('phishing');
  phishingStream.once('data', redirectToPhishingWarning);

  // ignore unused channels (handled by background, inpage)
  mux.ignoreStream('provider');
  mux.ignoreStream('publicConfig');
}

function logStreamDisconnectWarning(remoteLabel, err) {
  var warningMsg = 'eIncMetaContentscript - lost connection to ' + remoteLabel;
  if (err) warningMsg += '\n' + err.stack;
  console.warn(warningMsg);
}

function shouldInjectWeb3() {
  return doctypeCheck() && suffixCheck() && documentElementCheck();
}

function doctypeCheck() {
  var doctype = window.document.doctype;
  if (doctype) {
    return doctype.name === 'html';
  } else {
    return true;
  }
}

function suffixCheck() {
  var prohibitedTypes = ['xml', 'pdf'];
  var currentUrl = window.location.href;
  var currentRegex;
  for (var i = 0; i < prohibitedTypes.length; i++) {
    currentRegex = new RegExp('\\.' + prohibitedTypes[i] + '$');
    if (currentRegex.test(currentUrl)) {
      return false;
    }
  }
  return true;
}

function documentElementCheck() {
  var documentElement = document.documentElement.nodeName;
  if (documentElement) {
    return documentElement.toLowerCase() === 'html';
  }
  return true;
}

function redirectToPhishingWarning() {
  console.log('eIncMeta - redirecting to phishing warning');
  window.location.href = 'https://einc.io/phishing.html';
}

}).call(this,_dereq_("buffer").Buffer)
},{"./lib/port-stream.js":2,"buffer":5,"extensionizer":11,"obj-multiplex":16,"path":19,"ping-pong-stream/pong":20,"post-message-stream":21,"pump":23}],2:[function(_dereq_,module,exports){
(function (Buffer){
'use strict';

var Duplex = _dereq_('readable-stream').Duplex;
var inherits = _dereq_('util').inherits;
var noop = function noop() {};

module.exports = PortDuplexStream;

inherits(PortDuplexStream, Duplex);

function PortDuplexStream(port) {
  Duplex.call(this, {
    objectMode: true
  });
  this._port = port;
  port.onMessage.addListener(this._onMessage.bind(this));
  port.onDisconnect.addListener(this._onDisconnect.bind(this));
}

// private

PortDuplexStream.prototype._onMessage = function (msg) {
  if (Buffer.isBuffer(msg)) {
    delete msg._isBuffer;
    var data = new Buffer(msg);
    this.push(data);
  } else {
    this.push(msg);
  }
};

PortDuplexStream.prototype._onDisconnect = function () {
  this.destroy();
};

// stream plumbing

PortDuplexStream.prototype._read = noop;

PortDuplexStream.prototype._write = function (msg, encoding, cb) {
  try {
    if (Buffer.isBuffer(msg)) {
      var data = msg.toJSON();
      data._isBuffer = true;
      this._port.postMessage(data);
    } else {
      this._port.postMessage(msg);
    }
  } catch (err) {
    return cb(new Error('PortDuplexStream - disconnected'));
  }
  cb();
};

}).call(this,_dereq_("buffer").Buffer)
},{"buffer":5,"readable-stream":34,"util":38}],3:[function(_dereq_,module,exports){

},{}],4:[function(_dereq_,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],5:[function(_dereq_,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = _dereq_('base64-js')
var ieee754 = _dereq_('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":4,"ieee754":12}],6:[function(_dereq_,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],7:[function(_dereq_,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":_dereq_("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":14}],8:[function(_dereq_,module,exports){
var once = _dereq_('once');

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;

},{"once":18}],9:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],10:[function(_dereq_,module,exports){
const apis = [
  'alarms',
  'bookmarks',
  'browserAction',
  'commands',
  'contextMenus',
  'cookies',
  'downloads',
  'events',
  'extension',
  'extensionTypes',
  'history',
  'i18n',
  'idle',
  'notifications',
  'pageAction',
  'runtime',
  'storage',
  'tabs',
  'webNavigation',
  'webRequest',
  'windows',
]

function Extension () {
  const _this = this

  apis.forEach(function (api) {

    _this[api] = null

    try {
      if (chrome[api]) {
        _this[api] = chrome[api]
      }
    } catch (e) {}

    try {
      if (window[api]) {
        _this[api] = window[api]
      }
    } catch (e) {}

    try {
      if (browser[api]) {
        _this[api] = browser[api]
      }
    } catch (e) {}
    try {
      _this.api = browser.extension[api]
    } catch (e) {}
  })

  try {
    if (browser && browser.runtime) {
      this.runtime = browser.runtime
    }
  } catch (e) {}

  try {
    if (browser && browser.browserAction) {
      this.browserAction = browser.browserAction
    }
  } catch (e) {}

}

module.exports = Extension

},{}],11:[function(_dereq_,module,exports){
/* Extension.js
 *
 * A module for unifying browser differences in the WebExtension API.
 *
 * Initially implemented because Chrome hides all of their WebExtension API
 * behind a global `chrome` variable, but we'd like to start grooming
 * the code-base for cross-browser extension support.
 *
 * You can read more about the WebExtension API here:
 * https://developer.mozilla.org/en-US/Add-ons/WebExtensions
 */

const Extension = _dereq_('./extension-instance')
module.exports = new Extension()

},{"./extension-instance":10}],12:[function(_dereq_,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],13:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],14:[function(_dereq_,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],15:[function(_dereq_,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],16:[function(_dereq_,module,exports){
const { Duplex } = _dereq_('readable-stream')
const endOfStream = _dereq_('end-of-stream')
const once = _dereq_('once')
const noop = () => {}

const IGNORE_SUBSTREAM = {}


class ObjectMultiplex extends Duplex {

  constructor(_opts = {}) {
    const opts = Object.assign({}, _opts, {
      objectMode: true,
    })
    super(opts)

    this._substreams = {}
  }

  createStream (name) {
    // validate name
    if (!name) throw new Error('ObjectMultiplex - name must not be empty')
    if (this._substreams[name]) throw new Error('ObjectMultiplex - Substream for name "${name}" already exists')

    // create substream
    const substream = new Substream({ parent: this, name: name })
    this._substreams[name] = substream

    // listen for parent stream to end
    anyStreamEnd(this, (err) => {
      substream.destroy(err)
    })

    return substream
  }

  // ignore streams (dont display orphaned data warning)
  ignoreStream (name) {
    // validate name
    if (!name) throw new Error('ObjectMultiplex - name must not be empty')
    if (this._substreams[name]) throw new Error('ObjectMultiplex - Substream for name "${name}" already exists')
    // set
    this._substreams[name] = IGNORE_SUBSTREAM
  }

  // stream plumbing

  _read () {}

  _write(chunk, encoding, callback) {
    // parse message
    const name = chunk.name
    const data = chunk.data
    if (!name) {
      console.warn(`ObjectMultiplex - malformed chunk without name "${chunk}"`)
      return callback()
    }

    // get corresponding substream
    const substream = this._substreams[name]
    if (!substream) {
      console.warn(`ObjectMultiplex - orphaned data for stream "${name}"`)
      return callback()
    }

    // push data into substream
    if (substream !== IGNORE_SUBSTREAM) {
      substream.push(data)
    }

    callback()
  }

}


class Substream extends Duplex {

  constructor ({ parent, name }) {
    super({
      objectMode: true,
    })

    this._parent = parent
    this._name = name
  }

  _read () {}

  _write (chunk, enc, callback) {
    this._parent.push({
      name: this._name,
      data: chunk,
    })
    callback()
  }

}

module.exports = ObjectMultiplex

// util

function anyStreamEnd(stream, _cb) {
  const cb = once(_cb)
  endOfStream(stream, { readable: false }, cb)
  endOfStream(stream, { writable: false }, cb)
}
},{"end-of-stream":8,"once":18,"readable-stream":34}],17:[function(_dereq_,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}],18:[function(_dereq_,module,exports){
var wrappy = _dereq_('wrappy')
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}

},{"wrappy":17}],19:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,_dereq_('_process'))
},{"_process":6}],20:[function(_dereq_,module,exports){
const Duplex = _dereq_('readable-stream').Duplex
const inherits = _dereq_('util').inherits

module.exports = PongStream

inherits(PongStream, Duplex)

function PongStream (opts) {
  const self = this
  opts = opts || {}
  Duplex.call(this, opts)
  self._heartbeatRequest = opts.heartbeatRequest || 'ping'
  self._heartbeatResponse = opts.heartbeatResponse || 'pong'
}

// private

PongStream.prototype._sendResponse = function (msg) {
  const self = this
  self.push(self._heartbeatResponse)
}

// stream plumbing

PongStream.prototype._read = noop

PongStream.prototype._write = function (msg, encoding, cb) {
  const self = this
  if (msg.toString() === self._heartbeatRequest.toString()) {
    // heartbeat heard
    self._sendResponse()
    cb()
  } else {
    // unknown message
    cb(new Error('PongStream - unknown request'))
  }
  
}

// util

function noop() {}
},{"readable-stream":34,"util":38}],21:[function(_dereq_,module,exports){
const DuplexStream = _dereq_('readable-stream').Duplex
const inherits = _dereq_('util').inherits

module.exports = PostMessageStream

inherits(PostMessageStream, DuplexStream)

function PostMessageStream (opts) {
  DuplexStream.call(this, {
    objectMode: true,
  })

  this._name = opts.name
  this._target = opts.target
  this._targetWindow = opts.targetWindow || window
  this._origin = (opts.targetWindow ? '*' : location.origin)

  // initialization flags
  this._init = false
  this._haveSyn = false

  window.addEventListener('message', this._onMessage.bind(this), false)
  // send syncorization message
  this._write('SYN', null, noop)
  this.cork()
}

// private
PostMessageStream.prototype._onMessage = function (event) {
  var msg = event.data

  // validate message
  if (this._origin !== '*' && event.origin !== this._origin) return
  if (event.source !== this._targetWindow) return
  if (typeof msg !== 'object') return
  if (msg.target !== this._name) return
  if (!msg.data) return

  if (!this._init) {
    if (msg.data === 'SYN') {
      this._haveSyn = true
      this._write('ACK', null, noop)
    } else if (msg.data === 'ACK') {
      this._init = true
      if (!this._haveSyn) {
        this._write('ACK', null, noop)
      }
      this.uncork()
    }
  } else {
    // forward message
    try {
      this.push(msg.data)
    } catch (err) {
      this.emit('error', err)
    }
  }
}

// stream plumbing
PostMessageStream.prototype._read = noop

PostMessageStream.prototype._write = function (data, encoding, cb) {
  var message = {
    target: this._target,
    data: data,
  }
  this._targetWindow.postMessage(message, this._origin)
  cb()
}

// util

function noop () {}

},{"readable-stream":34,"util":38}],22:[function(_dereq_,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,_dereq_('_process'))
},{"_process":6}],23:[function(_dereq_,module,exports){
var once = _dereq_('once')
var eos = _dereq_('end-of-stream')
var fs = _dereq_('fs') // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump

},{"end-of-stream":8,"fs":3,"once":18}],24:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var Readable = _dereq_('./_stream_readable');
var Writable = _dereq_('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  processNextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":26,"./_stream_writable":28,"core-util-is":7,"inherits":13,"process-nextick-args":22}],25:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = _dereq_('./_stream_transform');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":27,"core-util-is":7,"inherits":13}],26:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = _dereq_('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = _dereq_('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = _dereq_('./internal/streams/stream');
/*</replacement>*/

// TODO(bmeurer): Change this back to const once hole checks are
// properly optimized away early in Ignition+TurboFan.
/*<replacement>*/
var Buffer = _dereq_('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = _dereq_('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = _dereq_('./internal/streams/BufferList');
var destroyImpl = _dereq_('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":24,"./internal/streams/BufferList":29,"./internal/streams/destroy":30,"./internal/streams/stream":31,"_process":6,"core-util-is":7,"events":9,"inherits":13,"isarray":15,"process-nextick-args":22,"safe-buffer":32,"string_decoder/":33,"util":3}],27:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = _dereq_('./_stream_duplex');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return stream.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":24,"core-util-is":7,"inherits":13}],28:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: _dereq_('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = _dereq_('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/
var Buffer = _dereq_('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

var destroyImpl = _dereq_('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    processNextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    processNextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      processNextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":24,"./internal/streams/destroy":30,"./internal/streams/stream":31,"_process":6,"core-util-is":7,"inherits":13,"process-nextick-args":22,"safe-buffer":32,"util-deprecate":35}],29:[function(_dereq_,module,exports){
'use strict';

/*<replacement>*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = _dereq_('safe-buffer').Buffer;
/*</replacement>*/

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();
},{"safe-buffer":32}],30:[function(_dereq_,module,exports){
'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      processNextTick(emitErrorNT, this, err);
    }
    return;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      processNextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":22}],31:[function(_dereq_,module,exports){
module.exports = _dereq_('events').EventEmitter;

},{"events":9}],32:[function(_dereq_,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = _dereq_('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":5}],33:[function(_dereq_,module,exports){
'use strict';

var Buffer = _dereq_('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":32}],34:[function(_dereq_,module,exports){
exports = module.exports = _dereq_('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = _dereq_('./lib/_stream_writable.js');
exports.Duplex = _dereq_('./lib/_stream_duplex.js');
exports.Transform = _dereq_('./lib/_stream_transform.js');
exports.PassThrough = _dereq_('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":24,"./lib/_stream_passthrough.js":25,"./lib/_stream_readable.js":26,"./lib/_stream_transform.js":27,"./lib/_stream_writable.js":28}],35:[function(_dereq_,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],36:[function(_dereq_,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],37:[function(_dereq_,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],38:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = _dereq_('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = _dereq_('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":37,"_process":6,"inherits":36}]},{},[1]);
